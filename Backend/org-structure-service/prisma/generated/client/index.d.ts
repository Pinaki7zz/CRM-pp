
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model BusinessEntity
 * 
 */
export type BusinessEntity = $Result.DefaultSelection<Prisma.$BusinessEntityPayload>
/**
 * Model BusinessUnit
 * 
 */
export type BusinessUnit = $Result.DefaultSelection<Prisma.$BusinessUnitPayload>
/**
 * Model BusinessEntityUnitPair
 * 
 */
export type BusinessEntityUnitPair = $Result.DefaultSelection<Prisma.$BusinessEntityUnitPairPayload>
/**
 * Model SalesChannel
 * 
 */
export type SalesChannel = $Result.DefaultSelection<Prisma.$SalesChannelPayload>
/**
 * Model SalesOffice
 * 
 */
export type SalesOffice = $Result.DefaultSelection<Prisma.$SalesOfficePayload>
/**
 * Model SalesTeam
 * 
 */
export type SalesTeam = $Result.DefaultSelection<Prisma.$SalesTeamPayload>
/**
 * Model SalesChannelOfficeTeamPair
 * 
 */
export type SalesChannelOfficeTeamPair = $Result.DefaultSelection<Prisma.$SalesChannelOfficeTeamPairPayload>
/**
 * Model MarketingChannel
 * 
 */
export type MarketingChannel = $Result.DefaultSelection<Prisma.$MarketingChannelPayload>
/**
 * Model MarketingOffice
 * 
 */
export type MarketingOffice = $Result.DefaultSelection<Prisma.$MarketingOfficePayload>
/**
 * Model MarketingTeam
 * 
 */
export type MarketingTeam = $Result.DefaultSelection<Prisma.$MarketingTeamPayload>
/**
 * Model MarketingChannelOfficeTeamPair
 * 
 */
export type MarketingChannelOfficeTeamPair = $Result.DefaultSelection<Prisma.$MarketingChannelOfficeTeamPairPayload>
/**
 * Model ServiceChannel
 * 
 */
export type ServiceChannel = $Result.DefaultSelection<Prisma.$ServiceChannelPayload>
/**
 * Model ServiceOffice
 * 
 */
export type ServiceOffice = $Result.DefaultSelection<Prisma.$ServiceOfficePayload>
/**
 * Model ServiceTeam
 * 
 */
export type ServiceTeam = $Result.DefaultSelection<Prisma.$ServiceTeamPayload>
/**
 * Model ServiceChannelOfficeTeamPair
 * 
 */
export type ServiceChannelOfficeTeamPair = $Result.DefaultSelection<Prisma.$ServiceChannelOfficeTeamPairPayload>
/**
 * Model BusinessUnitSalesPair
 * 
 */
export type BusinessUnitSalesPair = $Result.DefaultSelection<Prisma.$BusinessUnitSalesPairPayload>
/**
 * Model BusinessUnitMarketingPair
 * 
 */
export type BusinessUnitMarketingPair = $Result.DefaultSelection<Prisma.$BusinessUnitMarketingPairPayload>
/**
 * Model BusinessUnitServicePair
 * 
 */
export type BusinessUnitServicePair = $Result.DefaultSelection<Prisma.$BusinessUnitServicePairPayload>
/**
 * Model SalesTeamManager
 * 
 */
export type SalesTeamManager = $Result.DefaultSelection<Prisma.$SalesTeamManagerPayload>
/**
 * Model MarketingTeamManager
 * 
 */
export type MarketingTeamManager = $Result.DefaultSelection<Prisma.$MarketingTeamManagerPayload>
/**
 * Model ServiceTeamManager
 * 
 */
export type ServiceTeamManager = $Result.DefaultSelection<Prisma.$ServiceTeamManagerPayload>
/**
 * Model SalesTeamEmployee
 * 
 */
export type SalesTeamEmployee = $Result.DefaultSelection<Prisma.$SalesTeamEmployeePayload>
/**
 * Model MarketingTeamEmployee
 * 
 */
export type MarketingTeamEmployee = $Result.DefaultSelection<Prisma.$MarketingTeamEmployeePayload>
/**
 * Model ServiceTeamEmployee
 * 
 */
export type ServiceTeamEmployee = $Result.DefaultSelection<Prisma.$ServiceTeamEmployeePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Language: {
  EN: 'EN',
  ES: 'ES',
  FR: 'FR',
  DE: 'DE',
  IT: 'IT',
  NL: 'NL',
  ID: 'ID',
  VI: 'VI'
};

export type Language = (typeof Language)[keyof typeof Language]

}

export type Language = $Enums.Language

export const Language: typeof $Enums.Language

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more BusinessEntities
 * const businessEntities = await prisma.businessEntity.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more BusinessEntities
   * const businessEntities = await prisma.businessEntity.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.businessEntity`: Exposes CRUD operations for the **BusinessEntity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessEntities
    * const businessEntities = await prisma.businessEntity.findMany()
    * ```
    */
  get businessEntity(): Prisma.BusinessEntityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.businessUnit`: Exposes CRUD operations for the **BusinessUnit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessUnits
    * const businessUnits = await prisma.businessUnit.findMany()
    * ```
    */
  get businessUnit(): Prisma.BusinessUnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.businessEntityUnitPair`: Exposes CRUD operations for the **BusinessEntityUnitPair** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessEntityUnitPairs
    * const businessEntityUnitPairs = await prisma.businessEntityUnitPair.findMany()
    * ```
    */
  get businessEntityUnitPair(): Prisma.BusinessEntityUnitPairDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesChannel`: Exposes CRUD operations for the **SalesChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesChannels
    * const salesChannels = await prisma.salesChannel.findMany()
    * ```
    */
  get salesChannel(): Prisma.SalesChannelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesOffice`: Exposes CRUD operations for the **SalesOffice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesOffices
    * const salesOffices = await prisma.salesOffice.findMany()
    * ```
    */
  get salesOffice(): Prisma.SalesOfficeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesTeam`: Exposes CRUD operations for the **SalesTeam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesTeams
    * const salesTeams = await prisma.salesTeam.findMany()
    * ```
    */
  get salesTeam(): Prisma.SalesTeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesChannelOfficeTeamPair`: Exposes CRUD operations for the **SalesChannelOfficeTeamPair** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesChannelOfficeTeamPairs
    * const salesChannelOfficeTeamPairs = await prisma.salesChannelOfficeTeamPair.findMany()
    * ```
    */
  get salesChannelOfficeTeamPair(): Prisma.SalesChannelOfficeTeamPairDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketingChannel`: Exposes CRUD operations for the **MarketingChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketingChannels
    * const marketingChannels = await prisma.marketingChannel.findMany()
    * ```
    */
  get marketingChannel(): Prisma.MarketingChannelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketingOffice`: Exposes CRUD operations for the **MarketingOffice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketingOffices
    * const marketingOffices = await prisma.marketingOffice.findMany()
    * ```
    */
  get marketingOffice(): Prisma.MarketingOfficeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketingTeam`: Exposes CRUD operations for the **MarketingTeam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketingTeams
    * const marketingTeams = await prisma.marketingTeam.findMany()
    * ```
    */
  get marketingTeam(): Prisma.MarketingTeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketingChannelOfficeTeamPair`: Exposes CRUD operations for the **MarketingChannelOfficeTeamPair** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketingChannelOfficeTeamPairs
    * const marketingChannelOfficeTeamPairs = await prisma.marketingChannelOfficeTeamPair.findMany()
    * ```
    */
  get marketingChannelOfficeTeamPair(): Prisma.MarketingChannelOfficeTeamPairDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceChannel`: Exposes CRUD operations for the **ServiceChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceChannels
    * const serviceChannels = await prisma.serviceChannel.findMany()
    * ```
    */
  get serviceChannel(): Prisma.ServiceChannelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceOffice`: Exposes CRUD operations for the **ServiceOffice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceOffices
    * const serviceOffices = await prisma.serviceOffice.findMany()
    * ```
    */
  get serviceOffice(): Prisma.ServiceOfficeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceTeam`: Exposes CRUD operations for the **ServiceTeam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceTeams
    * const serviceTeams = await prisma.serviceTeam.findMany()
    * ```
    */
  get serviceTeam(): Prisma.ServiceTeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceChannelOfficeTeamPair`: Exposes CRUD operations for the **ServiceChannelOfficeTeamPair** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceChannelOfficeTeamPairs
    * const serviceChannelOfficeTeamPairs = await prisma.serviceChannelOfficeTeamPair.findMany()
    * ```
    */
  get serviceChannelOfficeTeamPair(): Prisma.ServiceChannelOfficeTeamPairDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.businessUnitSalesPair`: Exposes CRUD operations for the **BusinessUnitSalesPair** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessUnitSalesPairs
    * const businessUnitSalesPairs = await prisma.businessUnitSalesPair.findMany()
    * ```
    */
  get businessUnitSalesPair(): Prisma.BusinessUnitSalesPairDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.businessUnitMarketingPair`: Exposes CRUD operations for the **BusinessUnitMarketingPair** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessUnitMarketingPairs
    * const businessUnitMarketingPairs = await prisma.businessUnitMarketingPair.findMany()
    * ```
    */
  get businessUnitMarketingPair(): Prisma.BusinessUnitMarketingPairDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.businessUnitServicePair`: Exposes CRUD operations for the **BusinessUnitServicePair** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessUnitServicePairs
    * const businessUnitServicePairs = await prisma.businessUnitServicePair.findMany()
    * ```
    */
  get businessUnitServicePair(): Prisma.BusinessUnitServicePairDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesTeamManager`: Exposes CRUD operations for the **SalesTeamManager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesTeamManagers
    * const salesTeamManagers = await prisma.salesTeamManager.findMany()
    * ```
    */
  get salesTeamManager(): Prisma.SalesTeamManagerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketingTeamManager`: Exposes CRUD operations for the **MarketingTeamManager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketingTeamManagers
    * const marketingTeamManagers = await prisma.marketingTeamManager.findMany()
    * ```
    */
  get marketingTeamManager(): Prisma.MarketingTeamManagerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceTeamManager`: Exposes CRUD operations for the **ServiceTeamManager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceTeamManagers
    * const serviceTeamManagers = await prisma.serviceTeamManager.findMany()
    * ```
    */
  get serviceTeamManager(): Prisma.ServiceTeamManagerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salesTeamEmployee`: Exposes CRUD operations for the **SalesTeamEmployee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesTeamEmployees
    * const salesTeamEmployees = await prisma.salesTeamEmployee.findMany()
    * ```
    */
  get salesTeamEmployee(): Prisma.SalesTeamEmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marketingTeamEmployee`: Exposes CRUD operations for the **MarketingTeamEmployee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MarketingTeamEmployees
    * const marketingTeamEmployees = await prisma.marketingTeamEmployee.findMany()
    * ```
    */
  get marketingTeamEmployee(): Prisma.MarketingTeamEmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceTeamEmployee`: Exposes CRUD operations for the **ServiceTeamEmployee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceTeamEmployees
    * const serviceTeamEmployees = await prisma.serviceTeamEmployee.findMany()
    * ```
    */
  get serviceTeamEmployee(): Prisma.ServiceTeamEmployeeDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.1
   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    BusinessEntity: 'BusinessEntity',
    BusinessUnit: 'BusinessUnit',
    BusinessEntityUnitPair: 'BusinessEntityUnitPair',
    SalesChannel: 'SalesChannel',
    SalesOffice: 'SalesOffice',
    SalesTeam: 'SalesTeam',
    SalesChannelOfficeTeamPair: 'SalesChannelOfficeTeamPair',
    MarketingChannel: 'MarketingChannel',
    MarketingOffice: 'MarketingOffice',
    MarketingTeam: 'MarketingTeam',
    MarketingChannelOfficeTeamPair: 'MarketingChannelOfficeTeamPair',
    ServiceChannel: 'ServiceChannel',
    ServiceOffice: 'ServiceOffice',
    ServiceTeam: 'ServiceTeam',
    ServiceChannelOfficeTeamPair: 'ServiceChannelOfficeTeamPair',
    BusinessUnitSalesPair: 'BusinessUnitSalesPair',
    BusinessUnitMarketingPair: 'BusinessUnitMarketingPair',
    BusinessUnitServicePair: 'BusinessUnitServicePair',
    SalesTeamManager: 'SalesTeamManager',
    MarketingTeamManager: 'MarketingTeamManager',
    ServiceTeamManager: 'ServiceTeamManager',
    SalesTeamEmployee: 'SalesTeamEmployee',
    MarketingTeamEmployee: 'MarketingTeamEmployee',
    ServiceTeamEmployee: 'ServiceTeamEmployee'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "businessEntity" | "businessUnit" | "businessEntityUnitPair" | "salesChannel" | "salesOffice" | "salesTeam" | "salesChannelOfficeTeamPair" | "marketingChannel" | "marketingOffice" | "marketingTeam" | "marketingChannelOfficeTeamPair" | "serviceChannel" | "serviceOffice" | "serviceTeam" | "serviceChannelOfficeTeamPair" | "businessUnitSalesPair" | "businessUnitMarketingPair" | "businessUnitServicePair" | "salesTeamManager" | "marketingTeamManager" | "serviceTeamManager" | "salesTeamEmployee" | "marketingTeamEmployee" | "serviceTeamEmployee"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      BusinessEntity: {
        payload: Prisma.$BusinessEntityPayload<ExtArgs>
        fields: Prisma.BusinessEntityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessEntityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessEntityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityPayload>
          }
          findFirst: {
            args: Prisma.BusinessEntityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessEntityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityPayload>
          }
          findMany: {
            args: Prisma.BusinessEntityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityPayload>[]
          }
          create: {
            args: Prisma.BusinessEntityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityPayload>
          }
          createMany: {
            args: Prisma.BusinessEntityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessEntityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityPayload>[]
          }
          delete: {
            args: Prisma.BusinessEntityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityPayload>
          }
          update: {
            args: Prisma.BusinessEntityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityPayload>
          }
          deleteMany: {
            args: Prisma.BusinessEntityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessEntityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BusinessEntityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityPayload>[]
          }
          upsert: {
            args: Prisma.BusinessEntityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityPayload>
          }
          aggregate: {
            args: Prisma.BusinessEntityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessEntity>
          }
          groupBy: {
            args: Prisma.BusinessEntityGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessEntityGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessEntityCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessEntityCountAggregateOutputType> | number
          }
        }
      }
      BusinessUnit: {
        payload: Prisma.$BusinessUnitPayload<ExtArgs>
        fields: Prisma.BusinessUnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessUnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessUnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitPayload>
          }
          findFirst: {
            args: Prisma.BusinessUnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessUnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitPayload>
          }
          findMany: {
            args: Prisma.BusinessUnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitPayload>[]
          }
          create: {
            args: Prisma.BusinessUnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitPayload>
          }
          createMany: {
            args: Prisma.BusinessUnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessUnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitPayload>[]
          }
          delete: {
            args: Prisma.BusinessUnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitPayload>
          }
          update: {
            args: Prisma.BusinessUnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitPayload>
          }
          deleteMany: {
            args: Prisma.BusinessUnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessUnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BusinessUnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitPayload>[]
          }
          upsert: {
            args: Prisma.BusinessUnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitPayload>
          }
          aggregate: {
            args: Prisma.BusinessUnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessUnit>
          }
          groupBy: {
            args: Prisma.BusinessUnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessUnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessUnitCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessUnitCountAggregateOutputType> | number
          }
        }
      }
      BusinessEntityUnitPair: {
        payload: Prisma.$BusinessEntityUnitPairPayload<ExtArgs>
        fields: Prisma.BusinessEntityUnitPairFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessEntityUnitPairFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityUnitPairPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessEntityUnitPairFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityUnitPairPayload>
          }
          findFirst: {
            args: Prisma.BusinessEntityUnitPairFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityUnitPairPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessEntityUnitPairFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityUnitPairPayload>
          }
          findMany: {
            args: Prisma.BusinessEntityUnitPairFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityUnitPairPayload>[]
          }
          create: {
            args: Prisma.BusinessEntityUnitPairCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityUnitPairPayload>
          }
          createMany: {
            args: Prisma.BusinessEntityUnitPairCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessEntityUnitPairCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityUnitPairPayload>[]
          }
          delete: {
            args: Prisma.BusinessEntityUnitPairDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityUnitPairPayload>
          }
          update: {
            args: Prisma.BusinessEntityUnitPairUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityUnitPairPayload>
          }
          deleteMany: {
            args: Prisma.BusinessEntityUnitPairDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessEntityUnitPairUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BusinessEntityUnitPairUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityUnitPairPayload>[]
          }
          upsert: {
            args: Prisma.BusinessEntityUnitPairUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessEntityUnitPairPayload>
          }
          aggregate: {
            args: Prisma.BusinessEntityUnitPairAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessEntityUnitPair>
          }
          groupBy: {
            args: Prisma.BusinessEntityUnitPairGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessEntityUnitPairGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessEntityUnitPairCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessEntityUnitPairCountAggregateOutputType> | number
          }
        }
      }
      SalesChannel: {
        payload: Prisma.$SalesChannelPayload<ExtArgs>
        fields: Prisma.SalesChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelPayload>
          }
          findFirst: {
            args: Prisma.SalesChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelPayload>
          }
          findMany: {
            args: Prisma.SalesChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelPayload>[]
          }
          create: {
            args: Prisma.SalesChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelPayload>
          }
          createMany: {
            args: Prisma.SalesChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesChannelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelPayload>[]
          }
          delete: {
            args: Prisma.SalesChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelPayload>
          }
          update: {
            args: Prisma.SalesChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelPayload>
          }
          deleteMany: {
            args: Prisma.SalesChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesChannelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelPayload>[]
          }
          upsert: {
            args: Prisma.SalesChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelPayload>
          }
          aggregate: {
            args: Prisma.SalesChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesChannel>
          }
          groupBy: {
            args: Prisma.SalesChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesChannelCountArgs<ExtArgs>
            result: $Utils.Optional<SalesChannelCountAggregateOutputType> | number
          }
        }
      }
      SalesOffice: {
        payload: Prisma.$SalesOfficePayload<ExtArgs>
        fields: Prisma.SalesOfficeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesOfficeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOfficePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesOfficeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOfficePayload>
          }
          findFirst: {
            args: Prisma.SalesOfficeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOfficePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesOfficeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOfficePayload>
          }
          findMany: {
            args: Prisma.SalesOfficeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOfficePayload>[]
          }
          create: {
            args: Prisma.SalesOfficeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOfficePayload>
          }
          createMany: {
            args: Prisma.SalesOfficeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesOfficeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOfficePayload>[]
          }
          delete: {
            args: Prisma.SalesOfficeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOfficePayload>
          }
          update: {
            args: Prisma.SalesOfficeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOfficePayload>
          }
          deleteMany: {
            args: Prisma.SalesOfficeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesOfficeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesOfficeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOfficePayload>[]
          }
          upsert: {
            args: Prisma.SalesOfficeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesOfficePayload>
          }
          aggregate: {
            args: Prisma.SalesOfficeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesOffice>
          }
          groupBy: {
            args: Prisma.SalesOfficeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesOfficeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesOfficeCountArgs<ExtArgs>
            result: $Utils.Optional<SalesOfficeCountAggregateOutputType> | number
          }
        }
      }
      SalesTeam: {
        payload: Prisma.$SalesTeamPayload<ExtArgs>
        fields: Prisma.SalesTeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesTeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesTeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamPayload>
          }
          findFirst: {
            args: Prisma.SalesTeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesTeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamPayload>
          }
          findMany: {
            args: Prisma.SalesTeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamPayload>[]
          }
          create: {
            args: Prisma.SalesTeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamPayload>
          }
          createMany: {
            args: Prisma.SalesTeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesTeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamPayload>[]
          }
          delete: {
            args: Prisma.SalesTeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamPayload>
          }
          update: {
            args: Prisma.SalesTeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamPayload>
          }
          deleteMany: {
            args: Prisma.SalesTeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesTeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesTeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamPayload>[]
          }
          upsert: {
            args: Prisma.SalesTeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamPayload>
          }
          aggregate: {
            args: Prisma.SalesTeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesTeam>
          }
          groupBy: {
            args: Prisma.SalesTeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesTeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesTeamCountArgs<ExtArgs>
            result: $Utils.Optional<SalesTeamCountAggregateOutputType> | number
          }
        }
      }
      SalesChannelOfficeTeamPair: {
        payload: Prisma.$SalesChannelOfficeTeamPairPayload<ExtArgs>
        fields: Prisma.SalesChannelOfficeTeamPairFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesChannelOfficeTeamPairFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelOfficeTeamPairPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesChannelOfficeTeamPairFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelOfficeTeamPairPayload>
          }
          findFirst: {
            args: Prisma.SalesChannelOfficeTeamPairFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelOfficeTeamPairPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesChannelOfficeTeamPairFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelOfficeTeamPairPayload>
          }
          findMany: {
            args: Prisma.SalesChannelOfficeTeamPairFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelOfficeTeamPairPayload>[]
          }
          create: {
            args: Prisma.SalesChannelOfficeTeamPairCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelOfficeTeamPairPayload>
          }
          createMany: {
            args: Prisma.SalesChannelOfficeTeamPairCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesChannelOfficeTeamPairCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelOfficeTeamPairPayload>[]
          }
          delete: {
            args: Prisma.SalesChannelOfficeTeamPairDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelOfficeTeamPairPayload>
          }
          update: {
            args: Prisma.SalesChannelOfficeTeamPairUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelOfficeTeamPairPayload>
          }
          deleteMany: {
            args: Prisma.SalesChannelOfficeTeamPairDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesChannelOfficeTeamPairUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesChannelOfficeTeamPairUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelOfficeTeamPairPayload>[]
          }
          upsert: {
            args: Prisma.SalesChannelOfficeTeamPairUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesChannelOfficeTeamPairPayload>
          }
          aggregate: {
            args: Prisma.SalesChannelOfficeTeamPairAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesChannelOfficeTeamPair>
          }
          groupBy: {
            args: Prisma.SalesChannelOfficeTeamPairGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesChannelOfficeTeamPairGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesChannelOfficeTeamPairCountArgs<ExtArgs>
            result: $Utils.Optional<SalesChannelOfficeTeamPairCountAggregateOutputType> | number
          }
        }
      }
      MarketingChannel: {
        payload: Prisma.$MarketingChannelPayload<ExtArgs>
        fields: Prisma.MarketingChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketingChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketingChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelPayload>
          }
          findFirst: {
            args: Prisma.MarketingChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketingChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelPayload>
          }
          findMany: {
            args: Prisma.MarketingChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelPayload>[]
          }
          create: {
            args: Prisma.MarketingChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelPayload>
          }
          createMany: {
            args: Prisma.MarketingChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketingChannelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelPayload>[]
          }
          delete: {
            args: Prisma.MarketingChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelPayload>
          }
          update: {
            args: Prisma.MarketingChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelPayload>
          }
          deleteMany: {
            args: Prisma.MarketingChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketingChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MarketingChannelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelPayload>[]
          }
          upsert: {
            args: Prisma.MarketingChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelPayload>
          }
          aggregate: {
            args: Prisma.MarketingChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketingChannel>
          }
          groupBy: {
            args: Prisma.MarketingChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketingChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketingChannelCountArgs<ExtArgs>
            result: $Utils.Optional<MarketingChannelCountAggregateOutputType> | number
          }
        }
      }
      MarketingOffice: {
        payload: Prisma.$MarketingOfficePayload<ExtArgs>
        fields: Prisma.MarketingOfficeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketingOfficeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingOfficePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketingOfficeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingOfficePayload>
          }
          findFirst: {
            args: Prisma.MarketingOfficeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingOfficePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketingOfficeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingOfficePayload>
          }
          findMany: {
            args: Prisma.MarketingOfficeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingOfficePayload>[]
          }
          create: {
            args: Prisma.MarketingOfficeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingOfficePayload>
          }
          createMany: {
            args: Prisma.MarketingOfficeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketingOfficeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingOfficePayload>[]
          }
          delete: {
            args: Prisma.MarketingOfficeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingOfficePayload>
          }
          update: {
            args: Prisma.MarketingOfficeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingOfficePayload>
          }
          deleteMany: {
            args: Prisma.MarketingOfficeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketingOfficeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MarketingOfficeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingOfficePayload>[]
          }
          upsert: {
            args: Prisma.MarketingOfficeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingOfficePayload>
          }
          aggregate: {
            args: Prisma.MarketingOfficeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketingOffice>
          }
          groupBy: {
            args: Prisma.MarketingOfficeGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketingOfficeGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketingOfficeCountArgs<ExtArgs>
            result: $Utils.Optional<MarketingOfficeCountAggregateOutputType> | number
          }
        }
      }
      MarketingTeam: {
        payload: Prisma.$MarketingTeamPayload<ExtArgs>
        fields: Prisma.MarketingTeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketingTeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketingTeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamPayload>
          }
          findFirst: {
            args: Prisma.MarketingTeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketingTeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamPayload>
          }
          findMany: {
            args: Prisma.MarketingTeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamPayload>[]
          }
          create: {
            args: Prisma.MarketingTeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamPayload>
          }
          createMany: {
            args: Prisma.MarketingTeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketingTeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamPayload>[]
          }
          delete: {
            args: Prisma.MarketingTeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamPayload>
          }
          update: {
            args: Prisma.MarketingTeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamPayload>
          }
          deleteMany: {
            args: Prisma.MarketingTeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketingTeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MarketingTeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamPayload>[]
          }
          upsert: {
            args: Prisma.MarketingTeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamPayload>
          }
          aggregate: {
            args: Prisma.MarketingTeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketingTeam>
          }
          groupBy: {
            args: Prisma.MarketingTeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketingTeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketingTeamCountArgs<ExtArgs>
            result: $Utils.Optional<MarketingTeamCountAggregateOutputType> | number
          }
        }
      }
      MarketingChannelOfficeTeamPair: {
        payload: Prisma.$MarketingChannelOfficeTeamPairPayload<ExtArgs>
        fields: Prisma.MarketingChannelOfficeTeamPairFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketingChannelOfficeTeamPairFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelOfficeTeamPairPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketingChannelOfficeTeamPairFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelOfficeTeamPairPayload>
          }
          findFirst: {
            args: Prisma.MarketingChannelOfficeTeamPairFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelOfficeTeamPairPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketingChannelOfficeTeamPairFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelOfficeTeamPairPayload>
          }
          findMany: {
            args: Prisma.MarketingChannelOfficeTeamPairFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelOfficeTeamPairPayload>[]
          }
          create: {
            args: Prisma.MarketingChannelOfficeTeamPairCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelOfficeTeamPairPayload>
          }
          createMany: {
            args: Prisma.MarketingChannelOfficeTeamPairCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketingChannelOfficeTeamPairCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelOfficeTeamPairPayload>[]
          }
          delete: {
            args: Prisma.MarketingChannelOfficeTeamPairDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelOfficeTeamPairPayload>
          }
          update: {
            args: Prisma.MarketingChannelOfficeTeamPairUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelOfficeTeamPairPayload>
          }
          deleteMany: {
            args: Prisma.MarketingChannelOfficeTeamPairDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketingChannelOfficeTeamPairUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MarketingChannelOfficeTeamPairUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelOfficeTeamPairPayload>[]
          }
          upsert: {
            args: Prisma.MarketingChannelOfficeTeamPairUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingChannelOfficeTeamPairPayload>
          }
          aggregate: {
            args: Prisma.MarketingChannelOfficeTeamPairAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketingChannelOfficeTeamPair>
          }
          groupBy: {
            args: Prisma.MarketingChannelOfficeTeamPairGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketingChannelOfficeTeamPairGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketingChannelOfficeTeamPairCountArgs<ExtArgs>
            result: $Utils.Optional<MarketingChannelOfficeTeamPairCountAggregateOutputType> | number
          }
        }
      }
      ServiceChannel: {
        payload: Prisma.$ServiceChannelPayload<ExtArgs>
        fields: Prisma.ServiceChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelPayload>
          }
          findFirst: {
            args: Prisma.ServiceChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelPayload>
          }
          findMany: {
            args: Prisma.ServiceChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelPayload>[]
          }
          create: {
            args: Prisma.ServiceChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelPayload>
          }
          createMany: {
            args: Prisma.ServiceChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceChannelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelPayload>[]
          }
          delete: {
            args: Prisma.ServiceChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelPayload>
          }
          update: {
            args: Prisma.ServiceChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelPayload>
          }
          deleteMany: {
            args: Prisma.ServiceChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceChannelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelPayload>[]
          }
          upsert: {
            args: Prisma.ServiceChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelPayload>
          }
          aggregate: {
            args: Prisma.ServiceChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceChannel>
          }
          groupBy: {
            args: Prisma.ServiceChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceChannelCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceChannelCountAggregateOutputType> | number
          }
        }
      }
      ServiceOffice: {
        payload: Prisma.$ServiceOfficePayload<ExtArgs>
        fields: Prisma.ServiceOfficeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceOfficeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOfficePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceOfficeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOfficePayload>
          }
          findFirst: {
            args: Prisma.ServiceOfficeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOfficePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceOfficeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOfficePayload>
          }
          findMany: {
            args: Prisma.ServiceOfficeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOfficePayload>[]
          }
          create: {
            args: Prisma.ServiceOfficeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOfficePayload>
          }
          createMany: {
            args: Prisma.ServiceOfficeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceOfficeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOfficePayload>[]
          }
          delete: {
            args: Prisma.ServiceOfficeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOfficePayload>
          }
          update: {
            args: Prisma.ServiceOfficeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOfficePayload>
          }
          deleteMany: {
            args: Prisma.ServiceOfficeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceOfficeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceOfficeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOfficePayload>[]
          }
          upsert: {
            args: Prisma.ServiceOfficeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceOfficePayload>
          }
          aggregate: {
            args: Prisma.ServiceOfficeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceOffice>
          }
          groupBy: {
            args: Prisma.ServiceOfficeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceOfficeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceOfficeCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceOfficeCountAggregateOutputType> | number
          }
        }
      }
      ServiceTeam: {
        payload: Prisma.$ServiceTeamPayload<ExtArgs>
        fields: Prisma.ServiceTeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceTeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceTeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamPayload>
          }
          findFirst: {
            args: Prisma.ServiceTeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceTeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamPayload>
          }
          findMany: {
            args: Prisma.ServiceTeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamPayload>[]
          }
          create: {
            args: Prisma.ServiceTeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamPayload>
          }
          createMany: {
            args: Prisma.ServiceTeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceTeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamPayload>[]
          }
          delete: {
            args: Prisma.ServiceTeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamPayload>
          }
          update: {
            args: Prisma.ServiceTeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamPayload>
          }
          deleteMany: {
            args: Prisma.ServiceTeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceTeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceTeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamPayload>[]
          }
          upsert: {
            args: Prisma.ServiceTeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamPayload>
          }
          aggregate: {
            args: Prisma.ServiceTeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceTeam>
          }
          groupBy: {
            args: Prisma.ServiceTeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceTeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceTeamCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceTeamCountAggregateOutputType> | number
          }
        }
      }
      ServiceChannelOfficeTeamPair: {
        payload: Prisma.$ServiceChannelOfficeTeamPairPayload<ExtArgs>
        fields: Prisma.ServiceChannelOfficeTeamPairFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceChannelOfficeTeamPairFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelOfficeTeamPairPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceChannelOfficeTeamPairFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelOfficeTeamPairPayload>
          }
          findFirst: {
            args: Prisma.ServiceChannelOfficeTeamPairFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelOfficeTeamPairPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceChannelOfficeTeamPairFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelOfficeTeamPairPayload>
          }
          findMany: {
            args: Prisma.ServiceChannelOfficeTeamPairFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelOfficeTeamPairPayload>[]
          }
          create: {
            args: Prisma.ServiceChannelOfficeTeamPairCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelOfficeTeamPairPayload>
          }
          createMany: {
            args: Prisma.ServiceChannelOfficeTeamPairCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceChannelOfficeTeamPairCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelOfficeTeamPairPayload>[]
          }
          delete: {
            args: Prisma.ServiceChannelOfficeTeamPairDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelOfficeTeamPairPayload>
          }
          update: {
            args: Prisma.ServiceChannelOfficeTeamPairUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelOfficeTeamPairPayload>
          }
          deleteMany: {
            args: Prisma.ServiceChannelOfficeTeamPairDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceChannelOfficeTeamPairUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceChannelOfficeTeamPairUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelOfficeTeamPairPayload>[]
          }
          upsert: {
            args: Prisma.ServiceChannelOfficeTeamPairUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceChannelOfficeTeamPairPayload>
          }
          aggregate: {
            args: Prisma.ServiceChannelOfficeTeamPairAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceChannelOfficeTeamPair>
          }
          groupBy: {
            args: Prisma.ServiceChannelOfficeTeamPairGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceChannelOfficeTeamPairGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceChannelOfficeTeamPairCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceChannelOfficeTeamPairCountAggregateOutputType> | number
          }
        }
      }
      BusinessUnitSalesPair: {
        payload: Prisma.$BusinessUnitSalesPairPayload<ExtArgs>
        fields: Prisma.BusinessUnitSalesPairFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessUnitSalesPairFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitSalesPairPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessUnitSalesPairFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitSalesPairPayload>
          }
          findFirst: {
            args: Prisma.BusinessUnitSalesPairFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitSalesPairPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessUnitSalesPairFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitSalesPairPayload>
          }
          findMany: {
            args: Prisma.BusinessUnitSalesPairFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitSalesPairPayload>[]
          }
          create: {
            args: Prisma.BusinessUnitSalesPairCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitSalesPairPayload>
          }
          createMany: {
            args: Prisma.BusinessUnitSalesPairCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessUnitSalesPairCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitSalesPairPayload>[]
          }
          delete: {
            args: Prisma.BusinessUnitSalesPairDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitSalesPairPayload>
          }
          update: {
            args: Prisma.BusinessUnitSalesPairUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitSalesPairPayload>
          }
          deleteMany: {
            args: Prisma.BusinessUnitSalesPairDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessUnitSalesPairUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BusinessUnitSalesPairUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitSalesPairPayload>[]
          }
          upsert: {
            args: Prisma.BusinessUnitSalesPairUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitSalesPairPayload>
          }
          aggregate: {
            args: Prisma.BusinessUnitSalesPairAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessUnitSalesPair>
          }
          groupBy: {
            args: Prisma.BusinessUnitSalesPairGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessUnitSalesPairGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessUnitSalesPairCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessUnitSalesPairCountAggregateOutputType> | number
          }
        }
      }
      BusinessUnitMarketingPair: {
        payload: Prisma.$BusinessUnitMarketingPairPayload<ExtArgs>
        fields: Prisma.BusinessUnitMarketingPairFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessUnitMarketingPairFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitMarketingPairPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessUnitMarketingPairFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitMarketingPairPayload>
          }
          findFirst: {
            args: Prisma.BusinessUnitMarketingPairFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitMarketingPairPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessUnitMarketingPairFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitMarketingPairPayload>
          }
          findMany: {
            args: Prisma.BusinessUnitMarketingPairFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitMarketingPairPayload>[]
          }
          create: {
            args: Prisma.BusinessUnitMarketingPairCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitMarketingPairPayload>
          }
          createMany: {
            args: Prisma.BusinessUnitMarketingPairCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessUnitMarketingPairCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitMarketingPairPayload>[]
          }
          delete: {
            args: Prisma.BusinessUnitMarketingPairDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitMarketingPairPayload>
          }
          update: {
            args: Prisma.BusinessUnitMarketingPairUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitMarketingPairPayload>
          }
          deleteMany: {
            args: Prisma.BusinessUnitMarketingPairDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessUnitMarketingPairUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BusinessUnitMarketingPairUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitMarketingPairPayload>[]
          }
          upsert: {
            args: Prisma.BusinessUnitMarketingPairUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitMarketingPairPayload>
          }
          aggregate: {
            args: Prisma.BusinessUnitMarketingPairAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessUnitMarketingPair>
          }
          groupBy: {
            args: Prisma.BusinessUnitMarketingPairGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessUnitMarketingPairGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessUnitMarketingPairCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessUnitMarketingPairCountAggregateOutputType> | number
          }
        }
      }
      BusinessUnitServicePair: {
        payload: Prisma.$BusinessUnitServicePairPayload<ExtArgs>
        fields: Prisma.BusinessUnitServicePairFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessUnitServicePairFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitServicePairPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessUnitServicePairFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitServicePairPayload>
          }
          findFirst: {
            args: Prisma.BusinessUnitServicePairFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitServicePairPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessUnitServicePairFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitServicePairPayload>
          }
          findMany: {
            args: Prisma.BusinessUnitServicePairFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitServicePairPayload>[]
          }
          create: {
            args: Prisma.BusinessUnitServicePairCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitServicePairPayload>
          }
          createMany: {
            args: Prisma.BusinessUnitServicePairCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessUnitServicePairCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitServicePairPayload>[]
          }
          delete: {
            args: Prisma.BusinessUnitServicePairDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitServicePairPayload>
          }
          update: {
            args: Prisma.BusinessUnitServicePairUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitServicePairPayload>
          }
          deleteMany: {
            args: Prisma.BusinessUnitServicePairDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessUnitServicePairUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BusinessUnitServicePairUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitServicePairPayload>[]
          }
          upsert: {
            args: Prisma.BusinessUnitServicePairUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessUnitServicePairPayload>
          }
          aggregate: {
            args: Prisma.BusinessUnitServicePairAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessUnitServicePair>
          }
          groupBy: {
            args: Prisma.BusinessUnitServicePairGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessUnitServicePairGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessUnitServicePairCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessUnitServicePairCountAggregateOutputType> | number
          }
        }
      }
      SalesTeamManager: {
        payload: Prisma.$SalesTeamManagerPayload<ExtArgs>
        fields: Prisma.SalesTeamManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesTeamManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesTeamManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamManagerPayload>
          }
          findFirst: {
            args: Prisma.SalesTeamManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesTeamManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamManagerPayload>
          }
          findMany: {
            args: Prisma.SalesTeamManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamManagerPayload>[]
          }
          create: {
            args: Prisma.SalesTeamManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamManagerPayload>
          }
          createMany: {
            args: Prisma.SalesTeamManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesTeamManagerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamManagerPayload>[]
          }
          delete: {
            args: Prisma.SalesTeamManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamManagerPayload>
          }
          update: {
            args: Prisma.SalesTeamManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamManagerPayload>
          }
          deleteMany: {
            args: Prisma.SalesTeamManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesTeamManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesTeamManagerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamManagerPayload>[]
          }
          upsert: {
            args: Prisma.SalesTeamManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamManagerPayload>
          }
          aggregate: {
            args: Prisma.SalesTeamManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesTeamManager>
          }
          groupBy: {
            args: Prisma.SalesTeamManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesTeamManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesTeamManagerCountArgs<ExtArgs>
            result: $Utils.Optional<SalesTeamManagerCountAggregateOutputType> | number
          }
        }
      }
      MarketingTeamManager: {
        payload: Prisma.$MarketingTeamManagerPayload<ExtArgs>
        fields: Prisma.MarketingTeamManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketingTeamManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketingTeamManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamManagerPayload>
          }
          findFirst: {
            args: Prisma.MarketingTeamManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketingTeamManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamManagerPayload>
          }
          findMany: {
            args: Prisma.MarketingTeamManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamManagerPayload>[]
          }
          create: {
            args: Prisma.MarketingTeamManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamManagerPayload>
          }
          createMany: {
            args: Prisma.MarketingTeamManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketingTeamManagerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamManagerPayload>[]
          }
          delete: {
            args: Prisma.MarketingTeamManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamManagerPayload>
          }
          update: {
            args: Prisma.MarketingTeamManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamManagerPayload>
          }
          deleteMany: {
            args: Prisma.MarketingTeamManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketingTeamManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MarketingTeamManagerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamManagerPayload>[]
          }
          upsert: {
            args: Prisma.MarketingTeamManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamManagerPayload>
          }
          aggregate: {
            args: Prisma.MarketingTeamManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketingTeamManager>
          }
          groupBy: {
            args: Prisma.MarketingTeamManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketingTeamManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketingTeamManagerCountArgs<ExtArgs>
            result: $Utils.Optional<MarketingTeamManagerCountAggregateOutputType> | number
          }
        }
      }
      ServiceTeamManager: {
        payload: Prisma.$ServiceTeamManagerPayload<ExtArgs>
        fields: Prisma.ServiceTeamManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceTeamManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceTeamManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamManagerPayload>
          }
          findFirst: {
            args: Prisma.ServiceTeamManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceTeamManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamManagerPayload>
          }
          findMany: {
            args: Prisma.ServiceTeamManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamManagerPayload>[]
          }
          create: {
            args: Prisma.ServiceTeamManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamManagerPayload>
          }
          createMany: {
            args: Prisma.ServiceTeamManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceTeamManagerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamManagerPayload>[]
          }
          delete: {
            args: Prisma.ServiceTeamManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamManagerPayload>
          }
          update: {
            args: Prisma.ServiceTeamManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamManagerPayload>
          }
          deleteMany: {
            args: Prisma.ServiceTeamManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceTeamManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceTeamManagerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamManagerPayload>[]
          }
          upsert: {
            args: Prisma.ServiceTeamManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamManagerPayload>
          }
          aggregate: {
            args: Prisma.ServiceTeamManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceTeamManager>
          }
          groupBy: {
            args: Prisma.ServiceTeamManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceTeamManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceTeamManagerCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceTeamManagerCountAggregateOutputType> | number
          }
        }
      }
      SalesTeamEmployee: {
        payload: Prisma.$SalesTeamEmployeePayload<ExtArgs>
        fields: Prisma.SalesTeamEmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesTeamEmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamEmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesTeamEmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamEmployeePayload>
          }
          findFirst: {
            args: Prisma.SalesTeamEmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamEmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesTeamEmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamEmployeePayload>
          }
          findMany: {
            args: Prisma.SalesTeamEmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamEmployeePayload>[]
          }
          create: {
            args: Prisma.SalesTeamEmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamEmployeePayload>
          }
          createMany: {
            args: Prisma.SalesTeamEmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalesTeamEmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamEmployeePayload>[]
          }
          delete: {
            args: Prisma.SalesTeamEmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamEmployeePayload>
          }
          update: {
            args: Prisma.SalesTeamEmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamEmployeePayload>
          }
          deleteMany: {
            args: Prisma.SalesTeamEmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesTeamEmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalesTeamEmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamEmployeePayload>[]
          }
          upsert: {
            args: Prisma.SalesTeamEmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesTeamEmployeePayload>
          }
          aggregate: {
            args: Prisma.SalesTeamEmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesTeamEmployee>
          }
          groupBy: {
            args: Prisma.SalesTeamEmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesTeamEmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesTeamEmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<SalesTeamEmployeeCountAggregateOutputType> | number
          }
        }
      }
      MarketingTeamEmployee: {
        payload: Prisma.$MarketingTeamEmployeePayload<ExtArgs>
        fields: Prisma.MarketingTeamEmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MarketingTeamEmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamEmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MarketingTeamEmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamEmployeePayload>
          }
          findFirst: {
            args: Prisma.MarketingTeamEmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamEmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MarketingTeamEmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamEmployeePayload>
          }
          findMany: {
            args: Prisma.MarketingTeamEmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamEmployeePayload>[]
          }
          create: {
            args: Prisma.MarketingTeamEmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamEmployeePayload>
          }
          createMany: {
            args: Prisma.MarketingTeamEmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MarketingTeamEmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamEmployeePayload>[]
          }
          delete: {
            args: Prisma.MarketingTeamEmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamEmployeePayload>
          }
          update: {
            args: Prisma.MarketingTeamEmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamEmployeePayload>
          }
          deleteMany: {
            args: Prisma.MarketingTeamEmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MarketingTeamEmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MarketingTeamEmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamEmployeePayload>[]
          }
          upsert: {
            args: Prisma.MarketingTeamEmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MarketingTeamEmployeePayload>
          }
          aggregate: {
            args: Prisma.MarketingTeamEmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarketingTeamEmployee>
          }
          groupBy: {
            args: Prisma.MarketingTeamEmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<MarketingTeamEmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.MarketingTeamEmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<MarketingTeamEmployeeCountAggregateOutputType> | number
          }
        }
      }
      ServiceTeamEmployee: {
        payload: Prisma.$ServiceTeamEmployeePayload<ExtArgs>
        fields: Prisma.ServiceTeamEmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceTeamEmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamEmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceTeamEmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamEmployeePayload>
          }
          findFirst: {
            args: Prisma.ServiceTeamEmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamEmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceTeamEmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamEmployeePayload>
          }
          findMany: {
            args: Prisma.ServiceTeamEmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamEmployeePayload>[]
          }
          create: {
            args: Prisma.ServiceTeamEmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamEmployeePayload>
          }
          createMany: {
            args: Prisma.ServiceTeamEmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceTeamEmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamEmployeePayload>[]
          }
          delete: {
            args: Prisma.ServiceTeamEmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamEmployeePayload>
          }
          update: {
            args: Prisma.ServiceTeamEmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamEmployeePayload>
          }
          deleteMany: {
            args: Prisma.ServiceTeamEmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceTeamEmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceTeamEmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamEmployeePayload>[]
          }
          upsert: {
            args: Prisma.ServiceTeamEmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceTeamEmployeePayload>
          }
          aggregate: {
            args: Prisma.ServiceTeamEmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceTeamEmployee>
          }
          groupBy: {
            args: Prisma.ServiceTeamEmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceTeamEmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceTeamEmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceTeamEmployeeCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    businessEntity?: BusinessEntityOmit
    businessUnit?: BusinessUnitOmit
    businessEntityUnitPair?: BusinessEntityUnitPairOmit
    salesChannel?: SalesChannelOmit
    salesOffice?: SalesOfficeOmit
    salesTeam?: SalesTeamOmit
    salesChannelOfficeTeamPair?: SalesChannelOfficeTeamPairOmit
    marketingChannel?: MarketingChannelOmit
    marketingOffice?: MarketingOfficeOmit
    marketingTeam?: MarketingTeamOmit
    marketingChannelOfficeTeamPair?: MarketingChannelOfficeTeamPairOmit
    serviceChannel?: ServiceChannelOmit
    serviceOffice?: ServiceOfficeOmit
    serviceTeam?: ServiceTeamOmit
    serviceChannelOfficeTeamPair?: ServiceChannelOfficeTeamPairOmit
    businessUnitSalesPair?: BusinessUnitSalesPairOmit
    businessUnitMarketingPair?: BusinessUnitMarketingPairOmit
    businessUnitServicePair?: BusinessUnitServicePairOmit
    salesTeamManager?: SalesTeamManagerOmit
    marketingTeamManager?: MarketingTeamManagerOmit
    serviceTeamManager?: ServiceTeamManagerOmit
    salesTeamEmployee?: SalesTeamEmployeeOmit
    marketingTeamEmployee?: MarketingTeamEmployeeOmit
    serviceTeamEmployee?: ServiceTeamEmployeeOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BusinessEntityCountOutputType
   */

  export type BusinessEntityCountOutputType = {
    entityUnitPairs: number
  }

  export type BusinessEntityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityUnitPairs?: boolean | BusinessEntityCountOutputTypeCountEntityUnitPairsArgs
  }

  // Custom InputTypes
  /**
   * BusinessEntityCountOutputType without action
   */
  export type BusinessEntityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntityCountOutputType
     */
    select?: BusinessEntityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusinessEntityCountOutputType without action
   */
  export type BusinessEntityCountOutputTypeCountEntityUnitPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessEntityUnitPairWhereInput
  }


  /**
   * Count Type BusinessUnitCountOutputType
   */

  export type BusinessUnitCountOutputType = {
    entityUnitPairs: number
    businessUnitSalesPairs: number
    businessUnitMarketingPairs: number
    businessUnitServicePairs: number
  }

  export type BusinessUnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityUnitPairs?: boolean | BusinessUnitCountOutputTypeCountEntityUnitPairsArgs
    businessUnitSalesPairs?: boolean | BusinessUnitCountOutputTypeCountBusinessUnitSalesPairsArgs
    businessUnitMarketingPairs?: boolean | BusinessUnitCountOutputTypeCountBusinessUnitMarketingPairsArgs
    businessUnitServicePairs?: boolean | BusinessUnitCountOutputTypeCountBusinessUnitServicePairsArgs
  }

  // Custom InputTypes
  /**
   * BusinessUnitCountOutputType without action
   */
  export type BusinessUnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitCountOutputType
     */
    select?: BusinessUnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BusinessUnitCountOutputType without action
   */
  export type BusinessUnitCountOutputTypeCountEntityUnitPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessEntityUnitPairWhereInput
  }

  /**
   * BusinessUnitCountOutputType without action
   */
  export type BusinessUnitCountOutputTypeCountBusinessUnitSalesPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitSalesPairWhereInput
  }

  /**
   * BusinessUnitCountOutputType without action
   */
  export type BusinessUnitCountOutputTypeCountBusinessUnitMarketingPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitMarketingPairWhereInput
  }

  /**
   * BusinessUnitCountOutputType without action
   */
  export type BusinessUnitCountOutputTypeCountBusinessUnitServicePairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitServicePairWhereInput
  }


  /**
   * Count Type SalesChannelCountOutputType
   */

  export type SalesChannelCountOutputType = {
    channelOfficePairs: number
    businessUnitSalesPairs: number
  }

  export type SalesChannelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channelOfficePairs?: boolean | SalesChannelCountOutputTypeCountChannelOfficePairsArgs
    businessUnitSalesPairs?: boolean | SalesChannelCountOutputTypeCountBusinessUnitSalesPairsArgs
  }

  // Custom InputTypes
  /**
   * SalesChannelCountOutputType without action
   */
  export type SalesChannelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannelCountOutputType
     */
    select?: SalesChannelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalesChannelCountOutputType without action
   */
  export type SalesChannelCountOutputTypeCountChannelOfficePairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesChannelOfficeTeamPairWhereInput
  }

  /**
   * SalesChannelCountOutputType without action
   */
  export type SalesChannelCountOutputTypeCountBusinessUnitSalesPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitSalesPairWhereInput
  }


  /**
   * Count Type SalesOfficeCountOutputType
   */

  export type SalesOfficeCountOutputType = {
    officeTeamPairs: number
    businessUnitSalesPairs: number
  }

  export type SalesOfficeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    officeTeamPairs?: boolean | SalesOfficeCountOutputTypeCountOfficeTeamPairsArgs
    businessUnitSalesPairs?: boolean | SalesOfficeCountOutputTypeCountBusinessUnitSalesPairsArgs
  }

  // Custom InputTypes
  /**
   * SalesOfficeCountOutputType without action
   */
  export type SalesOfficeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOfficeCountOutputType
     */
    select?: SalesOfficeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalesOfficeCountOutputType without action
   */
  export type SalesOfficeCountOutputTypeCountOfficeTeamPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesChannelOfficeTeamPairWhereInput
  }

  /**
   * SalesOfficeCountOutputType without action
   */
  export type SalesOfficeCountOutputTypeCountBusinessUnitSalesPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitSalesPairWhereInput
  }


  /**
   * Count Type SalesTeamCountOutputType
   */

  export type SalesTeamCountOutputType = {
    officeTeamPairs: number
    businessUnitSalesPairs: number
  }

  export type SalesTeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    officeTeamPairs?: boolean | SalesTeamCountOutputTypeCountOfficeTeamPairsArgs
    businessUnitSalesPairs?: boolean | SalesTeamCountOutputTypeCountBusinessUnitSalesPairsArgs
  }

  // Custom InputTypes
  /**
   * SalesTeamCountOutputType without action
   */
  export type SalesTeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamCountOutputType
     */
    select?: SalesTeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalesTeamCountOutputType without action
   */
  export type SalesTeamCountOutputTypeCountOfficeTeamPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesChannelOfficeTeamPairWhereInput
  }

  /**
   * SalesTeamCountOutputType without action
   */
  export type SalesTeamCountOutputTypeCountBusinessUnitSalesPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitSalesPairWhereInput
  }


  /**
   * Count Type MarketingChannelCountOutputType
   */

  export type MarketingChannelCountOutputType = {
    channelOfficePairs: number
    businessUnitMarketingPairs: number
  }

  export type MarketingChannelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channelOfficePairs?: boolean | MarketingChannelCountOutputTypeCountChannelOfficePairsArgs
    businessUnitMarketingPairs?: boolean | MarketingChannelCountOutputTypeCountBusinessUnitMarketingPairsArgs
  }

  // Custom InputTypes
  /**
   * MarketingChannelCountOutputType without action
   */
  export type MarketingChannelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannelCountOutputType
     */
    select?: MarketingChannelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MarketingChannelCountOutputType without action
   */
  export type MarketingChannelCountOutputTypeCountChannelOfficePairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketingChannelOfficeTeamPairWhereInput
  }

  /**
   * MarketingChannelCountOutputType without action
   */
  export type MarketingChannelCountOutputTypeCountBusinessUnitMarketingPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitMarketingPairWhereInput
  }


  /**
   * Count Type MarketingOfficeCountOutputType
   */

  export type MarketingOfficeCountOutputType = {
    officeTeamPairs: number
    businessUnitMarketingPairs: number
  }

  export type MarketingOfficeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    officeTeamPairs?: boolean | MarketingOfficeCountOutputTypeCountOfficeTeamPairsArgs
    businessUnitMarketingPairs?: boolean | MarketingOfficeCountOutputTypeCountBusinessUnitMarketingPairsArgs
  }

  // Custom InputTypes
  /**
   * MarketingOfficeCountOutputType without action
   */
  export type MarketingOfficeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingOfficeCountOutputType
     */
    select?: MarketingOfficeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MarketingOfficeCountOutputType without action
   */
  export type MarketingOfficeCountOutputTypeCountOfficeTeamPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketingChannelOfficeTeamPairWhereInput
  }

  /**
   * MarketingOfficeCountOutputType without action
   */
  export type MarketingOfficeCountOutputTypeCountBusinessUnitMarketingPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitMarketingPairWhereInput
  }


  /**
   * Count Type MarketingTeamCountOutputType
   */

  export type MarketingTeamCountOutputType = {
    officeTeamPairs: number
    businessUnitMarketingPairs: number
  }

  export type MarketingTeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    officeTeamPairs?: boolean | MarketingTeamCountOutputTypeCountOfficeTeamPairsArgs
    businessUnitMarketingPairs?: boolean | MarketingTeamCountOutputTypeCountBusinessUnitMarketingPairsArgs
  }

  // Custom InputTypes
  /**
   * MarketingTeamCountOutputType without action
   */
  export type MarketingTeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamCountOutputType
     */
    select?: MarketingTeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MarketingTeamCountOutputType without action
   */
  export type MarketingTeamCountOutputTypeCountOfficeTeamPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketingChannelOfficeTeamPairWhereInput
  }

  /**
   * MarketingTeamCountOutputType without action
   */
  export type MarketingTeamCountOutputTypeCountBusinessUnitMarketingPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitMarketingPairWhereInput
  }


  /**
   * Count Type ServiceChannelCountOutputType
   */

  export type ServiceChannelCountOutputType = {
    channelOfficePairs: number
    businessUnitServicePairs: number
  }

  export type ServiceChannelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channelOfficePairs?: boolean | ServiceChannelCountOutputTypeCountChannelOfficePairsArgs
    businessUnitServicePairs?: boolean | ServiceChannelCountOutputTypeCountBusinessUnitServicePairsArgs
  }

  // Custom InputTypes
  /**
   * ServiceChannelCountOutputType without action
   */
  export type ServiceChannelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannelCountOutputType
     */
    select?: ServiceChannelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceChannelCountOutputType without action
   */
  export type ServiceChannelCountOutputTypeCountChannelOfficePairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceChannelOfficeTeamPairWhereInput
  }

  /**
   * ServiceChannelCountOutputType without action
   */
  export type ServiceChannelCountOutputTypeCountBusinessUnitServicePairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitServicePairWhereInput
  }


  /**
   * Count Type ServiceOfficeCountOutputType
   */

  export type ServiceOfficeCountOutputType = {
    officeTeamPairs: number
    businessUnitServicePairs: number
  }

  export type ServiceOfficeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    officeTeamPairs?: boolean | ServiceOfficeCountOutputTypeCountOfficeTeamPairsArgs
    businessUnitServicePairs?: boolean | ServiceOfficeCountOutputTypeCountBusinessUnitServicePairsArgs
  }

  // Custom InputTypes
  /**
   * ServiceOfficeCountOutputType without action
   */
  export type ServiceOfficeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOfficeCountOutputType
     */
    select?: ServiceOfficeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceOfficeCountOutputType without action
   */
  export type ServiceOfficeCountOutputTypeCountOfficeTeamPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceChannelOfficeTeamPairWhereInput
  }

  /**
   * ServiceOfficeCountOutputType without action
   */
  export type ServiceOfficeCountOutputTypeCountBusinessUnitServicePairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitServicePairWhereInput
  }


  /**
   * Count Type ServiceTeamCountOutputType
   */

  export type ServiceTeamCountOutputType = {
    officeTeamPairs: number
    businessUnitServicePairs: number
  }

  export type ServiceTeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    officeTeamPairs?: boolean | ServiceTeamCountOutputTypeCountOfficeTeamPairsArgs
    businessUnitServicePairs?: boolean | ServiceTeamCountOutputTypeCountBusinessUnitServicePairsArgs
  }

  // Custom InputTypes
  /**
   * ServiceTeamCountOutputType without action
   */
  export type ServiceTeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamCountOutputType
     */
    select?: ServiceTeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceTeamCountOutputType without action
   */
  export type ServiceTeamCountOutputTypeCountOfficeTeamPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceChannelOfficeTeamPairWhereInput
  }

  /**
   * ServiceTeamCountOutputType without action
   */
  export type ServiceTeamCountOutputTypeCountBusinessUnitServicePairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitServicePairWhereInput
  }


  /**
   * Models
   */

  /**
   * Model BusinessEntity
   */

  export type AggregateBusinessEntity = {
    _count: BusinessEntityCountAggregateOutputType | null
    _avg: BusinessEntityAvgAggregateOutputType | null
    _sum: BusinessEntitySumAggregateOutputType | null
    _min: BusinessEntityMinAggregateOutputType | null
    _max: BusinessEntityMaxAggregateOutputType | null
  }

  export type BusinessEntityAvgAggregateOutputType = {
    id: number | null
  }

  export type BusinessEntitySumAggregateOutputType = {
    id: number | null
  }

  export type BusinessEntityMinAggregateOutputType = {
    id: number | null
    businessEntityCode: string | null
    businessEntityName: string | null
    street1: string | null
    street2: string | null
    city: string | null
    state: string | null
    region: string | null
    country: string | null
    pinCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessEntityMaxAggregateOutputType = {
    id: number | null
    businessEntityCode: string | null
    businessEntityName: string | null
    street1: string | null
    street2: string | null
    city: string | null
    state: string | null
    region: string | null
    country: string | null
    pinCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessEntityCountAggregateOutputType = {
    id: number
    businessEntityCode: number
    businessEntityName: number
    street1: number
    street2: number
    city: number
    state: number
    region: number
    country: number
    pinCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusinessEntityAvgAggregateInputType = {
    id?: true
  }

  export type BusinessEntitySumAggregateInputType = {
    id?: true
  }

  export type BusinessEntityMinAggregateInputType = {
    id?: true
    businessEntityCode?: true
    businessEntityName?: true
    street1?: true
    street2?: true
    city?: true
    state?: true
    region?: true
    country?: true
    pinCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessEntityMaxAggregateInputType = {
    id?: true
    businessEntityCode?: true
    businessEntityName?: true
    street1?: true
    street2?: true
    city?: true
    state?: true
    region?: true
    country?: true
    pinCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessEntityCountAggregateInputType = {
    id?: true
    businessEntityCode?: true
    businessEntityName?: true
    street1?: true
    street2?: true
    city?: true
    state?: true
    region?: true
    country?: true
    pinCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusinessEntityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessEntity to aggregate.
     */
    where?: BusinessEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessEntities to fetch.
     */
    orderBy?: BusinessEntityOrderByWithRelationInput | BusinessEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessEntities
    **/
    _count?: true | BusinessEntityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessEntityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessEntitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessEntityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessEntityMaxAggregateInputType
  }

  export type GetBusinessEntityAggregateType<T extends BusinessEntityAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessEntity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessEntity[P]>
      : GetScalarType<T[P], AggregateBusinessEntity[P]>
  }




  export type BusinessEntityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessEntityWhereInput
    orderBy?: BusinessEntityOrderByWithAggregationInput | BusinessEntityOrderByWithAggregationInput[]
    by: BusinessEntityScalarFieldEnum[] | BusinessEntityScalarFieldEnum
    having?: BusinessEntityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessEntityCountAggregateInputType | true
    _avg?: BusinessEntityAvgAggregateInputType
    _sum?: BusinessEntitySumAggregateInputType
    _min?: BusinessEntityMinAggregateInputType
    _max?: BusinessEntityMaxAggregateInputType
  }

  export type BusinessEntityGroupByOutputType = {
    id: number
    businessEntityCode: string
    businessEntityName: string
    street1: string
    street2: string | null
    city: string
    state: string
    region: string | null
    country: string
    pinCode: string
    createdAt: Date
    updatedAt: Date
    _count: BusinessEntityCountAggregateOutputType | null
    _avg: BusinessEntityAvgAggregateOutputType | null
    _sum: BusinessEntitySumAggregateOutputType | null
    _min: BusinessEntityMinAggregateOutputType | null
    _max: BusinessEntityMaxAggregateOutputType | null
  }

  type GetBusinessEntityGroupByPayload<T extends BusinessEntityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessEntityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessEntityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessEntityGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessEntityGroupByOutputType[P]>
        }
      >
    >


  export type BusinessEntitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessEntityCode?: boolean
    businessEntityName?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    region?: boolean
    country?: boolean
    pinCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entityUnitPairs?: boolean | BusinessEntity$entityUnitPairsArgs<ExtArgs>
    _count?: boolean | BusinessEntityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessEntity"]>

  export type BusinessEntitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessEntityCode?: boolean
    businessEntityName?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    region?: boolean
    country?: boolean
    pinCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["businessEntity"]>

  export type BusinessEntitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessEntityCode?: boolean
    businessEntityName?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    region?: boolean
    country?: boolean
    pinCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["businessEntity"]>

  export type BusinessEntitySelectScalar = {
    id?: boolean
    businessEntityCode?: boolean
    businessEntityName?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    region?: boolean
    country?: boolean
    pinCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusinessEntityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "businessEntityCode" | "businessEntityName" | "street1" | "street2" | "city" | "state" | "region" | "country" | "pinCode" | "createdAt" | "updatedAt", ExtArgs["result"]["businessEntity"]>
  export type BusinessEntityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityUnitPairs?: boolean | BusinessEntity$entityUnitPairsArgs<ExtArgs>
    _count?: boolean | BusinessEntityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BusinessEntityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BusinessEntityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BusinessEntityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessEntity"
    objects: {
      entityUnitPairs: Prisma.$BusinessEntityUnitPairPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      businessEntityCode: string
      businessEntityName: string
      street1: string
      street2: string | null
      city: string
      state: string
      region: string | null
      country: string
      pinCode: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["businessEntity"]>
    composites: {}
  }

  type BusinessEntityGetPayload<S extends boolean | null | undefined | BusinessEntityDefaultArgs> = $Result.GetResult<Prisma.$BusinessEntityPayload, S>

  type BusinessEntityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BusinessEntityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BusinessEntityCountAggregateInputType | true
    }

  export interface BusinessEntityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessEntity'], meta: { name: 'BusinessEntity' } }
    /**
     * Find zero or one BusinessEntity that matches the filter.
     * @param {BusinessEntityFindUniqueArgs} args - Arguments to find a BusinessEntity
     * @example
     * // Get one BusinessEntity
     * const businessEntity = await prisma.businessEntity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessEntityFindUniqueArgs>(args: SelectSubset<T, BusinessEntityFindUniqueArgs<ExtArgs>>): Prisma__BusinessEntityClient<$Result.GetResult<Prisma.$BusinessEntityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BusinessEntity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BusinessEntityFindUniqueOrThrowArgs} args - Arguments to find a BusinessEntity
     * @example
     * // Get one BusinessEntity
     * const businessEntity = await prisma.businessEntity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessEntityFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessEntityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessEntityClient<$Result.GetResult<Prisma.$BusinessEntityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessEntity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessEntityFindFirstArgs} args - Arguments to find a BusinessEntity
     * @example
     * // Get one BusinessEntity
     * const businessEntity = await prisma.businessEntity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessEntityFindFirstArgs>(args?: SelectSubset<T, BusinessEntityFindFirstArgs<ExtArgs>>): Prisma__BusinessEntityClient<$Result.GetResult<Prisma.$BusinessEntityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessEntity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessEntityFindFirstOrThrowArgs} args - Arguments to find a BusinessEntity
     * @example
     * // Get one BusinessEntity
     * const businessEntity = await prisma.businessEntity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessEntityFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessEntityFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessEntityClient<$Result.GetResult<Prisma.$BusinessEntityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BusinessEntities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessEntityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessEntities
     * const businessEntities = await prisma.businessEntity.findMany()
     * 
     * // Get first 10 BusinessEntities
     * const businessEntities = await prisma.businessEntity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessEntityWithIdOnly = await prisma.businessEntity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessEntityFindManyArgs>(args?: SelectSubset<T, BusinessEntityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessEntityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BusinessEntity.
     * @param {BusinessEntityCreateArgs} args - Arguments to create a BusinessEntity.
     * @example
     * // Create one BusinessEntity
     * const BusinessEntity = await prisma.businessEntity.create({
     *   data: {
     *     // ... data to create a BusinessEntity
     *   }
     * })
     * 
     */
    create<T extends BusinessEntityCreateArgs>(args: SelectSubset<T, BusinessEntityCreateArgs<ExtArgs>>): Prisma__BusinessEntityClient<$Result.GetResult<Prisma.$BusinessEntityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BusinessEntities.
     * @param {BusinessEntityCreateManyArgs} args - Arguments to create many BusinessEntities.
     * @example
     * // Create many BusinessEntities
     * const businessEntity = await prisma.businessEntity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessEntityCreateManyArgs>(args?: SelectSubset<T, BusinessEntityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessEntities and returns the data saved in the database.
     * @param {BusinessEntityCreateManyAndReturnArgs} args - Arguments to create many BusinessEntities.
     * @example
     * // Create many BusinessEntities
     * const businessEntity = await prisma.businessEntity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessEntities and only return the `id`
     * const businessEntityWithIdOnly = await prisma.businessEntity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessEntityCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessEntityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessEntityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BusinessEntity.
     * @param {BusinessEntityDeleteArgs} args - Arguments to delete one BusinessEntity.
     * @example
     * // Delete one BusinessEntity
     * const BusinessEntity = await prisma.businessEntity.delete({
     *   where: {
     *     // ... filter to delete one BusinessEntity
     *   }
     * })
     * 
     */
    delete<T extends BusinessEntityDeleteArgs>(args: SelectSubset<T, BusinessEntityDeleteArgs<ExtArgs>>): Prisma__BusinessEntityClient<$Result.GetResult<Prisma.$BusinessEntityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BusinessEntity.
     * @param {BusinessEntityUpdateArgs} args - Arguments to update one BusinessEntity.
     * @example
     * // Update one BusinessEntity
     * const businessEntity = await prisma.businessEntity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessEntityUpdateArgs>(args: SelectSubset<T, BusinessEntityUpdateArgs<ExtArgs>>): Prisma__BusinessEntityClient<$Result.GetResult<Prisma.$BusinessEntityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BusinessEntities.
     * @param {BusinessEntityDeleteManyArgs} args - Arguments to filter BusinessEntities to delete.
     * @example
     * // Delete a few BusinessEntities
     * const { count } = await prisma.businessEntity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessEntityDeleteManyArgs>(args?: SelectSubset<T, BusinessEntityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessEntityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessEntities
     * const businessEntity = await prisma.businessEntity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessEntityUpdateManyArgs>(args: SelectSubset<T, BusinessEntityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessEntities and returns the data updated in the database.
     * @param {BusinessEntityUpdateManyAndReturnArgs} args - Arguments to update many BusinessEntities.
     * @example
     * // Update many BusinessEntities
     * const businessEntity = await prisma.businessEntity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BusinessEntities and only return the `id`
     * const businessEntityWithIdOnly = await prisma.businessEntity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BusinessEntityUpdateManyAndReturnArgs>(args: SelectSubset<T, BusinessEntityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessEntityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BusinessEntity.
     * @param {BusinessEntityUpsertArgs} args - Arguments to update or create a BusinessEntity.
     * @example
     * // Update or create a BusinessEntity
     * const businessEntity = await prisma.businessEntity.upsert({
     *   create: {
     *     // ... data to create a BusinessEntity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessEntity we want to update
     *   }
     * })
     */
    upsert<T extends BusinessEntityUpsertArgs>(args: SelectSubset<T, BusinessEntityUpsertArgs<ExtArgs>>): Prisma__BusinessEntityClient<$Result.GetResult<Prisma.$BusinessEntityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BusinessEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessEntityCountArgs} args - Arguments to filter BusinessEntities to count.
     * @example
     * // Count the number of BusinessEntities
     * const count = await prisma.businessEntity.count({
     *   where: {
     *     // ... the filter for the BusinessEntities we want to count
     *   }
     * })
    **/
    count<T extends BusinessEntityCountArgs>(
      args?: Subset<T, BusinessEntityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessEntityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessEntity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessEntityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessEntityAggregateArgs>(args: Subset<T, BusinessEntityAggregateArgs>): Prisma.PrismaPromise<GetBusinessEntityAggregateType<T>>

    /**
     * Group by BusinessEntity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessEntityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessEntityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessEntityGroupByArgs['orderBy'] }
        : { orderBy?: BusinessEntityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessEntityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessEntityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessEntity model
   */
  readonly fields: BusinessEntityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessEntity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessEntityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entityUnitPairs<T extends BusinessEntity$entityUnitPairsArgs<ExtArgs> = {}>(args?: Subset<T, BusinessEntity$entityUnitPairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessEntityUnitPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessEntity model
   */
  interface BusinessEntityFieldRefs {
    readonly id: FieldRef<"BusinessEntity", 'Int'>
    readonly businessEntityCode: FieldRef<"BusinessEntity", 'String'>
    readonly businessEntityName: FieldRef<"BusinessEntity", 'String'>
    readonly street1: FieldRef<"BusinessEntity", 'String'>
    readonly street2: FieldRef<"BusinessEntity", 'String'>
    readonly city: FieldRef<"BusinessEntity", 'String'>
    readonly state: FieldRef<"BusinessEntity", 'String'>
    readonly region: FieldRef<"BusinessEntity", 'String'>
    readonly country: FieldRef<"BusinessEntity", 'String'>
    readonly pinCode: FieldRef<"BusinessEntity", 'String'>
    readonly createdAt: FieldRef<"BusinessEntity", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessEntity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessEntity findUnique
   */
  export type BusinessEntityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntity
     */
    select?: BusinessEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntity
     */
    omit?: BusinessEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityInclude<ExtArgs> | null
    /**
     * Filter, which BusinessEntity to fetch.
     */
    where: BusinessEntityWhereUniqueInput
  }

  /**
   * BusinessEntity findUniqueOrThrow
   */
  export type BusinessEntityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntity
     */
    select?: BusinessEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntity
     */
    omit?: BusinessEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityInclude<ExtArgs> | null
    /**
     * Filter, which BusinessEntity to fetch.
     */
    where: BusinessEntityWhereUniqueInput
  }

  /**
   * BusinessEntity findFirst
   */
  export type BusinessEntityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntity
     */
    select?: BusinessEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntity
     */
    omit?: BusinessEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityInclude<ExtArgs> | null
    /**
     * Filter, which BusinessEntity to fetch.
     */
    where?: BusinessEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessEntities to fetch.
     */
    orderBy?: BusinessEntityOrderByWithRelationInput | BusinessEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessEntities.
     */
    cursor?: BusinessEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessEntities.
     */
    distinct?: BusinessEntityScalarFieldEnum | BusinessEntityScalarFieldEnum[]
  }

  /**
   * BusinessEntity findFirstOrThrow
   */
  export type BusinessEntityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntity
     */
    select?: BusinessEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntity
     */
    omit?: BusinessEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityInclude<ExtArgs> | null
    /**
     * Filter, which BusinessEntity to fetch.
     */
    where?: BusinessEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessEntities to fetch.
     */
    orderBy?: BusinessEntityOrderByWithRelationInput | BusinessEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessEntities.
     */
    cursor?: BusinessEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessEntities.
     */
    distinct?: BusinessEntityScalarFieldEnum | BusinessEntityScalarFieldEnum[]
  }

  /**
   * BusinessEntity findMany
   */
  export type BusinessEntityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntity
     */
    select?: BusinessEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntity
     */
    omit?: BusinessEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityInclude<ExtArgs> | null
    /**
     * Filter, which BusinessEntities to fetch.
     */
    where?: BusinessEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessEntities to fetch.
     */
    orderBy?: BusinessEntityOrderByWithRelationInput | BusinessEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessEntities.
     */
    cursor?: BusinessEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessEntities.
     */
    skip?: number
    distinct?: BusinessEntityScalarFieldEnum | BusinessEntityScalarFieldEnum[]
  }

  /**
   * BusinessEntity create
   */
  export type BusinessEntityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntity
     */
    select?: BusinessEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntity
     */
    omit?: BusinessEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessEntity.
     */
    data: XOR<BusinessEntityCreateInput, BusinessEntityUncheckedCreateInput>
  }

  /**
   * BusinessEntity createMany
   */
  export type BusinessEntityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessEntities.
     */
    data: BusinessEntityCreateManyInput | BusinessEntityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessEntity createManyAndReturn
   */
  export type BusinessEntityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntity
     */
    select?: BusinessEntitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntity
     */
    omit?: BusinessEntityOmit<ExtArgs> | null
    /**
     * The data used to create many BusinessEntities.
     */
    data: BusinessEntityCreateManyInput | BusinessEntityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessEntity update
   */
  export type BusinessEntityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntity
     */
    select?: BusinessEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntity
     */
    omit?: BusinessEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessEntity.
     */
    data: XOR<BusinessEntityUpdateInput, BusinessEntityUncheckedUpdateInput>
    /**
     * Choose, which BusinessEntity to update.
     */
    where: BusinessEntityWhereUniqueInput
  }

  /**
   * BusinessEntity updateMany
   */
  export type BusinessEntityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessEntities.
     */
    data: XOR<BusinessEntityUpdateManyMutationInput, BusinessEntityUncheckedUpdateManyInput>
    /**
     * Filter which BusinessEntities to update
     */
    where?: BusinessEntityWhereInput
    /**
     * Limit how many BusinessEntities to update.
     */
    limit?: number
  }

  /**
   * BusinessEntity updateManyAndReturn
   */
  export type BusinessEntityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntity
     */
    select?: BusinessEntitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntity
     */
    omit?: BusinessEntityOmit<ExtArgs> | null
    /**
     * The data used to update BusinessEntities.
     */
    data: XOR<BusinessEntityUpdateManyMutationInput, BusinessEntityUncheckedUpdateManyInput>
    /**
     * Filter which BusinessEntities to update
     */
    where?: BusinessEntityWhereInput
    /**
     * Limit how many BusinessEntities to update.
     */
    limit?: number
  }

  /**
   * BusinessEntity upsert
   */
  export type BusinessEntityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntity
     */
    select?: BusinessEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntity
     */
    omit?: BusinessEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessEntity to update in case it exists.
     */
    where: BusinessEntityWhereUniqueInput
    /**
     * In case the BusinessEntity found by the `where` argument doesn't exist, create a new BusinessEntity with this data.
     */
    create: XOR<BusinessEntityCreateInput, BusinessEntityUncheckedCreateInput>
    /**
     * In case the BusinessEntity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessEntityUpdateInput, BusinessEntityUncheckedUpdateInput>
  }

  /**
   * BusinessEntity delete
   */
  export type BusinessEntityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntity
     */
    select?: BusinessEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntity
     */
    omit?: BusinessEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityInclude<ExtArgs> | null
    /**
     * Filter which BusinessEntity to delete.
     */
    where: BusinessEntityWhereUniqueInput
  }

  /**
   * BusinessEntity deleteMany
   */
  export type BusinessEntityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessEntities to delete
     */
    where?: BusinessEntityWhereInput
    /**
     * Limit how many BusinessEntities to delete.
     */
    limit?: number
  }

  /**
   * BusinessEntity.entityUnitPairs
   */
  export type BusinessEntity$entityUnitPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntityUnitPair
     */
    select?: BusinessEntityUnitPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntityUnitPair
     */
    omit?: BusinessEntityUnitPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityUnitPairInclude<ExtArgs> | null
    where?: BusinessEntityUnitPairWhereInput
    orderBy?: BusinessEntityUnitPairOrderByWithRelationInput | BusinessEntityUnitPairOrderByWithRelationInput[]
    cursor?: BusinessEntityUnitPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessEntityUnitPairScalarFieldEnum | BusinessEntityUnitPairScalarFieldEnum[]
  }

  /**
   * BusinessEntity without action
   */
  export type BusinessEntityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntity
     */
    select?: BusinessEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntity
     */
    omit?: BusinessEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityInclude<ExtArgs> | null
  }


  /**
   * Model BusinessUnit
   */

  export type AggregateBusinessUnit = {
    _count: BusinessUnitCountAggregateOutputType | null
    _avg: BusinessUnitAvgAggregateOutputType | null
    _sum: BusinessUnitSumAggregateOutputType | null
    _min: BusinessUnitMinAggregateOutputType | null
    _max: BusinessUnitMaxAggregateOutputType | null
  }

  export type BusinessUnitAvgAggregateOutputType = {
    id: number | null
  }

  export type BusinessUnitSumAggregateOutputType = {
    id: number | null
  }

  export type BusinessUnitMinAggregateOutputType = {
    id: number | null
    businessUnitCode: string | null
    businessUnitDesc: string | null
    street1: string | null
    street2: string | null
    city: string | null
    state: string | null
    region: string | null
    country: string | null
    pinCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessUnitMaxAggregateOutputType = {
    id: number | null
    businessUnitCode: string | null
    businessUnitDesc: string | null
    street1: string | null
    street2: string | null
    city: string | null
    state: string | null
    region: string | null
    country: string | null
    pinCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessUnitCountAggregateOutputType = {
    id: number
    businessUnitCode: number
    businessUnitDesc: number
    street1: number
    street2: number
    city: number
    state: number
    region: number
    country: number
    pinCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusinessUnitAvgAggregateInputType = {
    id?: true
  }

  export type BusinessUnitSumAggregateInputType = {
    id?: true
  }

  export type BusinessUnitMinAggregateInputType = {
    id?: true
    businessUnitCode?: true
    businessUnitDesc?: true
    street1?: true
    street2?: true
    city?: true
    state?: true
    region?: true
    country?: true
    pinCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessUnitMaxAggregateInputType = {
    id?: true
    businessUnitCode?: true
    businessUnitDesc?: true
    street1?: true
    street2?: true
    city?: true
    state?: true
    region?: true
    country?: true
    pinCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessUnitCountAggregateInputType = {
    id?: true
    businessUnitCode?: true
    businessUnitDesc?: true
    street1?: true
    street2?: true
    city?: true
    state?: true
    region?: true
    country?: true
    pinCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusinessUnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessUnit to aggregate.
     */
    where?: BusinessUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnits to fetch.
     */
    orderBy?: BusinessUnitOrderByWithRelationInput | BusinessUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessUnits
    **/
    _count?: true | BusinessUnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessUnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessUnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessUnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessUnitMaxAggregateInputType
  }

  export type GetBusinessUnitAggregateType<T extends BusinessUnitAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessUnit[P]>
      : GetScalarType<T[P], AggregateBusinessUnit[P]>
  }




  export type BusinessUnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitWhereInput
    orderBy?: BusinessUnitOrderByWithAggregationInput | BusinessUnitOrderByWithAggregationInput[]
    by: BusinessUnitScalarFieldEnum[] | BusinessUnitScalarFieldEnum
    having?: BusinessUnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessUnitCountAggregateInputType | true
    _avg?: BusinessUnitAvgAggregateInputType
    _sum?: BusinessUnitSumAggregateInputType
    _min?: BusinessUnitMinAggregateInputType
    _max?: BusinessUnitMaxAggregateInputType
  }

  export type BusinessUnitGroupByOutputType = {
    id: number
    businessUnitCode: string
    businessUnitDesc: string
    street1: string
    street2: string | null
    city: string
    state: string
    region: string | null
    country: string
    pinCode: string
    createdAt: Date
    updatedAt: Date
    _count: BusinessUnitCountAggregateOutputType | null
    _avg: BusinessUnitAvgAggregateOutputType | null
    _sum: BusinessUnitSumAggregateOutputType | null
    _min: BusinessUnitMinAggregateOutputType | null
    _max: BusinessUnitMaxAggregateOutputType | null
  }

  type GetBusinessUnitGroupByPayload<T extends BusinessUnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessUnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessUnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessUnitGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessUnitGroupByOutputType[P]>
        }
      >
    >


  export type BusinessUnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessUnitCode?: boolean
    businessUnitDesc?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    region?: boolean
    country?: boolean
    pinCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entityUnitPairs?: boolean | BusinessUnit$entityUnitPairsArgs<ExtArgs>
    businessUnitSalesPairs?: boolean | BusinessUnit$businessUnitSalesPairsArgs<ExtArgs>
    businessUnitMarketingPairs?: boolean | BusinessUnit$businessUnitMarketingPairsArgs<ExtArgs>
    businessUnitServicePairs?: boolean | BusinessUnit$businessUnitServicePairsArgs<ExtArgs>
    _count?: boolean | BusinessUnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessUnit"]>

  export type BusinessUnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessUnitCode?: boolean
    businessUnitDesc?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    region?: boolean
    country?: boolean
    pinCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["businessUnit"]>

  export type BusinessUnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessUnitCode?: boolean
    businessUnitDesc?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    region?: boolean
    country?: boolean
    pinCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["businessUnit"]>

  export type BusinessUnitSelectScalar = {
    id?: boolean
    businessUnitCode?: boolean
    businessUnitDesc?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    region?: boolean
    country?: boolean
    pinCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusinessUnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "businessUnitCode" | "businessUnitDesc" | "street1" | "street2" | "city" | "state" | "region" | "country" | "pinCode" | "createdAt" | "updatedAt", ExtArgs["result"]["businessUnit"]>
  export type BusinessUnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityUnitPairs?: boolean | BusinessUnit$entityUnitPairsArgs<ExtArgs>
    businessUnitSalesPairs?: boolean | BusinessUnit$businessUnitSalesPairsArgs<ExtArgs>
    businessUnitMarketingPairs?: boolean | BusinessUnit$businessUnitMarketingPairsArgs<ExtArgs>
    businessUnitServicePairs?: boolean | BusinessUnit$businessUnitServicePairsArgs<ExtArgs>
    _count?: boolean | BusinessUnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BusinessUnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BusinessUnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BusinessUnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessUnit"
    objects: {
      entityUnitPairs: Prisma.$BusinessEntityUnitPairPayload<ExtArgs>[]
      businessUnitSalesPairs: Prisma.$BusinessUnitSalesPairPayload<ExtArgs>[]
      businessUnitMarketingPairs: Prisma.$BusinessUnitMarketingPairPayload<ExtArgs>[]
      businessUnitServicePairs: Prisma.$BusinessUnitServicePairPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      businessUnitCode: string
      businessUnitDesc: string
      street1: string
      street2: string | null
      city: string
      state: string
      region: string | null
      country: string
      pinCode: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["businessUnit"]>
    composites: {}
  }

  type BusinessUnitGetPayload<S extends boolean | null | undefined | BusinessUnitDefaultArgs> = $Result.GetResult<Prisma.$BusinessUnitPayload, S>

  type BusinessUnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BusinessUnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BusinessUnitCountAggregateInputType | true
    }

  export interface BusinessUnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessUnit'], meta: { name: 'BusinessUnit' } }
    /**
     * Find zero or one BusinessUnit that matches the filter.
     * @param {BusinessUnitFindUniqueArgs} args - Arguments to find a BusinessUnit
     * @example
     * // Get one BusinessUnit
     * const businessUnit = await prisma.businessUnit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessUnitFindUniqueArgs>(args: SelectSubset<T, BusinessUnitFindUniqueArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BusinessUnit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BusinessUnitFindUniqueOrThrowArgs} args - Arguments to find a BusinessUnit
     * @example
     * // Get one BusinessUnit
     * const businessUnit = await prisma.businessUnit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessUnitFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessUnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessUnit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitFindFirstArgs} args - Arguments to find a BusinessUnit
     * @example
     * // Get one BusinessUnit
     * const businessUnit = await prisma.businessUnit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessUnitFindFirstArgs>(args?: SelectSubset<T, BusinessUnitFindFirstArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessUnit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitFindFirstOrThrowArgs} args - Arguments to find a BusinessUnit
     * @example
     * // Get one BusinessUnit
     * const businessUnit = await prisma.businessUnit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessUnitFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessUnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BusinessUnits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessUnits
     * const businessUnits = await prisma.businessUnit.findMany()
     * 
     * // Get first 10 BusinessUnits
     * const businessUnits = await prisma.businessUnit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessUnitWithIdOnly = await prisma.businessUnit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessUnitFindManyArgs>(args?: SelectSubset<T, BusinessUnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BusinessUnit.
     * @param {BusinessUnitCreateArgs} args - Arguments to create a BusinessUnit.
     * @example
     * // Create one BusinessUnit
     * const BusinessUnit = await prisma.businessUnit.create({
     *   data: {
     *     // ... data to create a BusinessUnit
     *   }
     * })
     * 
     */
    create<T extends BusinessUnitCreateArgs>(args: SelectSubset<T, BusinessUnitCreateArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BusinessUnits.
     * @param {BusinessUnitCreateManyArgs} args - Arguments to create many BusinessUnits.
     * @example
     * // Create many BusinessUnits
     * const businessUnit = await prisma.businessUnit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessUnitCreateManyArgs>(args?: SelectSubset<T, BusinessUnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessUnits and returns the data saved in the database.
     * @param {BusinessUnitCreateManyAndReturnArgs} args - Arguments to create many BusinessUnits.
     * @example
     * // Create many BusinessUnits
     * const businessUnit = await prisma.businessUnit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessUnits and only return the `id`
     * const businessUnitWithIdOnly = await prisma.businessUnit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessUnitCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessUnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BusinessUnit.
     * @param {BusinessUnitDeleteArgs} args - Arguments to delete one BusinessUnit.
     * @example
     * // Delete one BusinessUnit
     * const BusinessUnit = await prisma.businessUnit.delete({
     *   where: {
     *     // ... filter to delete one BusinessUnit
     *   }
     * })
     * 
     */
    delete<T extends BusinessUnitDeleteArgs>(args: SelectSubset<T, BusinessUnitDeleteArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BusinessUnit.
     * @param {BusinessUnitUpdateArgs} args - Arguments to update one BusinessUnit.
     * @example
     * // Update one BusinessUnit
     * const businessUnit = await prisma.businessUnit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessUnitUpdateArgs>(args: SelectSubset<T, BusinessUnitUpdateArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BusinessUnits.
     * @param {BusinessUnitDeleteManyArgs} args - Arguments to filter BusinessUnits to delete.
     * @example
     * // Delete a few BusinessUnits
     * const { count } = await prisma.businessUnit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessUnitDeleteManyArgs>(args?: SelectSubset<T, BusinessUnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessUnits
     * const businessUnit = await prisma.businessUnit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessUnitUpdateManyArgs>(args: SelectSubset<T, BusinessUnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessUnits and returns the data updated in the database.
     * @param {BusinessUnitUpdateManyAndReturnArgs} args - Arguments to update many BusinessUnits.
     * @example
     * // Update many BusinessUnits
     * const businessUnit = await prisma.businessUnit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BusinessUnits and only return the `id`
     * const businessUnitWithIdOnly = await prisma.businessUnit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BusinessUnitUpdateManyAndReturnArgs>(args: SelectSubset<T, BusinessUnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BusinessUnit.
     * @param {BusinessUnitUpsertArgs} args - Arguments to update or create a BusinessUnit.
     * @example
     * // Update or create a BusinessUnit
     * const businessUnit = await prisma.businessUnit.upsert({
     *   create: {
     *     // ... data to create a BusinessUnit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessUnit we want to update
     *   }
     * })
     */
    upsert<T extends BusinessUnitUpsertArgs>(args: SelectSubset<T, BusinessUnitUpsertArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BusinessUnits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitCountArgs} args - Arguments to filter BusinessUnits to count.
     * @example
     * // Count the number of BusinessUnits
     * const count = await prisma.businessUnit.count({
     *   where: {
     *     // ... the filter for the BusinessUnits we want to count
     *   }
     * })
    **/
    count<T extends BusinessUnitCountArgs>(
      args?: Subset<T, BusinessUnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessUnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessUnitAggregateArgs>(args: Subset<T, BusinessUnitAggregateArgs>): Prisma.PrismaPromise<GetBusinessUnitAggregateType<T>>

    /**
     * Group by BusinessUnit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessUnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessUnitGroupByArgs['orderBy'] }
        : { orderBy?: BusinessUnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessUnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessUnit model
   */
  readonly fields: BusinessUnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessUnit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessUnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entityUnitPairs<T extends BusinessUnit$entityUnitPairsArgs<ExtArgs> = {}>(args?: Subset<T, BusinessUnit$entityUnitPairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessEntityUnitPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    businessUnitSalesPairs<T extends BusinessUnit$businessUnitSalesPairsArgs<ExtArgs> = {}>(args?: Subset<T, BusinessUnit$businessUnitSalesPairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitSalesPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    businessUnitMarketingPairs<T extends BusinessUnit$businessUnitMarketingPairsArgs<ExtArgs> = {}>(args?: Subset<T, BusinessUnit$businessUnitMarketingPairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitMarketingPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    businessUnitServicePairs<T extends BusinessUnit$businessUnitServicePairsArgs<ExtArgs> = {}>(args?: Subset<T, BusinessUnit$businessUnitServicePairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitServicePairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessUnit model
   */
  interface BusinessUnitFieldRefs {
    readonly id: FieldRef<"BusinessUnit", 'Int'>
    readonly businessUnitCode: FieldRef<"BusinessUnit", 'String'>
    readonly businessUnitDesc: FieldRef<"BusinessUnit", 'String'>
    readonly street1: FieldRef<"BusinessUnit", 'String'>
    readonly street2: FieldRef<"BusinessUnit", 'String'>
    readonly city: FieldRef<"BusinessUnit", 'String'>
    readonly state: FieldRef<"BusinessUnit", 'String'>
    readonly region: FieldRef<"BusinessUnit", 'String'>
    readonly country: FieldRef<"BusinessUnit", 'String'>
    readonly pinCode: FieldRef<"BusinessUnit", 'String'>
    readonly createdAt: FieldRef<"BusinessUnit", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessUnit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessUnit findUnique
   */
  export type BusinessUnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnit
     */
    omit?: BusinessUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnit to fetch.
     */
    where: BusinessUnitWhereUniqueInput
  }

  /**
   * BusinessUnit findUniqueOrThrow
   */
  export type BusinessUnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnit
     */
    omit?: BusinessUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnit to fetch.
     */
    where: BusinessUnitWhereUniqueInput
  }

  /**
   * BusinessUnit findFirst
   */
  export type BusinessUnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnit
     */
    omit?: BusinessUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnit to fetch.
     */
    where?: BusinessUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnits to fetch.
     */
    orderBy?: BusinessUnitOrderByWithRelationInput | BusinessUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessUnits.
     */
    cursor?: BusinessUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessUnits.
     */
    distinct?: BusinessUnitScalarFieldEnum | BusinessUnitScalarFieldEnum[]
  }

  /**
   * BusinessUnit findFirstOrThrow
   */
  export type BusinessUnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnit
     */
    omit?: BusinessUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnit to fetch.
     */
    where?: BusinessUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnits to fetch.
     */
    orderBy?: BusinessUnitOrderByWithRelationInput | BusinessUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessUnits.
     */
    cursor?: BusinessUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessUnits.
     */
    distinct?: BusinessUnitScalarFieldEnum | BusinessUnitScalarFieldEnum[]
  }

  /**
   * BusinessUnit findMany
   */
  export type BusinessUnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnit
     */
    omit?: BusinessUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnits to fetch.
     */
    where?: BusinessUnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnits to fetch.
     */
    orderBy?: BusinessUnitOrderByWithRelationInput | BusinessUnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessUnits.
     */
    cursor?: BusinessUnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnits.
     */
    skip?: number
    distinct?: BusinessUnitScalarFieldEnum | BusinessUnitScalarFieldEnum[]
  }

  /**
   * BusinessUnit create
   */
  export type BusinessUnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnit
     */
    omit?: BusinessUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessUnit.
     */
    data: XOR<BusinessUnitCreateInput, BusinessUnitUncheckedCreateInput>
  }

  /**
   * BusinessUnit createMany
   */
  export type BusinessUnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessUnits.
     */
    data: BusinessUnitCreateManyInput | BusinessUnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessUnit createManyAndReturn
   */
  export type BusinessUnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnit
     */
    omit?: BusinessUnitOmit<ExtArgs> | null
    /**
     * The data used to create many BusinessUnits.
     */
    data: BusinessUnitCreateManyInput | BusinessUnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessUnit update
   */
  export type BusinessUnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnit
     */
    omit?: BusinessUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessUnit.
     */
    data: XOR<BusinessUnitUpdateInput, BusinessUnitUncheckedUpdateInput>
    /**
     * Choose, which BusinessUnit to update.
     */
    where: BusinessUnitWhereUniqueInput
  }

  /**
   * BusinessUnit updateMany
   */
  export type BusinessUnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessUnits.
     */
    data: XOR<BusinessUnitUpdateManyMutationInput, BusinessUnitUncheckedUpdateManyInput>
    /**
     * Filter which BusinessUnits to update
     */
    where?: BusinessUnitWhereInput
    /**
     * Limit how many BusinessUnits to update.
     */
    limit?: number
  }

  /**
   * BusinessUnit updateManyAndReturn
   */
  export type BusinessUnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnit
     */
    omit?: BusinessUnitOmit<ExtArgs> | null
    /**
     * The data used to update BusinessUnits.
     */
    data: XOR<BusinessUnitUpdateManyMutationInput, BusinessUnitUncheckedUpdateManyInput>
    /**
     * Filter which BusinessUnits to update
     */
    where?: BusinessUnitWhereInput
    /**
     * Limit how many BusinessUnits to update.
     */
    limit?: number
  }

  /**
   * BusinessUnit upsert
   */
  export type BusinessUnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnit
     */
    omit?: BusinessUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessUnit to update in case it exists.
     */
    where: BusinessUnitWhereUniqueInput
    /**
     * In case the BusinessUnit found by the `where` argument doesn't exist, create a new BusinessUnit with this data.
     */
    create: XOR<BusinessUnitCreateInput, BusinessUnitUncheckedCreateInput>
    /**
     * In case the BusinessUnit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessUnitUpdateInput, BusinessUnitUncheckedUpdateInput>
  }

  /**
   * BusinessUnit delete
   */
  export type BusinessUnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnit
     */
    omit?: BusinessUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
    /**
     * Filter which BusinessUnit to delete.
     */
    where: BusinessUnitWhereUniqueInput
  }

  /**
   * BusinessUnit deleteMany
   */
  export type BusinessUnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessUnits to delete
     */
    where?: BusinessUnitWhereInput
    /**
     * Limit how many BusinessUnits to delete.
     */
    limit?: number
  }

  /**
   * BusinessUnit.entityUnitPairs
   */
  export type BusinessUnit$entityUnitPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntityUnitPair
     */
    select?: BusinessEntityUnitPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntityUnitPair
     */
    omit?: BusinessEntityUnitPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityUnitPairInclude<ExtArgs> | null
    where?: BusinessEntityUnitPairWhereInput
    orderBy?: BusinessEntityUnitPairOrderByWithRelationInput | BusinessEntityUnitPairOrderByWithRelationInput[]
    cursor?: BusinessEntityUnitPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessEntityUnitPairScalarFieldEnum | BusinessEntityUnitPairScalarFieldEnum[]
  }

  /**
   * BusinessUnit.businessUnitSalesPairs
   */
  export type BusinessUnit$businessUnitSalesPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSalesPair
     */
    select?: BusinessUnitSalesPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitSalesPair
     */
    omit?: BusinessUnitSalesPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSalesPairInclude<ExtArgs> | null
    where?: BusinessUnitSalesPairWhereInput
    orderBy?: BusinessUnitSalesPairOrderByWithRelationInput | BusinessUnitSalesPairOrderByWithRelationInput[]
    cursor?: BusinessUnitSalesPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessUnitSalesPairScalarFieldEnum | BusinessUnitSalesPairScalarFieldEnum[]
  }

  /**
   * BusinessUnit.businessUnitMarketingPairs
   */
  export type BusinessUnit$businessUnitMarketingPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitMarketingPair
     */
    select?: BusinessUnitMarketingPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitMarketingPair
     */
    omit?: BusinessUnitMarketingPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitMarketingPairInclude<ExtArgs> | null
    where?: BusinessUnitMarketingPairWhereInput
    orderBy?: BusinessUnitMarketingPairOrderByWithRelationInput | BusinessUnitMarketingPairOrderByWithRelationInput[]
    cursor?: BusinessUnitMarketingPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessUnitMarketingPairScalarFieldEnum | BusinessUnitMarketingPairScalarFieldEnum[]
  }

  /**
   * BusinessUnit.businessUnitServicePairs
   */
  export type BusinessUnit$businessUnitServicePairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitServicePair
     */
    select?: BusinessUnitServicePairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitServicePair
     */
    omit?: BusinessUnitServicePairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitServicePairInclude<ExtArgs> | null
    where?: BusinessUnitServicePairWhereInput
    orderBy?: BusinessUnitServicePairOrderByWithRelationInput | BusinessUnitServicePairOrderByWithRelationInput[]
    cursor?: BusinessUnitServicePairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessUnitServicePairScalarFieldEnum | BusinessUnitServicePairScalarFieldEnum[]
  }

  /**
   * BusinessUnit without action
   */
  export type BusinessUnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnit
     */
    select?: BusinessUnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnit
     */
    omit?: BusinessUnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitInclude<ExtArgs> | null
  }


  /**
   * Model BusinessEntityUnitPair
   */

  export type AggregateBusinessEntityUnitPair = {
    _count: BusinessEntityUnitPairCountAggregateOutputType | null
    _avg: BusinessEntityUnitPairAvgAggregateOutputType | null
    _sum: BusinessEntityUnitPairSumAggregateOutputType | null
    _min: BusinessEntityUnitPairMinAggregateOutputType | null
    _max: BusinessEntityUnitPairMaxAggregateOutputType | null
  }

  export type BusinessEntityUnitPairAvgAggregateOutputType = {
    id: number | null
  }

  export type BusinessEntityUnitPairSumAggregateOutputType = {
    id: number | null
  }

  export type BusinessEntityUnitPairMinAggregateOutputType = {
    id: number | null
    businessEntityCode: string | null
    businessUnitCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessEntityUnitPairMaxAggregateOutputType = {
    id: number | null
    businessEntityCode: string | null
    businessUnitCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BusinessEntityUnitPairCountAggregateOutputType = {
    id: number
    businessEntityCode: number
    businessUnitCode: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BusinessEntityUnitPairAvgAggregateInputType = {
    id?: true
  }

  export type BusinessEntityUnitPairSumAggregateInputType = {
    id?: true
  }

  export type BusinessEntityUnitPairMinAggregateInputType = {
    id?: true
    businessEntityCode?: true
    businessUnitCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessEntityUnitPairMaxAggregateInputType = {
    id?: true
    businessEntityCode?: true
    businessUnitCode?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BusinessEntityUnitPairCountAggregateInputType = {
    id?: true
    businessEntityCode?: true
    businessUnitCode?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BusinessEntityUnitPairAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessEntityUnitPair to aggregate.
     */
    where?: BusinessEntityUnitPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessEntityUnitPairs to fetch.
     */
    orderBy?: BusinessEntityUnitPairOrderByWithRelationInput | BusinessEntityUnitPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessEntityUnitPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessEntityUnitPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessEntityUnitPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessEntityUnitPairs
    **/
    _count?: true | BusinessEntityUnitPairCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessEntityUnitPairAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessEntityUnitPairSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessEntityUnitPairMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessEntityUnitPairMaxAggregateInputType
  }

  export type GetBusinessEntityUnitPairAggregateType<T extends BusinessEntityUnitPairAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessEntityUnitPair]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessEntityUnitPair[P]>
      : GetScalarType<T[P], AggregateBusinessEntityUnitPair[P]>
  }




  export type BusinessEntityUnitPairGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessEntityUnitPairWhereInput
    orderBy?: BusinessEntityUnitPairOrderByWithAggregationInput | BusinessEntityUnitPairOrderByWithAggregationInput[]
    by: BusinessEntityUnitPairScalarFieldEnum[] | BusinessEntityUnitPairScalarFieldEnum
    having?: BusinessEntityUnitPairScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessEntityUnitPairCountAggregateInputType | true
    _avg?: BusinessEntityUnitPairAvgAggregateInputType
    _sum?: BusinessEntityUnitPairSumAggregateInputType
    _min?: BusinessEntityUnitPairMinAggregateInputType
    _max?: BusinessEntityUnitPairMaxAggregateInputType
  }

  export type BusinessEntityUnitPairGroupByOutputType = {
    id: number
    businessEntityCode: string
    businessUnitCode: string
    createdAt: Date
    updatedAt: Date
    _count: BusinessEntityUnitPairCountAggregateOutputType | null
    _avg: BusinessEntityUnitPairAvgAggregateOutputType | null
    _sum: BusinessEntityUnitPairSumAggregateOutputType | null
    _min: BusinessEntityUnitPairMinAggregateOutputType | null
    _max: BusinessEntityUnitPairMaxAggregateOutputType | null
  }

  type GetBusinessEntityUnitPairGroupByPayload<T extends BusinessEntityUnitPairGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessEntityUnitPairGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessEntityUnitPairGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessEntityUnitPairGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessEntityUnitPairGroupByOutputType[P]>
        }
      >
    >


  export type BusinessEntityUnitPairSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessEntityCode?: boolean
    businessUnitCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessEntity?: boolean | BusinessEntityDefaultArgs<ExtArgs>
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessEntityUnitPair"]>

  export type BusinessEntityUnitPairSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessEntityCode?: boolean
    businessUnitCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessEntity?: boolean | BusinessEntityDefaultArgs<ExtArgs>
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessEntityUnitPair"]>

  export type BusinessEntityUnitPairSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessEntityCode?: boolean
    businessUnitCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    businessEntity?: boolean | BusinessEntityDefaultArgs<ExtArgs>
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessEntityUnitPair"]>

  export type BusinessEntityUnitPairSelectScalar = {
    id?: boolean
    businessEntityCode?: boolean
    businessUnitCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BusinessEntityUnitPairOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "businessEntityCode" | "businessUnitCode" | "createdAt" | "updatedAt", ExtArgs["result"]["businessEntityUnitPair"]>
  export type BusinessEntityUnitPairInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessEntity?: boolean | BusinessEntityDefaultArgs<ExtArgs>
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
  }
  export type BusinessEntityUnitPairIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessEntity?: boolean | BusinessEntityDefaultArgs<ExtArgs>
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
  }
  export type BusinessEntityUnitPairIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessEntity?: boolean | BusinessEntityDefaultArgs<ExtArgs>
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
  }

  export type $BusinessEntityUnitPairPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessEntityUnitPair"
    objects: {
      businessEntity: Prisma.$BusinessEntityPayload<ExtArgs>
      businessUnit: Prisma.$BusinessUnitPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      businessEntityCode: string
      businessUnitCode: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["businessEntityUnitPair"]>
    composites: {}
  }

  type BusinessEntityUnitPairGetPayload<S extends boolean | null | undefined | BusinessEntityUnitPairDefaultArgs> = $Result.GetResult<Prisma.$BusinessEntityUnitPairPayload, S>

  type BusinessEntityUnitPairCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BusinessEntityUnitPairFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BusinessEntityUnitPairCountAggregateInputType | true
    }

  export interface BusinessEntityUnitPairDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessEntityUnitPair'], meta: { name: 'BusinessEntityUnitPair' } }
    /**
     * Find zero or one BusinessEntityUnitPair that matches the filter.
     * @param {BusinessEntityUnitPairFindUniqueArgs} args - Arguments to find a BusinessEntityUnitPair
     * @example
     * // Get one BusinessEntityUnitPair
     * const businessEntityUnitPair = await prisma.businessEntityUnitPair.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessEntityUnitPairFindUniqueArgs>(args: SelectSubset<T, BusinessEntityUnitPairFindUniqueArgs<ExtArgs>>): Prisma__BusinessEntityUnitPairClient<$Result.GetResult<Prisma.$BusinessEntityUnitPairPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BusinessEntityUnitPair that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BusinessEntityUnitPairFindUniqueOrThrowArgs} args - Arguments to find a BusinessEntityUnitPair
     * @example
     * // Get one BusinessEntityUnitPair
     * const businessEntityUnitPair = await prisma.businessEntityUnitPair.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessEntityUnitPairFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessEntityUnitPairFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessEntityUnitPairClient<$Result.GetResult<Prisma.$BusinessEntityUnitPairPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessEntityUnitPair that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessEntityUnitPairFindFirstArgs} args - Arguments to find a BusinessEntityUnitPair
     * @example
     * // Get one BusinessEntityUnitPair
     * const businessEntityUnitPair = await prisma.businessEntityUnitPair.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessEntityUnitPairFindFirstArgs>(args?: SelectSubset<T, BusinessEntityUnitPairFindFirstArgs<ExtArgs>>): Prisma__BusinessEntityUnitPairClient<$Result.GetResult<Prisma.$BusinessEntityUnitPairPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessEntityUnitPair that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessEntityUnitPairFindFirstOrThrowArgs} args - Arguments to find a BusinessEntityUnitPair
     * @example
     * // Get one BusinessEntityUnitPair
     * const businessEntityUnitPair = await prisma.businessEntityUnitPair.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessEntityUnitPairFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessEntityUnitPairFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessEntityUnitPairClient<$Result.GetResult<Prisma.$BusinessEntityUnitPairPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BusinessEntityUnitPairs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessEntityUnitPairFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessEntityUnitPairs
     * const businessEntityUnitPairs = await prisma.businessEntityUnitPair.findMany()
     * 
     * // Get first 10 BusinessEntityUnitPairs
     * const businessEntityUnitPairs = await prisma.businessEntityUnitPair.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessEntityUnitPairWithIdOnly = await prisma.businessEntityUnitPair.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessEntityUnitPairFindManyArgs>(args?: SelectSubset<T, BusinessEntityUnitPairFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessEntityUnitPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BusinessEntityUnitPair.
     * @param {BusinessEntityUnitPairCreateArgs} args - Arguments to create a BusinessEntityUnitPair.
     * @example
     * // Create one BusinessEntityUnitPair
     * const BusinessEntityUnitPair = await prisma.businessEntityUnitPair.create({
     *   data: {
     *     // ... data to create a BusinessEntityUnitPair
     *   }
     * })
     * 
     */
    create<T extends BusinessEntityUnitPairCreateArgs>(args: SelectSubset<T, BusinessEntityUnitPairCreateArgs<ExtArgs>>): Prisma__BusinessEntityUnitPairClient<$Result.GetResult<Prisma.$BusinessEntityUnitPairPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BusinessEntityUnitPairs.
     * @param {BusinessEntityUnitPairCreateManyArgs} args - Arguments to create many BusinessEntityUnitPairs.
     * @example
     * // Create many BusinessEntityUnitPairs
     * const businessEntityUnitPair = await prisma.businessEntityUnitPair.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessEntityUnitPairCreateManyArgs>(args?: SelectSubset<T, BusinessEntityUnitPairCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessEntityUnitPairs and returns the data saved in the database.
     * @param {BusinessEntityUnitPairCreateManyAndReturnArgs} args - Arguments to create many BusinessEntityUnitPairs.
     * @example
     * // Create many BusinessEntityUnitPairs
     * const businessEntityUnitPair = await prisma.businessEntityUnitPair.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessEntityUnitPairs and only return the `id`
     * const businessEntityUnitPairWithIdOnly = await prisma.businessEntityUnitPair.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessEntityUnitPairCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessEntityUnitPairCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessEntityUnitPairPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BusinessEntityUnitPair.
     * @param {BusinessEntityUnitPairDeleteArgs} args - Arguments to delete one BusinessEntityUnitPair.
     * @example
     * // Delete one BusinessEntityUnitPair
     * const BusinessEntityUnitPair = await prisma.businessEntityUnitPair.delete({
     *   where: {
     *     // ... filter to delete one BusinessEntityUnitPair
     *   }
     * })
     * 
     */
    delete<T extends BusinessEntityUnitPairDeleteArgs>(args: SelectSubset<T, BusinessEntityUnitPairDeleteArgs<ExtArgs>>): Prisma__BusinessEntityUnitPairClient<$Result.GetResult<Prisma.$BusinessEntityUnitPairPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BusinessEntityUnitPair.
     * @param {BusinessEntityUnitPairUpdateArgs} args - Arguments to update one BusinessEntityUnitPair.
     * @example
     * // Update one BusinessEntityUnitPair
     * const businessEntityUnitPair = await prisma.businessEntityUnitPair.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessEntityUnitPairUpdateArgs>(args: SelectSubset<T, BusinessEntityUnitPairUpdateArgs<ExtArgs>>): Prisma__BusinessEntityUnitPairClient<$Result.GetResult<Prisma.$BusinessEntityUnitPairPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BusinessEntityUnitPairs.
     * @param {BusinessEntityUnitPairDeleteManyArgs} args - Arguments to filter BusinessEntityUnitPairs to delete.
     * @example
     * // Delete a few BusinessEntityUnitPairs
     * const { count } = await prisma.businessEntityUnitPair.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessEntityUnitPairDeleteManyArgs>(args?: SelectSubset<T, BusinessEntityUnitPairDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessEntityUnitPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessEntityUnitPairUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessEntityUnitPairs
     * const businessEntityUnitPair = await prisma.businessEntityUnitPair.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessEntityUnitPairUpdateManyArgs>(args: SelectSubset<T, BusinessEntityUnitPairUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessEntityUnitPairs and returns the data updated in the database.
     * @param {BusinessEntityUnitPairUpdateManyAndReturnArgs} args - Arguments to update many BusinessEntityUnitPairs.
     * @example
     * // Update many BusinessEntityUnitPairs
     * const businessEntityUnitPair = await prisma.businessEntityUnitPair.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BusinessEntityUnitPairs and only return the `id`
     * const businessEntityUnitPairWithIdOnly = await prisma.businessEntityUnitPair.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BusinessEntityUnitPairUpdateManyAndReturnArgs>(args: SelectSubset<T, BusinessEntityUnitPairUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessEntityUnitPairPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BusinessEntityUnitPair.
     * @param {BusinessEntityUnitPairUpsertArgs} args - Arguments to update or create a BusinessEntityUnitPair.
     * @example
     * // Update or create a BusinessEntityUnitPair
     * const businessEntityUnitPair = await prisma.businessEntityUnitPair.upsert({
     *   create: {
     *     // ... data to create a BusinessEntityUnitPair
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessEntityUnitPair we want to update
     *   }
     * })
     */
    upsert<T extends BusinessEntityUnitPairUpsertArgs>(args: SelectSubset<T, BusinessEntityUnitPairUpsertArgs<ExtArgs>>): Prisma__BusinessEntityUnitPairClient<$Result.GetResult<Prisma.$BusinessEntityUnitPairPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BusinessEntityUnitPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessEntityUnitPairCountArgs} args - Arguments to filter BusinessEntityUnitPairs to count.
     * @example
     * // Count the number of BusinessEntityUnitPairs
     * const count = await prisma.businessEntityUnitPair.count({
     *   where: {
     *     // ... the filter for the BusinessEntityUnitPairs we want to count
     *   }
     * })
    **/
    count<T extends BusinessEntityUnitPairCountArgs>(
      args?: Subset<T, BusinessEntityUnitPairCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessEntityUnitPairCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessEntityUnitPair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessEntityUnitPairAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessEntityUnitPairAggregateArgs>(args: Subset<T, BusinessEntityUnitPairAggregateArgs>): Prisma.PrismaPromise<GetBusinessEntityUnitPairAggregateType<T>>

    /**
     * Group by BusinessEntityUnitPair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessEntityUnitPairGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessEntityUnitPairGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessEntityUnitPairGroupByArgs['orderBy'] }
        : { orderBy?: BusinessEntityUnitPairGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessEntityUnitPairGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessEntityUnitPairGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessEntityUnitPair model
   */
  readonly fields: BusinessEntityUnitPairFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessEntityUnitPair.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessEntityUnitPairClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessEntity<T extends BusinessEntityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessEntityDefaultArgs<ExtArgs>>): Prisma__BusinessEntityClient<$Result.GetResult<Prisma.$BusinessEntityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    businessUnit<T extends BusinessUnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessUnitDefaultArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessEntityUnitPair model
   */
  interface BusinessEntityUnitPairFieldRefs {
    readonly id: FieldRef<"BusinessEntityUnitPair", 'Int'>
    readonly businessEntityCode: FieldRef<"BusinessEntityUnitPair", 'String'>
    readonly businessUnitCode: FieldRef<"BusinessEntityUnitPair", 'String'>
    readonly createdAt: FieldRef<"BusinessEntityUnitPair", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessEntityUnitPair", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BusinessEntityUnitPair findUnique
   */
  export type BusinessEntityUnitPairFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntityUnitPair
     */
    select?: BusinessEntityUnitPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntityUnitPair
     */
    omit?: BusinessEntityUnitPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityUnitPairInclude<ExtArgs> | null
    /**
     * Filter, which BusinessEntityUnitPair to fetch.
     */
    where: BusinessEntityUnitPairWhereUniqueInput
  }

  /**
   * BusinessEntityUnitPair findUniqueOrThrow
   */
  export type BusinessEntityUnitPairFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntityUnitPair
     */
    select?: BusinessEntityUnitPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntityUnitPair
     */
    omit?: BusinessEntityUnitPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityUnitPairInclude<ExtArgs> | null
    /**
     * Filter, which BusinessEntityUnitPair to fetch.
     */
    where: BusinessEntityUnitPairWhereUniqueInput
  }

  /**
   * BusinessEntityUnitPair findFirst
   */
  export type BusinessEntityUnitPairFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntityUnitPair
     */
    select?: BusinessEntityUnitPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntityUnitPair
     */
    omit?: BusinessEntityUnitPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityUnitPairInclude<ExtArgs> | null
    /**
     * Filter, which BusinessEntityUnitPair to fetch.
     */
    where?: BusinessEntityUnitPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessEntityUnitPairs to fetch.
     */
    orderBy?: BusinessEntityUnitPairOrderByWithRelationInput | BusinessEntityUnitPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessEntityUnitPairs.
     */
    cursor?: BusinessEntityUnitPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessEntityUnitPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessEntityUnitPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessEntityUnitPairs.
     */
    distinct?: BusinessEntityUnitPairScalarFieldEnum | BusinessEntityUnitPairScalarFieldEnum[]
  }

  /**
   * BusinessEntityUnitPair findFirstOrThrow
   */
  export type BusinessEntityUnitPairFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntityUnitPair
     */
    select?: BusinessEntityUnitPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntityUnitPair
     */
    omit?: BusinessEntityUnitPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityUnitPairInclude<ExtArgs> | null
    /**
     * Filter, which BusinessEntityUnitPair to fetch.
     */
    where?: BusinessEntityUnitPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessEntityUnitPairs to fetch.
     */
    orderBy?: BusinessEntityUnitPairOrderByWithRelationInput | BusinessEntityUnitPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessEntityUnitPairs.
     */
    cursor?: BusinessEntityUnitPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessEntityUnitPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessEntityUnitPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessEntityUnitPairs.
     */
    distinct?: BusinessEntityUnitPairScalarFieldEnum | BusinessEntityUnitPairScalarFieldEnum[]
  }

  /**
   * BusinessEntityUnitPair findMany
   */
  export type BusinessEntityUnitPairFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntityUnitPair
     */
    select?: BusinessEntityUnitPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntityUnitPair
     */
    omit?: BusinessEntityUnitPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityUnitPairInclude<ExtArgs> | null
    /**
     * Filter, which BusinessEntityUnitPairs to fetch.
     */
    where?: BusinessEntityUnitPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessEntityUnitPairs to fetch.
     */
    orderBy?: BusinessEntityUnitPairOrderByWithRelationInput | BusinessEntityUnitPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessEntityUnitPairs.
     */
    cursor?: BusinessEntityUnitPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessEntityUnitPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessEntityUnitPairs.
     */
    skip?: number
    distinct?: BusinessEntityUnitPairScalarFieldEnum | BusinessEntityUnitPairScalarFieldEnum[]
  }

  /**
   * BusinessEntityUnitPair create
   */
  export type BusinessEntityUnitPairCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntityUnitPair
     */
    select?: BusinessEntityUnitPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntityUnitPair
     */
    omit?: BusinessEntityUnitPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityUnitPairInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessEntityUnitPair.
     */
    data: XOR<BusinessEntityUnitPairCreateInput, BusinessEntityUnitPairUncheckedCreateInput>
  }

  /**
   * BusinessEntityUnitPair createMany
   */
  export type BusinessEntityUnitPairCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessEntityUnitPairs.
     */
    data: BusinessEntityUnitPairCreateManyInput | BusinessEntityUnitPairCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessEntityUnitPair createManyAndReturn
   */
  export type BusinessEntityUnitPairCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntityUnitPair
     */
    select?: BusinessEntityUnitPairSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntityUnitPair
     */
    omit?: BusinessEntityUnitPairOmit<ExtArgs> | null
    /**
     * The data used to create many BusinessEntityUnitPairs.
     */
    data: BusinessEntityUnitPairCreateManyInput | BusinessEntityUnitPairCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityUnitPairIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessEntityUnitPair update
   */
  export type BusinessEntityUnitPairUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntityUnitPair
     */
    select?: BusinessEntityUnitPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntityUnitPair
     */
    omit?: BusinessEntityUnitPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityUnitPairInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessEntityUnitPair.
     */
    data: XOR<BusinessEntityUnitPairUpdateInput, BusinessEntityUnitPairUncheckedUpdateInput>
    /**
     * Choose, which BusinessEntityUnitPair to update.
     */
    where: BusinessEntityUnitPairWhereUniqueInput
  }

  /**
   * BusinessEntityUnitPair updateMany
   */
  export type BusinessEntityUnitPairUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessEntityUnitPairs.
     */
    data: XOR<BusinessEntityUnitPairUpdateManyMutationInput, BusinessEntityUnitPairUncheckedUpdateManyInput>
    /**
     * Filter which BusinessEntityUnitPairs to update
     */
    where?: BusinessEntityUnitPairWhereInput
    /**
     * Limit how many BusinessEntityUnitPairs to update.
     */
    limit?: number
  }

  /**
   * BusinessEntityUnitPair updateManyAndReturn
   */
  export type BusinessEntityUnitPairUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntityUnitPair
     */
    select?: BusinessEntityUnitPairSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntityUnitPair
     */
    omit?: BusinessEntityUnitPairOmit<ExtArgs> | null
    /**
     * The data used to update BusinessEntityUnitPairs.
     */
    data: XOR<BusinessEntityUnitPairUpdateManyMutationInput, BusinessEntityUnitPairUncheckedUpdateManyInput>
    /**
     * Filter which BusinessEntityUnitPairs to update
     */
    where?: BusinessEntityUnitPairWhereInput
    /**
     * Limit how many BusinessEntityUnitPairs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityUnitPairIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessEntityUnitPair upsert
   */
  export type BusinessEntityUnitPairUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntityUnitPair
     */
    select?: BusinessEntityUnitPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntityUnitPair
     */
    omit?: BusinessEntityUnitPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityUnitPairInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessEntityUnitPair to update in case it exists.
     */
    where: BusinessEntityUnitPairWhereUniqueInput
    /**
     * In case the BusinessEntityUnitPair found by the `where` argument doesn't exist, create a new BusinessEntityUnitPair with this data.
     */
    create: XOR<BusinessEntityUnitPairCreateInput, BusinessEntityUnitPairUncheckedCreateInput>
    /**
     * In case the BusinessEntityUnitPair was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessEntityUnitPairUpdateInput, BusinessEntityUnitPairUncheckedUpdateInput>
  }

  /**
   * BusinessEntityUnitPair delete
   */
  export type BusinessEntityUnitPairDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntityUnitPair
     */
    select?: BusinessEntityUnitPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntityUnitPair
     */
    omit?: BusinessEntityUnitPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityUnitPairInclude<ExtArgs> | null
    /**
     * Filter which BusinessEntityUnitPair to delete.
     */
    where: BusinessEntityUnitPairWhereUniqueInput
  }

  /**
   * BusinessEntityUnitPair deleteMany
   */
  export type BusinessEntityUnitPairDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessEntityUnitPairs to delete
     */
    where?: BusinessEntityUnitPairWhereInput
    /**
     * Limit how many BusinessEntityUnitPairs to delete.
     */
    limit?: number
  }

  /**
   * BusinessEntityUnitPair without action
   */
  export type BusinessEntityUnitPairDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessEntityUnitPair
     */
    select?: BusinessEntityUnitPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessEntityUnitPair
     */
    omit?: BusinessEntityUnitPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessEntityUnitPairInclude<ExtArgs> | null
  }


  /**
   * Model SalesChannel
   */

  export type AggregateSalesChannel = {
    _count: SalesChannelCountAggregateOutputType | null
    _avg: SalesChannelAvgAggregateOutputType | null
    _sum: SalesChannelSumAggregateOutputType | null
    _min: SalesChannelMinAggregateOutputType | null
    _max: SalesChannelMaxAggregateOutputType | null
  }

  export type SalesChannelAvgAggregateOutputType = {
    id: number | null
  }

  export type SalesChannelSumAggregateOutputType = {
    id: number | null
  }

  export type SalesChannelMinAggregateOutputType = {
    id: number | null
    salesChannelCode: string | null
    salesChannelName: string | null
    salesChannelDesc: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesChannelMaxAggregateOutputType = {
    id: number | null
    salesChannelCode: string | null
    salesChannelName: string | null
    salesChannelDesc: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesChannelCountAggregateOutputType = {
    id: number
    salesChannelCode: number
    salesChannelName: number
    salesChannelDesc: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesChannelAvgAggregateInputType = {
    id?: true
  }

  export type SalesChannelSumAggregateInputType = {
    id?: true
  }

  export type SalesChannelMinAggregateInputType = {
    id?: true
    salesChannelCode?: true
    salesChannelName?: true
    salesChannelDesc?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesChannelMaxAggregateInputType = {
    id?: true
    salesChannelCode?: true
    salesChannelName?: true
    salesChannelDesc?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesChannelCountAggregateInputType = {
    id?: true
    salesChannelCode?: true
    salesChannelName?: true
    salesChannelDesc?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesChannel to aggregate.
     */
    where?: SalesChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesChannels to fetch.
     */
    orderBy?: SalesChannelOrderByWithRelationInput | SalesChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesChannels
    **/
    _count?: true | SalesChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesChannelMaxAggregateInputType
  }

  export type GetSalesChannelAggregateType<T extends SalesChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesChannel[P]>
      : GetScalarType<T[P], AggregateSalesChannel[P]>
  }




  export type SalesChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesChannelWhereInput
    orderBy?: SalesChannelOrderByWithAggregationInput | SalesChannelOrderByWithAggregationInput[]
    by: SalesChannelScalarFieldEnum[] | SalesChannelScalarFieldEnum
    having?: SalesChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesChannelCountAggregateInputType | true
    _avg?: SalesChannelAvgAggregateInputType
    _sum?: SalesChannelSumAggregateInputType
    _min?: SalesChannelMinAggregateInputType
    _max?: SalesChannelMaxAggregateInputType
  }

  export type SalesChannelGroupByOutputType = {
    id: number
    salesChannelCode: string
    salesChannelName: string
    salesChannelDesc: string | null
    createdAt: Date
    updatedAt: Date
    _count: SalesChannelCountAggregateOutputType | null
    _avg: SalesChannelAvgAggregateOutputType | null
    _sum: SalesChannelSumAggregateOutputType | null
    _min: SalesChannelMinAggregateOutputType | null
    _max: SalesChannelMaxAggregateOutputType | null
  }

  type GetSalesChannelGroupByPayload<T extends SalesChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesChannelGroupByOutputType[P]>
            : GetScalarType<T[P], SalesChannelGroupByOutputType[P]>
        }
      >
    >


  export type SalesChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesChannelCode?: boolean
    salesChannelName?: boolean
    salesChannelDesc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    channelOfficePairs?: boolean | SalesChannel$channelOfficePairsArgs<ExtArgs>
    businessUnitSalesPairs?: boolean | SalesChannel$businessUnitSalesPairsArgs<ExtArgs>
    _count?: boolean | SalesChannelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesChannel"]>

  export type SalesChannelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesChannelCode?: boolean
    salesChannelName?: boolean
    salesChannelDesc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["salesChannel"]>

  export type SalesChannelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesChannelCode?: boolean
    salesChannelName?: boolean
    salesChannelDesc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["salesChannel"]>

  export type SalesChannelSelectScalar = {
    id?: boolean
    salesChannelCode?: boolean
    salesChannelName?: boolean
    salesChannelDesc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalesChannelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "salesChannelCode" | "salesChannelName" | "salesChannelDesc" | "createdAt" | "updatedAt", ExtArgs["result"]["salesChannel"]>
  export type SalesChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channelOfficePairs?: boolean | SalesChannel$channelOfficePairsArgs<ExtArgs>
    businessUnitSalesPairs?: boolean | SalesChannel$businessUnitSalesPairsArgs<ExtArgs>
    _count?: boolean | SalesChannelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalesChannelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SalesChannelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SalesChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesChannel"
    objects: {
      channelOfficePairs: Prisma.$SalesChannelOfficeTeamPairPayload<ExtArgs>[]
      businessUnitSalesPairs: Prisma.$BusinessUnitSalesPairPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      salesChannelCode: string
      salesChannelName: string
      salesChannelDesc: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salesChannel"]>
    composites: {}
  }

  type SalesChannelGetPayload<S extends boolean | null | undefined | SalesChannelDefaultArgs> = $Result.GetResult<Prisma.$SalesChannelPayload, S>

  type SalesChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesChannelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesChannelCountAggregateInputType | true
    }

  export interface SalesChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesChannel'], meta: { name: 'SalesChannel' } }
    /**
     * Find zero or one SalesChannel that matches the filter.
     * @param {SalesChannelFindUniqueArgs} args - Arguments to find a SalesChannel
     * @example
     * // Get one SalesChannel
     * const salesChannel = await prisma.salesChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesChannelFindUniqueArgs>(args: SelectSubset<T, SalesChannelFindUniqueArgs<ExtArgs>>): Prisma__SalesChannelClient<$Result.GetResult<Prisma.$SalesChannelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesChannel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesChannelFindUniqueOrThrowArgs} args - Arguments to find a SalesChannel
     * @example
     * // Get one SalesChannel
     * const salesChannel = await prisma.salesChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesChannelClient<$Result.GetResult<Prisma.$SalesChannelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesChannelFindFirstArgs} args - Arguments to find a SalesChannel
     * @example
     * // Get one SalesChannel
     * const salesChannel = await prisma.salesChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesChannelFindFirstArgs>(args?: SelectSubset<T, SalesChannelFindFirstArgs<ExtArgs>>): Prisma__SalesChannelClient<$Result.GetResult<Prisma.$SalesChannelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesChannel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesChannelFindFirstOrThrowArgs} args - Arguments to find a SalesChannel
     * @example
     * // Get one SalesChannel
     * const salesChannel = await prisma.salesChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesChannelClient<$Result.GetResult<Prisma.$SalesChannelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesChannels
     * const salesChannels = await prisma.salesChannel.findMany()
     * 
     * // Get first 10 SalesChannels
     * const salesChannels = await prisma.salesChannel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesChannelWithIdOnly = await prisma.salesChannel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesChannelFindManyArgs>(args?: SelectSubset<T, SalesChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesChannelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesChannel.
     * @param {SalesChannelCreateArgs} args - Arguments to create a SalesChannel.
     * @example
     * // Create one SalesChannel
     * const SalesChannel = await prisma.salesChannel.create({
     *   data: {
     *     // ... data to create a SalesChannel
     *   }
     * })
     * 
     */
    create<T extends SalesChannelCreateArgs>(args: SelectSubset<T, SalesChannelCreateArgs<ExtArgs>>): Prisma__SalesChannelClient<$Result.GetResult<Prisma.$SalesChannelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesChannels.
     * @param {SalesChannelCreateManyArgs} args - Arguments to create many SalesChannels.
     * @example
     * // Create many SalesChannels
     * const salesChannel = await prisma.salesChannel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesChannelCreateManyArgs>(args?: SelectSubset<T, SalesChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesChannels and returns the data saved in the database.
     * @param {SalesChannelCreateManyAndReturnArgs} args - Arguments to create many SalesChannels.
     * @example
     * // Create many SalesChannels
     * const salesChannel = await prisma.salesChannel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesChannels and only return the `id`
     * const salesChannelWithIdOnly = await prisma.salesChannel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesChannelCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesChannelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesChannelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesChannel.
     * @param {SalesChannelDeleteArgs} args - Arguments to delete one SalesChannel.
     * @example
     * // Delete one SalesChannel
     * const SalesChannel = await prisma.salesChannel.delete({
     *   where: {
     *     // ... filter to delete one SalesChannel
     *   }
     * })
     * 
     */
    delete<T extends SalesChannelDeleteArgs>(args: SelectSubset<T, SalesChannelDeleteArgs<ExtArgs>>): Prisma__SalesChannelClient<$Result.GetResult<Prisma.$SalesChannelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesChannel.
     * @param {SalesChannelUpdateArgs} args - Arguments to update one SalesChannel.
     * @example
     * // Update one SalesChannel
     * const salesChannel = await prisma.salesChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesChannelUpdateArgs>(args: SelectSubset<T, SalesChannelUpdateArgs<ExtArgs>>): Prisma__SalesChannelClient<$Result.GetResult<Prisma.$SalesChannelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesChannels.
     * @param {SalesChannelDeleteManyArgs} args - Arguments to filter SalesChannels to delete.
     * @example
     * // Delete a few SalesChannels
     * const { count } = await prisma.salesChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesChannelDeleteManyArgs>(args?: SelectSubset<T, SalesChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesChannels
     * const salesChannel = await prisma.salesChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesChannelUpdateManyArgs>(args: SelectSubset<T, SalesChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesChannels and returns the data updated in the database.
     * @param {SalesChannelUpdateManyAndReturnArgs} args - Arguments to update many SalesChannels.
     * @example
     * // Update many SalesChannels
     * const salesChannel = await prisma.salesChannel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesChannels and only return the `id`
     * const salesChannelWithIdOnly = await prisma.salesChannel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesChannelUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesChannelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesChannelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesChannel.
     * @param {SalesChannelUpsertArgs} args - Arguments to update or create a SalesChannel.
     * @example
     * // Update or create a SalesChannel
     * const salesChannel = await prisma.salesChannel.upsert({
     *   create: {
     *     // ... data to create a SalesChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesChannel we want to update
     *   }
     * })
     */
    upsert<T extends SalesChannelUpsertArgs>(args: SelectSubset<T, SalesChannelUpsertArgs<ExtArgs>>): Prisma__SalesChannelClient<$Result.GetResult<Prisma.$SalesChannelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesChannelCountArgs} args - Arguments to filter SalesChannels to count.
     * @example
     * // Count the number of SalesChannels
     * const count = await prisma.salesChannel.count({
     *   where: {
     *     // ... the filter for the SalesChannels we want to count
     *   }
     * })
    **/
    count<T extends SalesChannelCountArgs>(
      args?: Subset<T, SalesChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesChannelAggregateArgs>(args: Subset<T, SalesChannelAggregateArgs>): Prisma.PrismaPromise<GetSalesChannelAggregateType<T>>

    /**
     * Group by SalesChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesChannelGroupByArgs['orderBy'] }
        : { orderBy?: SalesChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesChannel model
   */
  readonly fields: SalesChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channelOfficePairs<T extends SalesChannel$channelOfficePairsArgs<ExtArgs> = {}>(args?: Subset<T, SalesChannel$channelOfficePairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesChannelOfficeTeamPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    businessUnitSalesPairs<T extends SalesChannel$businessUnitSalesPairsArgs<ExtArgs> = {}>(args?: Subset<T, SalesChannel$businessUnitSalesPairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitSalesPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesChannel model
   */
  interface SalesChannelFieldRefs {
    readonly id: FieldRef<"SalesChannel", 'Int'>
    readonly salesChannelCode: FieldRef<"SalesChannel", 'String'>
    readonly salesChannelName: FieldRef<"SalesChannel", 'String'>
    readonly salesChannelDesc: FieldRef<"SalesChannel", 'String'>
    readonly createdAt: FieldRef<"SalesChannel", 'DateTime'>
    readonly updatedAt: FieldRef<"SalesChannel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesChannel findUnique
   */
  export type SalesChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannel
     */
    select?: SalesChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannel
     */
    omit?: SalesChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelInclude<ExtArgs> | null
    /**
     * Filter, which SalesChannel to fetch.
     */
    where: SalesChannelWhereUniqueInput
  }

  /**
   * SalesChannel findUniqueOrThrow
   */
  export type SalesChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannel
     */
    select?: SalesChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannel
     */
    omit?: SalesChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelInclude<ExtArgs> | null
    /**
     * Filter, which SalesChannel to fetch.
     */
    where: SalesChannelWhereUniqueInput
  }

  /**
   * SalesChannel findFirst
   */
  export type SalesChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannel
     */
    select?: SalesChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannel
     */
    omit?: SalesChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelInclude<ExtArgs> | null
    /**
     * Filter, which SalesChannel to fetch.
     */
    where?: SalesChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesChannels to fetch.
     */
    orderBy?: SalesChannelOrderByWithRelationInput | SalesChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesChannels.
     */
    cursor?: SalesChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesChannels.
     */
    distinct?: SalesChannelScalarFieldEnum | SalesChannelScalarFieldEnum[]
  }

  /**
   * SalesChannel findFirstOrThrow
   */
  export type SalesChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannel
     */
    select?: SalesChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannel
     */
    omit?: SalesChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelInclude<ExtArgs> | null
    /**
     * Filter, which SalesChannel to fetch.
     */
    where?: SalesChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesChannels to fetch.
     */
    orderBy?: SalesChannelOrderByWithRelationInput | SalesChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesChannels.
     */
    cursor?: SalesChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesChannels.
     */
    distinct?: SalesChannelScalarFieldEnum | SalesChannelScalarFieldEnum[]
  }

  /**
   * SalesChannel findMany
   */
  export type SalesChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannel
     */
    select?: SalesChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannel
     */
    omit?: SalesChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelInclude<ExtArgs> | null
    /**
     * Filter, which SalesChannels to fetch.
     */
    where?: SalesChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesChannels to fetch.
     */
    orderBy?: SalesChannelOrderByWithRelationInput | SalesChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesChannels.
     */
    cursor?: SalesChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesChannels.
     */
    skip?: number
    distinct?: SalesChannelScalarFieldEnum | SalesChannelScalarFieldEnum[]
  }

  /**
   * SalesChannel create
   */
  export type SalesChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannel
     */
    select?: SalesChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannel
     */
    omit?: SalesChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesChannel.
     */
    data: XOR<SalesChannelCreateInput, SalesChannelUncheckedCreateInput>
  }

  /**
   * SalesChannel createMany
   */
  export type SalesChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesChannels.
     */
    data: SalesChannelCreateManyInput | SalesChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesChannel createManyAndReturn
   */
  export type SalesChannelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannel
     */
    select?: SalesChannelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannel
     */
    omit?: SalesChannelOmit<ExtArgs> | null
    /**
     * The data used to create many SalesChannels.
     */
    data: SalesChannelCreateManyInput | SalesChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesChannel update
   */
  export type SalesChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannel
     */
    select?: SalesChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannel
     */
    omit?: SalesChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesChannel.
     */
    data: XOR<SalesChannelUpdateInput, SalesChannelUncheckedUpdateInput>
    /**
     * Choose, which SalesChannel to update.
     */
    where: SalesChannelWhereUniqueInput
  }

  /**
   * SalesChannel updateMany
   */
  export type SalesChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesChannels.
     */
    data: XOR<SalesChannelUpdateManyMutationInput, SalesChannelUncheckedUpdateManyInput>
    /**
     * Filter which SalesChannels to update
     */
    where?: SalesChannelWhereInput
    /**
     * Limit how many SalesChannels to update.
     */
    limit?: number
  }

  /**
   * SalesChannel updateManyAndReturn
   */
  export type SalesChannelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannel
     */
    select?: SalesChannelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannel
     */
    omit?: SalesChannelOmit<ExtArgs> | null
    /**
     * The data used to update SalesChannels.
     */
    data: XOR<SalesChannelUpdateManyMutationInput, SalesChannelUncheckedUpdateManyInput>
    /**
     * Filter which SalesChannels to update
     */
    where?: SalesChannelWhereInput
    /**
     * Limit how many SalesChannels to update.
     */
    limit?: number
  }

  /**
   * SalesChannel upsert
   */
  export type SalesChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannel
     */
    select?: SalesChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannel
     */
    omit?: SalesChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesChannel to update in case it exists.
     */
    where: SalesChannelWhereUniqueInput
    /**
     * In case the SalesChannel found by the `where` argument doesn't exist, create a new SalesChannel with this data.
     */
    create: XOR<SalesChannelCreateInput, SalesChannelUncheckedCreateInput>
    /**
     * In case the SalesChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesChannelUpdateInput, SalesChannelUncheckedUpdateInput>
  }

  /**
   * SalesChannel delete
   */
  export type SalesChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannel
     */
    select?: SalesChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannel
     */
    omit?: SalesChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelInclude<ExtArgs> | null
    /**
     * Filter which SalesChannel to delete.
     */
    where: SalesChannelWhereUniqueInput
  }

  /**
   * SalesChannel deleteMany
   */
  export type SalesChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesChannels to delete
     */
    where?: SalesChannelWhereInput
    /**
     * Limit how many SalesChannels to delete.
     */
    limit?: number
  }

  /**
   * SalesChannel.channelOfficePairs
   */
  export type SalesChannel$channelOfficePairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannelOfficeTeamPair
     */
    select?: SalesChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannelOfficeTeamPair
     */
    omit?: SalesChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelOfficeTeamPairInclude<ExtArgs> | null
    where?: SalesChannelOfficeTeamPairWhereInput
    orderBy?: SalesChannelOfficeTeamPairOrderByWithRelationInput | SalesChannelOfficeTeamPairOrderByWithRelationInput[]
    cursor?: SalesChannelOfficeTeamPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesChannelOfficeTeamPairScalarFieldEnum | SalesChannelOfficeTeamPairScalarFieldEnum[]
  }

  /**
   * SalesChannel.businessUnitSalesPairs
   */
  export type SalesChannel$businessUnitSalesPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSalesPair
     */
    select?: BusinessUnitSalesPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitSalesPair
     */
    omit?: BusinessUnitSalesPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSalesPairInclude<ExtArgs> | null
    where?: BusinessUnitSalesPairWhereInput
    orderBy?: BusinessUnitSalesPairOrderByWithRelationInput | BusinessUnitSalesPairOrderByWithRelationInput[]
    cursor?: BusinessUnitSalesPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessUnitSalesPairScalarFieldEnum | BusinessUnitSalesPairScalarFieldEnum[]
  }

  /**
   * SalesChannel without action
   */
  export type SalesChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannel
     */
    select?: SalesChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannel
     */
    omit?: SalesChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelInclude<ExtArgs> | null
  }


  /**
   * Model SalesOffice
   */

  export type AggregateSalesOffice = {
    _count: SalesOfficeCountAggregateOutputType | null
    _avg: SalesOfficeAvgAggregateOutputType | null
    _sum: SalesOfficeSumAggregateOutputType | null
    _min: SalesOfficeMinAggregateOutputType | null
    _max: SalesOfficeMaxAggregateOutputType | null
  }

  export type SalesOfficeAvgAggregateOutputType = {
    id: number | null
  }

  export type SalesOfficeSumAggregateOutputType = {
    id: number | null
  }

  export type SalesOfficeMinAggregateOutputType = {
    id: number | null
    salesOfficeId: string | null
    organizationName: string | null
    salesOfficeDesc: string | null
    street1: string | null
    street2: string | null
    city: string | null
    state: string | null
    region: string | null
    country: string | null
    pinCode: string | null
    validFrom: Date | null
    validTo: Date | null
    company: string | null
    parentUnit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesOfficeMaxAggregateOutputType = {
    id: number | null
    salesOfficeId: string | null
    organizationName: string | null
    salesOfficeDesc: string | null
    street1: string | null
    street2: string | null
    city: string | null
    state: string | null
    region: string | null
    country: string | null
    pinCode: string | null
    validFrom: Date | null
    validTo: Date | null
    company: string | null
    parentUnit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesOfficeCountAggregateOutputType = {
    id: number
    salesOfficeId: number
    organizationName: number
    salesOfficeDesc: number
    street1: number
    street2: number
    city: number
    state: number
    region: number
    country: number
    pinCode: number
    validFrom: number
    validTo: number
    company: number
    parentUnit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesOfficeAvgAggregateInputType = {
    id?: true
  }

  export type SalesOfficeSumAggregateInputType = {
    id?: true
  }

  export type SalesOfficeMinAggregateInputType = {
    id?: true
    salesOfficeId?: true
    organizationName?: true
    salesOfficeDesc?: true
    street1?: true
    street2?: true
    city?: true
    state?: true
    region?: true
    country?: true
    pinCode?: true
    validFrom?: true
    validTo?: true
    company?: true
    parentUnit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesOfficeMaxAggregateInputType = {
    id?: true
    salesOfficeId?: true
    organizationName?: true
    salesOfficeDesc?: true
    street1?: true
    street2?: true
    city?: true
    state?: true
    region?: true
    country?: true
    pinCode?: true
    validFrom?: true
    validTo?: true
    company?: true
    parentUnit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesOfficeCountAggregateInputType = {
    id?: true
    salesOfficeId?: true
    organizationName?: true
    salesOfficeDesc?: true
    street1?: true
    street2?: true
    city?: true
    state?: true
    region?: true
    country?: true
    pinCode?: true
    validFrom?: true
    validTo?: true
    company?: true
    parentUnit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesOfficeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesOffice to aggregate.
     */
    where?: SalesOfficeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOffices to fetch.
     */
    orderBy?: SalesOfficeOrderByWithRelationInput | SalesOfficeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesOfficeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOffices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOffices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesOffices
    **/
    _count?: true | SalesOfficeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesOfficeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesOfficeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesOfficeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesOfficeMaxAggregateInputType
  }

  export type GetSalesOfficeAggregateType<T extends SalesOfficeAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesOffice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesOffice[P]>
      : GetScalarType<T[P], AggregateSalesOffice[P]>
  }




  export type SalesOfficeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesOfficeWhereInput
    orderBy?: SalesOfficeOrderByWithAggregationInput | SalesOfficeOrderByWithAggregationInput[]
    by: SalesOfficeScalarFieldEnum[] | SalesOfficeScalarFieldEnum
    having?: SalesOfficeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesOfficeCountAggregateInputType | true
    _avg?: SalesOfficeAvgAggregateInputType
    _sum?: SalesOfficeSumAggregateInputType
    _min?: SalesOfficeMinAggregateInputType
    _max?: SalesOfficeMaxAggregateInputType
  }

  export type SalesOfficeGroupByOutputType = {
    id: number
    salesOfficeId: string
    organizationName: string
    salesOfficeDesc: string | null
    street1: string
    street2: string | null
    city: string
    state: string
    region: string | null
    country: string
    pinCode: string
    validFrom: Date
    validTo: Date
    company: string
    parentUnit: string | null
    createdAt: Date
    updatedAt: Date
    _count: SalesOfficeCountAggregateOutputType | null
    _avg: SalesOfficeAvgAggregateOutputType | null
    _sum: SalesOfficeSumAggregateOutputType | null
    _min: SalesOfficeMinAggregateOutputType | null
    _max: SalesOfficeMaxAggregateOutputType | null
  }

  type GetSalesOfficeGroupByPayload<T extends SalesOfficeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesOfficeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesOfficeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesOfficeGroupByOutputType[P]>
            : GetScalarType<T[P], SalesOfficeGroupByOutputType[P]>
        }
      >
    >


  export type SalesOfficeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesOfficeId?: boolean
    organizationName?: boolean
    salesOfficeDesc?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    region?: boolean
    country?: boolean
    pinCode?: boolean
    validFrom?: boolean
    validTo?: boolean
    company?: boolean
    parentUnit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeTeamPairs?: boolean | SalesOffice$officeTeamPairsArgs<ExtArgs>
    businessUnitSalesPairs?: boolean | SalesOffice$businessUnitSalesPairsArgs<ExtArgs>
    _count?: boolean | SalesOfficeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesOffice"]>

  export type SalesOfficeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesOfficeId?: boolean
    organizationName?: boolean
    salesOfficeDesc?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    region?: boolean
    country?: boolean
    pinCode?: boolean
    validFrom?: boolean
    validTo?: boolean
    company?: boolean
    parentUnit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["salesOffice"]>

  export type SalesOfficeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesOfficeId?: boolean
    organizationName?: boolean
    salesOfficeDesc?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    region?: boolean
    country?: boolean
    pinCode?: boolean
    validFrom?: boolean
    validTo?: boolean
    company?: boolean
    parentUnit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["salesOffice"]>

  export type SalesOfficeSelectScalar = {
    id?: boolean
    salesOfficeId?: boolean
    organizationName?: boolean
    salesOfficeDesc?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    region?: boolean
    country?: boolean
    pinCode?: boolean
    validFrom?: boolean
    validTo?: boolean
    company?: boolean
    parentUnit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalesOfficeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "salesOfficeId" | "organizationName" | "salesOfficeDesc" | "street1" | "street2" | "city" | "state" | "region" | "country" | "pinCode" | "validFrom" | "validTo" | "company" | "parentUnit" | "createdAt" | "updatedAt", ExtArgs["result"]["salesOffice"]>
  export type SalesOfficeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    officeTeamPairs?: boolean | SalesOffice$officeTeamPairsArgs<ExtArgs>
    businessUnitSalesPairs?: boolean | SalesOffice$businessUnitSalesPairsArgs<ExtArgs>
    _count?: boolean | SalesOfficeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalesOfficeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SalesOfficeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SalesOfficePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesOffice"
    objects: {
      officeTeamPairs: Prisma.$SalesChannelOfficeTeamPairPayload<ExtArgs>[]
      businessUnitSalesPairs: Prisma.$BusinessUnitSalesPairPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      salesOfficeId: string
      organizationName: string
      salesOfficeDesc: string | null
      street1: string
      street2: string | null
      city: string
      state: string
      region: string | null
      country: string
      pinCode: string
      validFrom: Date
      validTo: Date
      company: string
      parentUnit: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salesOffice"]>
    composites: {}
  }

  type SalesOfficeGetPayload<S extends boolean | null | undefined | SalesOfficeDefaultArgs> = $Result.GetResult<Prisma.$SalesOfficePayload, S>

  type SalesOfficeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesOfficeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesOfficeCountAggregateInputType | true
    }

  export interface SalesOfficeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesOffice'], meta: { name: 'SalesOffice' } }
    /**
     * Find zero or one SalesOffice that matches the filter.
     * @param {SalesOfficeFindUniqueArgs} args - Arguments to find a SalesOffice
     * @example
     * // Get one SalesOffice
     * const salesOffice = await prisma.salesOffice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesOfficeFindUniqueArgs>(args: SelectSubset<T, SalesOfficeFindUniqueArgs<ExtArgs>>): Prisma__SalesOfficeClient<$Result.GetResult<Prisma.$SalesOfficePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesOffice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesOfficeFindUniqueOrThrowArgs} args - Arguments to find a SalesOffice
     * @example
     * // Get one SalesOffice
     * const salesOffice = await prisma.salesOffice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesOfficeFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesOfficeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesOfficeClient<$Result.GetResult<Prisma.$SalesOfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesOffice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOfficeFindFirstArgs} args - Arguments to find a SalesOffice
     * @example
     * // Get one SalesOffice
     * const salesOffice = await prisma.salesOffice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesOfficeFindFirstArgs>(args?: SelectSubset<T, SalesOfficeFindFirstArgs<ExtArgs>>): Prisma__SalesOfficeClient<$Result.GetResult<Prisma.$SalesOfficePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesOffice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOfficeFindFirstOrThrowArgs} args - Arguments to find a SalesOffice
     * @example
     * // Get one SalesOffice
     * const salesOffice = await prisma.salesOffice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesOfficeFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesOfficeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesOfficeClient<$Result.GetResult<Prisma.$SalesOfficePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesOffices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOfficeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesOffices
     * const salesOffices = await prisma.salesOffice.findMany()
     * 
     * // Get first 10 SalesOffices
     * const salesOffices = await prisma.salesOffice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesOfficeWithIdOnly = await prisma.salesOffice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesOfficeFindManyArgs>(args?: SelectSubset<T, SalesOfficeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOfficePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesOffice.
     * @param {SalesOfficeCreateArgs} args - Arguments to create a SalesOffice.
     * @example
     * // Create one SalesOffice
     * const SalesOffice = await prisma.salesOffice.create({
     *   data: {
     *     // ... data to create a SalesOffice
     *   }
     * })
     * 
     */
    create<T extends SalesOfficeCreateArgs>(args: SelectSubset<T, SalesOfficeCreateArgs<ExtArgs>>): Prisma__SalesOfficeClient<$Result.GetResult<Prisma.$SalesOfficePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesOffices.
     * @param {SalesOfficeCreateManyArgs} args - Arguments to create many SalesOffices.
     * @example
     * // Create many SalesOffices
     * const salesOffice = await prisma.salesOffice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesOfficeCreateManyArgs>(args?: SelectSubset<T, SalesOfficeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesOffices and returns the data saved in the database.
     * @param {SalesOfficeCreateManyAndReturnArgs} args - Arguments to create many SalesOffices.
     * @example
     * // Create many SalesOffices
     * const salesOffice = await prisma.salesOffice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesOffices and only return the `id`
     * const salesOfficeWithIdOnly = await prisma.salesOffice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesOfficeCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesOfficeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOfficePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesOffice.
     * @param {SalesOfficeDeleteArgs} args - Arguments to delete one SalesOffice.
     * @example
     * // Delete one SalesOffice
     * const SalesOffice = await prisma.salesOffice.delete({
     *   where: {
     *     // ... filter to delete one SalesOffice
     *   }
     * })
     * 
     */
    delete<T extends SalesOfficeDeleteArgs>(args: SelectSubset<T, SalesOfficeDeleteArgs<ExtArgs>>): Prisma__SalesOfficeClient<$Result.GetResult<Prisma.$SalesOfficePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesOffice.
     * @param {SalesOfficeUpdateArgs} args - Arguments to update one SalesOffice.
     * @example
     * // Update one SalesOffice
     * const salesOffice = await prisma.salesOffice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesOfficeUpdateArgs>(args: SelectSubset<T, SalesOfficeUpdateArgs<ExtArgs>>): Prisma__SalesOfficeClient<$Result.GetResult<Prisma.$SalesOfficePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesOffices.
     * @param {SalesOfficeDeleteManyArgs} args - Arguments to filter SalesOffices to delete.
     * @example
     * // Delete a few SalesOffices
     * const { count } = await prisma.salesOffice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesOfficeDeleteManyArgs>(args?: SelectSubset<T, SalesOfficeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesOffices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOfficeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesOffices
     * const salesOffice = await prisma.salesOffice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesOfficeUpdateManyArgs>(args: SelectSubset<T, SalesOfficeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesOffices and returns the data updated in the database.
     * @param {SalesOfficeUpdateManyAndReturnArgs} args - Arguments to update many SalesOffices.
     * @example
     * // Update many SalesOffices
     * const salesOffice = await prisma.salesOffice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesOffices and only return the `id`
     * const salesOfficeWithIdOnly = await prisma.salesOffice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesOfficeUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesOfficeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesOfficePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesOffice.
     * @param {SalesOfficeUpsertArgs} args - Arguments to update or create a SalesOffice.
     * @example
     * // Update or create a SalesOffice
     * const salesOffice = await prisma.salesOffice.upsert({
     *   create: {
     *     // ... data to create a SalesOffice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesOffice we want to update
     *   }
     * })
     */
    upsert<T extends SalesOfficeUpsertArgs>(args: SelectSubset<T, SalesOfficeUpsertArgs<ExtArgs>>): Prisma__SalesOfficeClient<$Result.GetResult<Prisma.$SalesOfficePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesOffices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOfficeCountArgs} args - Arguments to filter SalesOffices to count.
     * @example
     * // Count the number of SalesOffices
     * const count = await prisma.salesOffice.count({
     *   where: {
     *     // ... the filter for the SalesOffices we want to count
     *   }
     * })
    **/
    count<T extends SalesOfficeCountArgs>(
      args?: Subset<T, SalesOfficeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesOfficeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesOffice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOfficeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesOfficeAggregateArgs>(args: Subset<T, SalesOfficeAggregateArgs>): Prisma.PrismaPromise<GetSalesOfficeAggregateType<T>>

    /**
     * Group by SalesOffice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesOfficeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesOfficeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesOfficeGroupByArgs['orderBy'] }
        : { orderBy?: SalesOfficeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesOfficeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesOfficeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesOffice model
   */
  readonly fields: SalesOfficeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesOffice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesOfficeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    officeTeamPairs<T extends SalesOffice$officeTeamPairsArgs<ExtArgs> = {}>(args?: Subset<T, SalesOffice$officeTeamPairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesChannelOfficeTeamPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    businessUnitSalesPairs<T extends SalesOffice$businessUnitSalesPairsArgs<ExtArgs> = {}>(args?: Subset<T, SalesOffice$businessUnitSalesPairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitSalesPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesOffice model
   */
  interface SalesOfficeFieldRefs {
    readonly id: FieldRef<"SalesOffice", 'Int'>
    readonly salesOfficeId: FieldRef<"SalesOffice", 'String'>
    readonly organizationName: FieldRef<"SalesOffice", 'String'>
    readonly salesOfficeDesc: FieldRef<"SalesOffice", 'String'>
    readonly street1: FieldRef<"SalesOffice", 'String'>
    readonly street2: FieldRef<"SalesOffice", 'String'>
    readonly city: FieldRef<"SalesOffice", 'String'>
    readonly state: FieldRef<"SalesOffice", 'String'>
    readonly region: FieldRef<"SalesOffice", 'String'>
    readonly country: FieldRef<"SalesOffice", 'String'>
    readonly pinCode: FieldRef<"SalesOffice", 'String'>
    readonly validFrom: FieldRef<"SalesOffice", 'DateTime'>
    readonly validTo: FieldRef<"SalesOffice", 'DateTime'>
    readonly company: FieldRef<"SalesOffice", 'String'>
    readonly parentUnit: FieldRef<"SalesOffice", 'String'>
    readonly createdAt: FieldRef<"SalesOffice", 'DateTime'>
    readonly updatedAt: FieldRef<"SalesOffice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesOffice findUnique
   */
  export type SalesOfficeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOffice
     */
    select?: SalesOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOffice
     */
    omit?: SalesOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOfficeInclude<ExtArgs> | null
    /**
     * Filter, which SalesOffice to fetch.
     */
    where: SalesOfficeWhereUniqueInput
  }

  /**
   * SalesOffice findUniqueOrThrow
   */
  export type SalesOfficeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOffice
     */
    select?: SalesOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOffice
     */
    omit?: SalesOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOfficeInclude<ExtArgs> | null
    /**
     * Filter, which SalesOffice to fetch.
     */
    where: SalesOfficeWhereUniqueInput
  }

  /**
   * SalesOffice findFirst
   */
  export type SalesOfficeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOffice
     */
    select?: SalesOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOffice
     */
    omit?: SalesOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOfficeInclude<ExtArgs> | null
    /**
     * Filter, which SalesOffice to fetch.
     */
    where?: SalesOfficeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOffices to fetch.
     */
    orderBy?: SalesOfficeOrderByWithRelationInput | SalesOfficeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesOffices.
     */
    cursor?: SalesOfficeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOffices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOffices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesOffices.
     */
    distinct?: SalesOfficeScalarFieldEnum | SalesOfficeScalarFieldEnum[]
  }

  /**
   * SalesOffice findFirstOrThrow
   */
  export type SalesOfficeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOffice
     */
    select?: SalesOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOffice
     */
    omit?: SalesOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOfficeInclude<ExtArgs> | null
    /**
     * Filter, which SalesOffice to fetch.
     */
    where?: SalesOfficeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOffices to fetch.
     */
    orderBy?: SalesOfficeOrderByWithRelationInput | SalesOfficeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesOffices.
     */
    cursor?: SalesOfficeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOffices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOffices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesOffices.
     */
    distinct?: SalesOfficeScalarFieldEnum | SalesOfficeScalarFieldEnum[]
  }

  /**
   * SalesOffice findMany
   */
  export type SalesOfficeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOffice
     */
    select?: SalesOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOffice
     */
    omit?: SalesOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOfficeInclude<ExtArgs> | null
    /**
     * Filter, which SalesOffices to fetch.
     */
    where?: SalesOfficeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesOffices to fetch.
     */
    orderBy?: SalesOfficeOrderByWithRelationInput | SalesOfficeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesOffices.
     */
    cursor?: SalesOfficeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesOffices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesOffices.
     */
    skip?: number
    distinct?: SalesOfficeScalarFieldEnum | SalesOfficeScalarFieldEnum[]
  }

  /**
   * SalesOffice create
   */
  export type SalesOfficeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOffice
     */
    select?: SalesOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOffice
     */
    omit?: SalesOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOfficeInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesOffice.
     */
    data: XOR<SalesOfficeCreateInput, SalesOfficeUncheckedCreateInput>
  }

  /**
   * SalesOffice createMany
   */
  export type SalesOfficeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesOffices.
     */
    data: SalesOfficeCreateManyInput | SalesOfficeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesOffice createManyAndReturn
   */
  export type SalesOfficeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOffice
     */
    select?: SalesOfficeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOffice
     */
    omit?: SalesOfficeOmit<ExtArgs> | null
    /**
     * The data used to create many SalesOffices.
     */
    data: SalesOfficeCreateManyInput | SalesOfficeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesOffice update
   */
  export type SalesOfficeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOffice
     */
    select?: SalesOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOffice
     */
    omit?: SalesOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOfficeInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesOffice.
     */
    data: XOR<SalesOfficeUpdateInput, SalesOfficeUncheckedUpdateInput>
    /**
     * Choose, which SalesOffice to update.
     */
    where: SalesOfficeWhereUniqueInput
  }

  /**
   * SalesOffice updateMany
   */
  export type SalesOfficeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesOffices.
     */
    data: XOR<SalesOfficeUpdateManyMutationInput, SalesOfficeUncheckedUpdateManyInput>
    /**
     * Filter which SalesOffices to update
     */
    where?: SalesOfficeWhereInput
    /**
     * Limit how many SalesOffices to update.
     */
    limit?: number
  }

  /**
   * SalesOffice updateManyAndReturn
   */
  export type SalesOfficeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOffice
     */
    select?: SalesOfficeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOffice
     */
    omit?: SalesOfficeOmit<ExtArgs> | null
    /**
     * The data used to update SalesOffices.
     */
    data: XOR<SalesOfficeUpdateManyMutationInput, SalesOfficeUncheckedUpdateManyInput>
    /**
     * Filter which SalesOffices to update
     */
    where?: SalesOfficeWhereInput
    /**
     * Limit how many SalesOffices to update.
     */
    limit?: number
  }

  /**
   * SalesOffice upsert
   */
  export type SalesOfficeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOffice
     */
    select?: SalesOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOffice
     */
    omit?: SalesOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOfficeInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesOffice to update in case it exists.
     */
    where: SalesOfficeWhereUniqueInput
    /**
     * In case the SalesOffice found by the `where` argument doesn't exist, create a new SalesOffice with this data.
     */
    create: XOR<SalesOfficeCreateInput, SalesOfficeUncheckedCreateInput>
    /**
     * In case the SalesOffice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesOfficeUpdateInput, SalesOfficeUncheckedUpdateInput>
  }

  /**
   * SalesOffice delete
   */
  export type SalesOfficeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOffice
     */
    select?: SalesOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOffice
     */
    omit?: SalesOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOfficeInclude<ExtArgs> | null
    /**
     * Filter which SalesOffice to delete.
     */
    where: SalesOfficeWhereUniqueInput
  }

  /**
   * SalesOffice deleteMany
   */
  export type SalesOfficeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesOffices to delete
     */
    where?: SalesOfficeWhereInput
    /**
     * Limit how many SalesOffices to delete.
     */
    limit?: number
  }

  /**
   * SalesOffice.officeTeamPairs
   */
  export type SalesOffice$officeTeamPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannelOfficeTeamPair
     */
    select?: SalesChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannelOfficeTeamPair
     */
    omit?: SalesChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelOfficeTeamPairInclude<ExtArgs> | null
    where?: SalesChannelOfficeTeamPairWhereInput
    orderBy?: SalesChannelOfficeTeamPairOrderByWithRelationInput | SalesChannelOfficeTeamPairOrderByWithRelationInput[]
    cursor?: SalesChannelOfficeTeamPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesChannelOfficeTeamPairScalarFieldEnum | SalesChannelOfficeTeamPairScalarFieldEnum[]
  }

  /**
   * SalesOffice.businessUnitSalesPairs
   */
  export type SalesOffice$businessUnitSalesPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSalesPair
     */
    select?: BusinessUnitSalesPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitSalesPair
     */
    omit?: BusinessUnitSalesPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSalesPairInclude<ExtArgs> | null
    where?: BusinessUnitSalesPairWhereInput
    orderBy?: BusinessUnitSalesPairOrderByWithRelationInput | BusinessUnitSalesPairOrderByWithRelationInput[]
    cursor?: BusinessUnitSalesPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessUnitSalesPairScalarFieldEnum | BusinessUnitSalesPairScalarFieldEnum[]
  }

  /**
   * SalesOffice without action
   */
  export type SalesOfficeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesOffice
     */
    select?: SalesOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesOffice
     */
    omit?: SalesOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesOfficeInclude<ExtArgs> | null
  }


  /**
   * Model SalesTeam
   */

  export type AggregateSalesTeam = {
    _count: SalesTeamCountAggregateOutputType | null
    _avg: SalesTeamAvgAggregateOutputType | null
    _sum: SalesTeamSumAggregateOutputType | null
    _min: SalesTeamMinAggregateOutputType | null
    _max: SalesTeamMaxAggregateOutputType | null
  }

  export type SalesTeamAvgAggregateOutputType = {
    id: number | null
  }

  export type SalesTeamSumAggregateOutputType = {
    id: number | null
  }

  export type SalesTeamMinAggregateOutputType = {
    id: number | null
    salesTeamCode: string | null
    salesTeamName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesTeamMaxAggregateOutputType = {
    id: number | null
    salesTeamCode: string | null
    salesTeamName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesTeamCountAggregateOutputType = {
    id: number
    salesTeamCode: number
    salesTeamName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesTeamAvgAggregateInputType = {
    id?: true
  }

  export type SalesTeamSumAggregateInputType = {
    id?: true
  }

  export type SalesTeamMinAggregateInputType = {
    id?: true
    salesTeamCode?: true
    salesTeamName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesTeamMaxAggregateInputType = {
    id?: true
    salesTeamCode?: true
    salesTeamName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesTeamCountAggregateInputType = {
    id?: true
    salesTeamCode?: true
    salesTeamName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesTeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesTeam to aggregate.
     */
    where?: SalesTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeams to fetch.
     */
    orderBy?: SalesTeamOrderByWithRelationInput | SalesTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesTeams
    **/
    _count?: true | SalesTeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesTeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesTeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesTeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesTeamMaxAggregateInputType
  }

  export type GetSalesTeamAggregateType<T extends SalesTeamAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesTeam[P]>
      : GetScalarType<T[P], AggregateSalesTeam[P]>
  }




  export type SalesTeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesTeamWhereInput
    orderBy?: SalesTeamOrderByWithAggregationInput | SalesTeamOrderByWithAggregationInput[]
    by: SalesTeamScalarFieldEnum[] | SalesTeamScalarFieldEnum
    having?: SalesTeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesTeamCountAggregateInputType | true
    _avg?: SalesTeamAvgAggregateInputType
    _sum?: SalesTeamSumAggregateInputType
    _min?: SalesTeamMinAggregateInputType
    _max?: SalesTeamMaxAggregateInputType
  }

  export type SalesTeamGroupByOutputType = {
    id: number
    salesTeamCode: string
    salesTeamName: string
    createdAt: Date
    updatedAt: Date
    _count: SalesTeamCountAggregateOutputType | null
    _avg: SalesTeamAvgAggregateOutputType | null
    _sum: SalesTeamSumAggregateOutputType | null
    _min: SalesTeamMinAggregateOutputType | null
    _max: SalesTeamMaxAggregateOutputType | null
  }

  type GetSalesTeamGroupByPayload<T extends SalesTeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesTeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesTeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesTeamGroupByOutputType[P]>
            : GetScalarType<T[P], SalesTeamGroupByOutputType[P]>
        }
      >
    >


  export type SalesTeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesTeamCode?: boolean
    salesTeamName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeTeamPairs?: boolean | SalesTeam$officeTeamPairsArgs<ExtArgs>
    businessUnitSalesPairs?: boolean | SalesTeam$businessUnitSalesPairsArgs<ExtArgs>
    _count?: boolean | SalesTeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesTeam"]>

  export type SalesTeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesTeamCode?: boolean
    salesTeamName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["salesTeam"]>

  export type SalesTeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesTeamCode?: boolean
    salesTeamName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["salesTeam"]>

  export type SalesTeamSelectScalar = {
    id?: boolean
    salesTeamCode?: boolean
    salesTeamName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalesTeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "salesTeamCode" | "salesTeamName" | "createdAt" | "updatedAt", ExtArgs["result"]["salesTeam"]>
  export type SalesTeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    officeTeamPairs?: boolean | SalesTeam$officeTeamPairsArgs<ExtArgs>
    businessUnitSalesPairs?: boolean | SalesTeam$businessUnitSalesPairsArgs<ExtArgs>
    _count?: boolean | SalesTeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SalesTeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SalesTeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SalesTeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesTeam"
    objects: {
      officeTeamPairs: Prisma.$SalesChannelOfficeTeamPairPayload<ExtArgs>[]
      businessUnitSalesPairs: Prisma.$BusinessUnitSalesPairPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      salesTeamCode: string
      salesTeamName: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salesTeam"]>
    composites: {}
  }

  type SalesTeamGetPayload<S extends boolean | null | undefined | SalesTeamDefaultArgs> = $Result.GetResult<Prisma.$SalesTeamPayload, S>

  type SalesTeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesTeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesTeamCountAggregateInputType | true
    }

  export interface SalesTeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesTeam'], meta: { name: 'SalesTeam' } }
    /**
     * Find zero or one SalesTeam that matches the filter.
     * @param {SalesTeamFindUniqueArgs} args - Arguments to find a SalesTeam
     * @example
     * // Get one SalesTeam
     * const salesTeam = await prisma.salesTeam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesTeamFindUniqueArgs>(args: SelectSubset<T, SalesTeamFindUniqueArgs<ExtArgs>>): Prisma__SalesTeamClient<$Result.GetResult<Prisma.$SalesTeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesTeam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesTeamFindUniqueOrThrowArgs} args - Arguments to find a SalesTeam
     * @example
     * // Get one SalesTeam
     * const salesTeam = await prisma.salesTeam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesTeamFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesTeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesTeamClient<$Result.GetResult<Prisma.$SalesTeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesTeam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamFindFirstArgs} args - Arguments to find a SalesTeam
     * @example
     * // Get one SalesTeam
     * const salesTeam = await prisma.salesTeam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesTeamFindFirstArgs>(args?: SelectSubset<T, SalesTeamFindFirstArgs<ExtArgs>>): Prisma__SalesTeamClient<$Result.GetResult<Prisma.$SalesTeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesTeam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamFindFirstOrThrowArgs} args - Arguments to find a SalesTeam
     * @example
     * // Get one SalesTeam
     * const salesTeam = await prisma.salesTeam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesTeamFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesTeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesTeamClient<$Result.GetResult<Prisma.$SalesTeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesTeams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesTeams
     * const salesTeams = await prisma.salesTeam.findMany()
     * 
     * // Get first 10 SalesTeams
     * const salesTeams = await prisma.salesTeam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesTeamWithIdOnly = await prisma.salesTeam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesTeamFindManyArgs>(args?: SelectSubset<T, SalesTeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesTeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesTeam.
     * @param {SalesTeamCreateArgs} args - Arguments to create a SalesTeam.
     * @example
     * // Create one SalesTeam
     * const SalesTeam = await prisma.salesTeam.create({
     *   data: {
     *     // ... data to create a SalesTeam
     *   }
     * })
     * 
     */
    create<T extends SalesTeamCreateArgs>(args: SelectSubset<T, SalesTeamCreateArgs<ExtArgs>>): Prisma__SalesTeamClient<$Result.GetResult<Prisma.$SalesTeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesTeams.
     * @param {SalesTeamCreateManyArgs} args - Arguments to create many SalesTeams.
     * @example
     * // Create many SalesTeams
     * const salesTeam = await prisma.salesTeam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesTeamCreateManyArgs>(args?: SelectSubset<T, SalesTeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesTeams and returns the data saved in the database.
     * @param {SalesTeamCreateManyAndReturnArgs} args - Arguments to create many SalesTeams.
     * @example
     * // Create many SalesTeams
     * const salesTeam = await prisma.salesTeam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesTeams and only return the `id`
     * const salesTeamWithIdOnly = await prisma.salesTeam.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesTeamCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesTeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesTeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesTeam.
     * @param {SalesTeamDeleteArgs} args - Arguments to delete one SalesTeam.
     * @example
     * // Delete one SalesTeam
     * const SalesTeam = await prisma.salesTeam.delete({
     *   where: {
     *     // ... filter to delete one SalesTeam
     *   }
     * })
     * 
     */
    delete<T extends SalesTeamDeleteArgs>(args: SelectSubset<T, SalesTeamDeleteArgs<ExtArgs>>): Prisma__SalesTeamClient<$Result.GetResult<Prisma.$SalesTeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesTeam.
     * @param {SalesTeamUpdateArgs} args - Arguments to update one SalesTeam.
     * @example
     * // Update one SalesTeam
     * const salesTeam = await prisma.salesTeam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesTeamUpdateArgs>(args: SelectSubset<T, SalesTeamUpdateArgs<ExtArgs>>): Prisma__SalesTeamClient<$Result.GetResult<Prisma.$SalesTeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesTeams.
     * @param {SalesTeamDeleteManyArgs} args - Arguments to filter SalesTeams to delete.
     * @example
     * // Delete a few SalesTeams
     * const { count } = await prisma.salesTeam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesTeamDeleteManyArgs>(args?: SelectSubset<T, SalesTeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesTeams
     * const salesTeam = await prisma.salesTeam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesTeamUpdateManyArgs>(args: SelectSubset<T, SalesTeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesTeams and returns the data updated in the database.
     * @param {SalesTeamUpdateManyAndReturnArgs} args - Arguments to update many SalesTeams.
     * @example
     * // Update many SalesTeams
     * const salesTeam = await prisma.salesTeam.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesTeams and only return the `id`
     * const salesTeamWithIdOnly = await prisma.salesTeam.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesTeamUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesTeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesTeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesTeam.
     * @param {SalesTeamUpsertArgs} args - Arguments to update or create a SalesTeam.
     * @example
     * // Update or create a SalesTeam
     * const salesTeam = await prisma.salesTeam.upsert({
     *   create: {
     *     // ... data to create a SalesTeam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesTeam we want to update
     *   }
     * })
     */
    upsert<T extends SalesTeamUpsertArgs>(args: SelectSubset<T, SalesTeamUpsertArgs<ExtArgs>>): Prisma__SalesTeamClient<$Result.GetResult<Prisma.$SalesTeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamCountArgs} args - Arguments to filter SalesTeams to count.
     * @example
     * // Count the number of SalesTeams
     * const count = await prisma.salesTeam.count({
     *   where: {
     *     // ... the filter for the SalesTeams we want to count
     *   }
     * })
    **/
    count<T extends SalesTeamCountArgs>(
      args?: Subset<T, SalesTeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesTeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesTeamAggregateArgs>(args: Subset<T, SalesTeamAggregateArgs>): Prisma.PrismaPromise<GetSalesTeamAggregateType<T>>

    /**
     * Group by SalesTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesTeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesTeamGroupByArgs['orderBy'] }
        : { orderBy?: SalesTeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesTeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesTeam model
   */
  readonly fields: SalesTeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesTeam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesTeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    officeTeamPairs<T extends SalesTeam$officeTeamPairsArgs<ExtArgs> = {}>(args?: Subset<T, SalesTeam$officeTeamPairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesChannelOfficeTeamPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    businessUnitSalesPairs<T extends SalesTeam$businessUnitSalesPairsArgs<ExtArgs> = {}>(args?: Subset<T, SalesTeam$businessUnitSalesPairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitSalesPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesTeam model
   */
  interface SalesTeamFieldRefs {
    readonly id: FieldRef<"SalesTeam", 'Int'>
    readonly salesTeamCode: FieldRef<"SalesTeam", 'String'>
    readonly salesTeamName: FieldRef<"SalesTeam", 'String'>
    readonly createdAt: FieldRef<"SalesTeam", 'DateTime'>
    readonly updatedAt: FieldRef<"SalesTeam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesTeam findUnique
   */
  export type SalesTeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeam
     */
    omit?: SalesTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesTeamInclude<ExtArgs> | null
    /**
     * Filter, which SalesTeam to fetch.
     */
    where: SalesTeamWhereUniqueInput
  }

  /**
   * SalesTeam findUniqueOrThrow
   */
  export type SalesTeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeam
     */
    omit?: SalesTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesTeamInclude<ExtArgs> | null
    /**
     * Filter, which SalesTeam to fetch.
     */
    where: SalesTeamWhereUniqueInput
  }

  /**
   * SalesTeam findFirst
   */
  export type SalesTeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeam
     */
    omit?: SalesTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesTeamInclude<ExtArgs> | null
    /**
     * Filter, which SalesTeam to fetch.
     */
    where?: SalesTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeams to fetch.
     */
    orderBy?: SalesTeamOrderByWithRelationInput | SalesTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesTeams.
     */
    cursor?: SalesTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesTeams.
     */
    distinct?: SalesTeamScalarFieldEnum | SalesTeamScalarFieldEnum[]
  }

  /**
   * SalesTeam findFirstOrThrow
   */
  export type SalesTeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeam
     */
    omit?: SalesTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesTeamInclude<ExtArgs> | null
    /**
     * Filter, which SalesTeam to fetch.
     */
    where?: SalesTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeams to fetch.
     */
    orderBy?: SalesTeamOrderByWithRelationInput | SalesTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesTeams.
     */
    cursor?: SalesTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesTeams.
     */
    distinct?: SalesTeamScalarFieldEnum | SalesTeamScalarFieldEnum[]
  }

  /**
   * SalesTeam findMany
   */
  export type SalesTeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeam
     */
    omit?: SalesTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesTeamInclude<ExtArgs> | null
    /**
     * Filter, which SalesTeams to fetch.
     */
    where?: SalesTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeams to fetch.
     */
    orderBy?: SalesTeamOrderByWithRelationInput | SalesTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesTeams.
     */
    cursor?: SalesTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeams.
     */
    skip?: number
    distinct?: SalesTeamScalarFieldEnum | SalesTeamScalarFieldEnum[]
  }

  /**
   * SalesTeam create
   */
  export type SalesTeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeam
     */
    omit?: SalesTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesTeamInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesTeam.
     */
    data: XOR<SalesTeamCreateInput, SalesTeamUncheckedCreateInput>
  }

  /**
   * SalesTeam createMany
   */
  export type SalesTeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesTeams.
     */
    data: SalesTeamCreateManyInput | SalesTeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesTeam createManyAndReturn
   */
  export type SalesTeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeam
     */
    omit?: SalesTeamOmit<ExtArgs> | null
    /**
     * The data used to create many SalesTeams.
     */
    data: SalesTeamCreateManyInput | SalesTeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesTeam update
   */
  export type SalesTeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeam
     */
    omit?: SalesTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesTeamInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesTeam.
     */
    data: XOR<SalesTeamUpdateInput, SalesTeamUncheckedUpdateInput>
    /**
     * Choose, which SalesTeam to update.
     */
    where: SalesTeamWhereUniqueInput
  }

  /**
   * SalesTeam updateMany
   */
  export type SalesTeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesTeams.
     */
    data: XOR<SalesTeamUpdateManyMutationInput, SalesTeamUncheckedUpdateManyInput>
    /**
     * Filter which SalesTeams to update
     */
    where?: SalesTeamWhereInput
    /**
     * Limit how many SalesTeams to update.
     */
    limit?: number
  }

  /**
   * SalesTeam updateManyAndReturn
   */
  export type SalesTeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeam
     */
    omit?: SalesTeamOmit<ExtArgs> | null
    /**
     * The data used to update SalesTeams.
     */
    data: XOR<SalesTeamUpdateManyMutationInput, SalesTeamUncheckedUpdateManyInput>
    /**
     * Filter which SalesTeams to update
     */
    where?: SalesTeamWhereInput
    /**
     * Limit how many SalesTeams to update.
     */
    limit?: number
  }

  /**
   * SalesTeam upsert
   */
  export type SalesTeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeam
     */
    omit?: SalesTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesTeamInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesTeam to update in case it exists.
     */
    where: SalesTeamWhereUniqueInput
    /**
     * In case the SalesTeam found by the `where` argument doesn't exist, create a new SalesTeam with this data.
     */
    create: XOR<SalesTeamCreateInput, SalesTeamUncheckedCreateInput>
    /**
     * In case the SalesTeam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesTeamUpdateInput, SalesTeamUncheckedUpdateInput>
  }

  /**
   * SalesTeam delete
   */
  export type SalesTeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeam
     */
    omit?: SalesTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesTeamInclude<ExtArgs> | null
    /**
     * Filter which SalesTeam to delete.
     */
    where: SalesTeamWhereUniqueInput
  }

  /**
   * SalesTeam deleteMany
   */
  export type SalesTeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesTeams to delete
     */
    where?: SalesTeamWhereInput
    /**
     * Limit how many SalesTeams to delete.
     */
    limit?: number
  }

  /**
   * SalesTeam.officeTeamPairs
   */
  export type SalesTeam$officeTeamPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannelOfficeTeamPair
     */
    select?: SalesChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannelOfficeTeamPair
     */
    omit?: SalesChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelOfficeTeamPairInclude<ExtArgs> | null
    where?: SalesChannelOfficeTeamPairWhereInput
    orderBy?: SalesChannelOfficeTeamPairOrderByWithRelationInput | SalesChannelOfficeTeamPairOrderByWithRelationInput[]
    cursor?: SalesChannelOfficeTeamPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesChannelOfficeTeamPairScalarFieldEnum | SalesChannelOfficeTeamPairScalarFieldEnum[]
  }

  /**
   * SalesTeam.businessUnitSalesPairs
   */
  export type SalesTeam$businessUnitSalesPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSalesPair
     */
    select?: BusinessUnitSalesPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitSalesPair
     */
    omit?: BusinessUnitSalesPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSalesPairInclude<ExtArgs> | null
    where?: BusinessUnitSalesPairWhereInput
    orderBy?: BusinessUnitSalesPairOrderByWithRelationInput | BusinessUnitSalesPairOrderByWithRelationInput[]
    cursor?: BusinessUnitSalesPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessUnitSalesPairScalarFieldEnum | BusinessUnitSalesPairScalarFieldEnum[]
  }

  /**
   * SalesTeam without action
   */
  export type SalesTeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeam
     */
    select?: SalesTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeam
     */
    omit?: SalesTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesTeamInclude<ExtArgs> | null
  }


  /**
   * Model SalesChannelOfficeTeamPair
   */

  export type AggregateSalesChannelOfficeTeamPair = {
    _count: SalesChannelOfficeTeamPairCountAggregateOutputType | null
    _avg: SalesChannelOfficeTeamPairAvgAggregateOutputType | null
    _sum: SalesChannelOfficeTeamPairSumAggregateOutputType | null
    _min: SalesChannelOfficeTeamPairMinAggregateOutputType | null
    _max: SalesChannelOfficeTeamPairMaxAggregateOutputType | null
  }

  export type SalesChannelOfficeTeamPairAvgAggregateOutputType = {
    id: number | null
  }

  export type SalesChannelOfficeTeamPairSumAggregateOutputType = {
    id: number | null
  }

  export type SalesChannelOfficeTeamPairMinAggregateOutputType = {
    id: number | null
    salesChannelCode: string | null
    salesOfficeId: string | null
    salesTeamCode: string | null
  }

  export type SalesChannelOfficeTeamPairMaxAggregateOutputType = {
    id: number | null
    salesChannelCode: string | null
    salesOfficeId: string | null
    salesTeamCode: string | null
  }

  export type SalesChannelOfficeTeamPairCountAggregateOutputType = {
    id: number
    salesChannelCode: number
    salesOfficeId: number
    salesTeamCode: number
    _all: number
  }


  export type SalesChannelOfficeTeamPairAvgAggregateInputType = {
    id?: true
  }

  export type SalesChannelOfficeTeamPairSumAggregateInputType = {
    id?: true
  }

  export type SalesChannelOfficeTeamPairMinAggregateInputType = {
    id?: true
    salesChannelCode?: true
    salesOfficeId?: true
    salesTeamCode?: true
  }

  export type SalesChannelOfficeTeamPairMaxAggregateInputType = {
    id?: true
    salesChannelCode?: true
    salesOfficeId?: true
    salesTeamCode?: true
  }

  export type SalesChannelOfficeTeamPairCountAggregateInputType = {
    id?: true
    salesChannelCode?: true
    salesOfficeId?: true
    salesTeamCode?: true
    _all?: true
  }

  export type SalesChannelOfficeTeamPairAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesChannelOfficeTeamPair to aggregate.
     */
    where?: SalesChannelOfficeTeamPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesChannelOfficeTeamPairs to fetch.
     */
    orderBy?: SalesChannelOfficeTeamPairOrderByWithRelationInput | SalesChannelOfficeTeamPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesChannelOfficeTeamPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesChannelOfficeTeamPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesChannelOfficeTeamPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesChannelOfficeTeamPairs
    **/
    _count?: true | SalesChannelOfficeTeamPairCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesChannelOfficeTeamPairAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesChannelOfficeTeamPairSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesChannelOfficeTeamPairMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesChannelOfficeTeamPairMaxAggregateInputType
  }

  export type GetSalesChannelOfficeTeamPairAggregateType<T extends SalesChannelOfficeTeamPairAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesChannelOfficeTeamPair]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesChannelOfficeTeamPair[P]>
      : GetScalarType<T[P], AggregateSalesChannelOfficeTeamPair[P]>
  }




  export type SalesChannelOfficeTeamPairGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesChannelOfficeTeamPairWhereInput
    orderBy?: SalesChannelOfficeTeamPairOrderByWithAggregationInput | SalesChannelOfficeTeamPairOrderByWithAggregationInput[]
    by: SalesChannelOfficeTeamPairScalarFieldEnum[] | SalesChannelOfficeTeamPairScalarFieldEnum
    having?: SalesChannelOfficeTeamPairScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesChannelOfficeTeamPairCountAggregateInputType | true
    _avg?: SalesChannelOfficeTeamPairAvgAggregateInputType
    _sum?: SalesChannelOfficeTeamPairSumAggregateInputType
    _min?: SalesChannelOfficeTeamPairMinAggregateInputType
    _max?: SalesChannelOfficeTeamPairMaxAggregateInputType
  }

  export type SalesChannelOfficeTeamPairGroupByOutputType = {
    id: number
    salesChannelCode: string
    salesOfficeId: string
    salesTeamCode: string
    _count: SalesChannelOfficeTeamPairCountAggregateOutputType | null
    _avg: SalesChannelOfficeTeamPairAvgAggregateOutputType | null
    _sum: SalesChannelOfficeTeamPairSumAggregateOutputType | null
    _min: SalesChannelOfficeTeamPairMinAggregateOutputType | null
    _max: SalesChannelOfficeTeamPairMaxAggregateOutputType | null
  }

  type GetSalesChannelOfficeTeamPairGroupByPayload<T extends SalesChannelOfficeTeamPairGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesChannelOfficeTeamPairGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesChannelOfficeTeamPairGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesChannelOfficeTeamPairGroupByOutputType[P]>
            : GetScalarType<T[P], SalesChannelOfficeTeamPairGroupByOutputType[P]>
        }
      >
    >


  export type SalesChannelOfficeTeamPairSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesChannelCode?: boolean
    salesOfficeId?: boolean
    salesTeamCode?: boolean
    salesChannel?: boolean | SalesChannelDefaultArgs<ExtArgs>
    salesOffice?: boolean | SalesOfficeDefaultArgs<ExtArgs>
    salesTeam?: boolean | SalesTeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesChannelOfficeTeamPair"]>

  export type SalesChannelOfficeTeamPairSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesChannelCode?: boolean
    salesOfficeId?: boolean
    salesTeamCode?: boolean
    salesChannel?: boolean | SalesChannelDefaultArgs<ExtArgs>
    salesOffice?: boolean | SalesOfficeDefaultArgs<ExtArgs>
    salesTeam?: boolean | SalesTeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesChannelOfficeTeamPair"]>

  export type SalesChannelOfficeTeamPairSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    salesChannelCode?: boolean
    salesOfficeId?: boolean
    salesTeamCode?: boolean
    salesChannel?: boolean | SalesChannelDefaultArgs<ExtArgs>
    salesOffice?: boolean | SalesOfficeDefaultArgs<ExtArgs>
    salesTeam?: boolean | SalesTeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesChannelOfficeTeamPair"]>

  export type SalesChannelOfficeTeamPairSelectScalar = {
    id?: boolean
    salesChannelCode?: boolean
    salesOfficeId?: boolean
    salesTeamCode?: boolean
  }

  export type SalesChannelOfficeTeamPairOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "salesChannelCode" | "salesOfficeId" | "salesTeamCode", ExtArgs["result"]["salesChannelOfficeTeamPair"]>
  export type SalesChannelOfficeTeamPairInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salesChannel?: boolean | SalesChannelDefaultArgs<ExtArgs>
    salesOffice?: boolean | SalesOfficeDefaultArgs<ExtArgs>
    salesTeam?: boolean | SalesTeamDefaultArgs<ExtArgs>
  }
  export type SalesChannelOfficeTeamPairIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salesChannel?: boolean | SalesChannelDefaultArgs<ExtArgs>
    salesOffice?: boolean | SalesOfficeDefaultArgs<ExtArgs>
    salesTeam?: boolean | SalesTeamDefaultArgs<ExtArgs>
  }
  export type SalesChannelOfficeTeamPairIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    salesChannel?: boolean | SalesChannelDefaultArgs<ExtArgs>
    salesOffice?: boolean | SalesOfficeDefaultArgs<ExtArgs>
    salesTeam?: boolean | SalesTeamDefaultArgs<ExtArgs>
  }

  export type $SalesChannelOfficeTeamPairPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesChannelOfficeTeamPair"
    objects: {
      salesChannel: Prisma.$SalesChannelPayload<ExtArgs>
      salesOffice: Prisma.$SalesOfficePayload<ExtArgs>
      salesTeam: Prisma.$SalesTeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      salesChannelCode: string
      salesOfficeId: string
      salesTeamCode: string
    }, ExtArgs["result"]["salesChannelOfficeTeamPair"]>
    composites: {}
  }

  type SalesChannelOfficeTeamPairGetPayload<S extends boolean | null | undefined | SalesChannelOfficeTeamPairDefaultArgs> = $Result.GetResult<Prisma.$SalesChannelOfficeTeamPairPayload, S>

  type SalesChannelOfficeTeamPairCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesChannelOfficeTeamPairFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesChannelOfficeTeamPairCountAggregateInputType | true
    }

  export interface SalesChannelOfficeTeamPairDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesChannelOfficeTeamPair'], meta: { name: 'SalesChannelOfficeTeamPair' } }
    /**
     * Find zero or one SalesChannelOfficeTeamPair that matches the filter.
     * @param {SalesChannelOfficeTeamPairFindUniqueArgs} args - Arguments to find a SalesChannelOfficeTeamPair
     * @example
     * // Get one SalesChannelOfficeTeamPair
     * const salesChannelOfficeTeamPair = await prisma.salesChannelOfficeTeamPair.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesChannelOfficeTeamPairFindUniqueArgs>(args: SelectSubset<T, SalesChannelOfficeTeamPairFindUniqueArgs<ExtArgs>>): Prisma__SalesChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$SalesChannelOfficeTeamPairPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesChannelOfficeTeamPair that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesChannelOfficeTeamPairFindUniqueOrThrowArgs} args - Arguments to find a SalesChannelOfficeTeamPair
     * @example
     * // Get one SalesChannelOfficeTeamPair
     * const salesChannelOfficeTeamPair = await prisma.salesChannelOfficeTeamPair.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesChannelOfficeTeamPairFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesChannelOfficeTeamPairFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$SalesChannelOfficeTeamPairPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesChannelOfficeTeamPair that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesChannelOfficeTeamPairFindFirstArgs} args - Arguments to find a SalesChannelOfficeTeamPair
     * @example
     * // Get one SalesChannelOfficeTeamPair
     * const salesChannelOfficeTeamPair = await prisma.salesChannelOfficeTeamPair.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesChannelOfficeTeamPairFindFirstArgs>(args?: SelectSubset<T, SalesChannelOfficeTeamPairFindFirstArgs<ExtArgs>>): Prisma__SalesChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$SalesChannelOfficeTeamPairPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesChannelOfficeTeamPair that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesChannelOfficeTeamPairFindFirstOrThrowArgs} args - Arguments to find a SalesChannelOfficeTeamPair
     * @example
     * // Get one SalesChannelOfficeTeamPair
     * const salesChannelOfficeTeamPair = await prisma.salesChannelOfficeTeamPair.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesChannelOfficeTeamPairFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesChannelOfficeTeamPairFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$SalesChannelOfficeTeamPairPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesChannelOfficeTeamPairs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesChannelOfficeTeamPairFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesChannelOfficeTeamPairs
     * const salesChannelOfficeTeamPairs = await prisma.salesChannelOfficeTeamPair.findMany()
     * 
     * // Get first 10 SalesChannelOfficeTeamPairs
     * const salesChannelOfficeTeamPairs = await prisma.salesChannelOfficeTeamPair.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesChannelOfficeTeamPairWithIdOnly = await prisma.salesChannelOfficeTeamPair.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesChannelOfficeTeamPairFindManyArgs>(args?: SelectSubset<T, SalesChannelOfficeTeamPairFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesChannelOfficeTeamPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesChannelOfficeTeamPair.
     * @param {SalesChannelOfficeTeamPairCreateArgs} args - Arguments to create a SalesChannelOfficeTeamPair.
     * @example
     * // Create one SalesChannelOfficeTeamPair
     * const SalesChannelOfficeTeamPair = await prisma.salesChannelOfficeTeamPair.create({
     *   data: {
     *     // ... data to create a SalesChannelOfficeTeamPair
     *   }
     * })
     * 
     */
    create<T extends SalesChannelOfficeTeamPairCreateArgs>(args: SelectSubset<T, SalesChannelOfficeTeamPairCreateArgs<ExtArgs>>): Prisma__SalesChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$SalesChannelOfficeTeamPairPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesChannelOfficeTeamPairs.
     * @param {SalesChannelOfficeTeamPairCreateManyArgs} args - Arguments to create many SalesChannelOfficeTeamPairs.
     * @example
     * // Create many SalesChannelOfficeTeamPairs
     * const salesChannelOfficeTeamPair = await prisma.salesChannelOfficeTeamPair.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesChannelOfficeTeamPairCreateManyArgs>(args?: SelectSubset<T, SalesChannelOfficeTeamPairCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesChannelOfficeTeamPairs and returns the data saved in the database.
     * @param {SalesChannelOfficeTeamPairCreateManyAndReturnArgs} args - Arguments to create many SalesChannelOfficeTeamPairs.
     * @example
     * // Create many SalesChannelOfficeTeamPairs
     * const salesChannelOfficeTeamPair = await prisma.salesChannelOfficeTeamPair.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesChannelOfficeTeamPairs and only return the `id`
     * const salesChannelOfficeTeamPairWithIdOnly = await prisma.salesChannelOfficeTeamPair.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesChannelOfficeTeamPairCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesChannelOfficeTeamPairCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesChannelOfficeTeamPairPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesChannelOfficeTeamPair.
     * @param {SalesChannelOfficeTeamPairDeleteArgs} args - Arguments to delete one SalesChannelOfficeTeamPair.
     * @example
     * // Delete one SalesChannelOfficeTeamPair
     * const SalesChannelOfficeTeamPair = await prisma.salesChannelOfficeTeamPair.delete({
     *   where: {
     *     // ... filter to delete one SalesChannelOfficeTeamPair
     *   }
     * })
     * 
     */
    delete<T extends SalesChannelOfficeTeamPairDeleteArgs>(args: SelectSubset<T, SalesChannelOfficeTeamPairDeleteArgs<ExtArgs>>): Prisma__SalesChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$SalesChannelOfficeTeamPairPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesChannelOfficeTeamPair.
     * @param {SalesChannelOfficeTeamPairUpdateArgs} args - Arguments to update one SalesChannelOfficeTeamPair.
     * @example
     * // Update one SalesChannelOfficeTeamPair
     * const salesChannelOfficeTeamPair = await prisma.salesChannelOfficeTeamPair.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesChannelOfficeTeamPairUpdateArgs>(args: SelectSubset<T, SalesChannelOfficeTeamPairUpdateArgs<ExtArgs>>): Prisma__SalesChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$SalesChannelOfficeTeamPairPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesChannelOfficeTeamPairs.
     * @param {SalesChannelOfficeTeamPairDeleteManyArgs} args - Arguments to filter SalesChannelOfficeTeamPairs to delete.
     * @example
     * // Delete a few SalesChannelOfficeTeamPairs
     * const { count } = await prisma.salesChannelOfficeTeamPair.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesChannelOfficeTeamPairDeleteManyArgs>(args?: SelectSubset<T, SalesChannelOfficeTeamPairDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesChannelOfficeTeamPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesChannelOfficeTeamPairUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesChannelOfficeTeamPairs
     * const salesChannelOfficeTeamPair = await prisma.salesChannelOfficeTeamPair.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesChannelOfficeTeamPairUpdateManyArgs>(args: SelectSubset<T, SalesChannelOfficeTeamPairUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesChannelOfficeTeamPairs and returns the data updated in the database.
     * @param {SalesChannelOfficeTeamPairUpdateManyAndReturnArgs} args - Arguments to update many SalesChannelOfficeTeamPairs.
     * @example
     * // Update many SalesChannelOfficeTeamPairs
     * const salesChannelOfficeTeamPair = await prisma.salesChannelOfficeTeamPair.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesChannelOfficeTeamPairs and only return the `id`
     * const salesChannelOfficeTeamPairWithIdOnly = await prisma.salesChannelOfficeTeamPair.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesChannelOfficeTeamPairUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesChannelOfficeTeamPairUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesChannelOfficeTeamPairPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesChannelOfficeTeamPair.
     * @param {SalesChannelOfficeTeamPairUpsertArgs} args - Arguments to update or create a SalesChannelOfficeTeamPair.
     * @example
     * // Update or create a SalesChannelOfficeTeamPair
     * const salesChannelOfficeTeamPair = await prisma.salesChannelOfficeTeamPair.upsert({
     *   create: {
     *     // ... data to create a SalesChannelOfficeTeamPair
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesChannelOfficeTeamPair we want to update
     *   }
     * })
     */
    upsert<T extends SalesChannelOfficeTeamPairUpsertArgs>(args: SelectSubset<T, SalesChannelOfficeTeamPairUpsertArgs<ExtArgs>>): Prisma__SalesChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$SalesChannelOfficeTeamPairPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesChannelOfficeTeamPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesChannelOfficeTeamPairCountArgs} args - Arguments to filter SalesChannelOfficeTeamPairs to count.
     * @example
     * // Count the number of SalesChannelOfficeTeamPairs
     * const count = await prisma.salesChannelOfficeTeamPair.count({
     *   where: {
     *     // ... the filter for the SalesChannelOfficeTeamPairs we want to count
     *   }
     * })
    **/
    count<T extends SalesChannelOfficeTeamPairCountArgs>(
      args?: Subset<T, SalesChannelOfficeTeamPairCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesChannelOfficeTeamPairCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesChannelOfficeTeamPair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesChannelOfficeTeamPairAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesChannelOfficeTeamPairAggregateArgs>(args: Subset<T, SalesChannelOfficeTeamPairAggregateArgs>): Prisma.PrismaPromise<GetSalesChannelOfficeTeamPairAggregateType<T>>

    /**
     * Group by SalesChannelOfficeTeamPair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesChannelOfficeTeamPairGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesChannelOfficeTeamPairGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesChannelOfficeTeamPairGroupByArgs['orderBy'] }
        : { orderBy?: SalesChannelOfficeTeamPairGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesChannelOfficeTeamPairGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesChannelOfficeTeamPairGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesChannelOfficeTeamPair model
   */
  readonly fields: SalesChannelOfficeTeamPairFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesChannelOfficeTeamPair.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesChannelOfficeTeamPairClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    salesChannel<T extends SalesChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesChannelDefaultArgs<ExtArgs>>): Prisma__SalesChannelClient<$Result.GetResult<Prisma.$SalesChannelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    salesOffice<T extends SalesOfficeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesOfficeDefaultArgs<ExtArgs>>): Prisma__SalesOfficeClient<$Result.GetResult<Prisma.$SalesOfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    salesTeam<T extends SalesTeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesTeamDefaultArgs<ExtArgs>>): Prisma__SalesTeamClient<$Result.GetResult<Prisma.$SalesTeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesChannelOfficeTeamPair model
   */
  interface SalesChannelOfficeTeamPairFieldRefs {
    readonly id: FieldRef<"SalesChannelOfficeTeamPair", 'Int'>
    readonly salesChannelCode: FieldRef<"SalesChannelOfficeTeamPair", 'String'>
    readonly salesOfficeId: FieldRef<"SalesChannelOfficeTeamPair", 'String'>
    readonly salesTeamCode: FieldRef<"SalesChannelOfficeTeamPair", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SalesChannelOfficeTeamPair findUnique
   */
  export type SalesChannelOfficeTeamPairFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannelOfficeTeamPair
     */
    select?: SalesChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannelOfficeTeamPair
     */
    omit?: SalesChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * Filter, which SalesChannelOfficeTeamPair to fetch.
     */
    where: SalesChannelOfficeTeamPairWhereUniqueInput
  }

  /**
   * SalesChannelOfficeTeamPair findUniqueOrThrow
   */
  export type SalesChannelOfficeTeamPairFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannelOfficeTeamPair
     */
    select?: SalesChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannelOfficeTeamPair
     */
    omit?: SalesChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * Filter, which SalesChannelOfficeTeamPair to fetch.
     */
    where: SalesChannelOfficeTeamPairWhereUniqueInput
  }

  /**
   * SalesChannelOfficeTeamPair findFirst
   */
  export type SalesChannelOfficeTeamPairFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannelOfficeTeamPair
     */
    select?: SalesChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannelOfficeTeamPair
     */
    omit?: SalesChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * Filter, which SalesChannelOfficeTeamPair to fetch.
     */
    where?: SalesChannelOfficeTeamPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesChannelOfficeTeamPairs to fetch.
     */
    orderBy?: SalesChannelOfficeTeamPairOrderByWithRelationInput | SalesChannelOfficeTeamPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesChannelOfficeTeamPairs.
     */
    cursor?: SalesChannelOfficeTeamPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesChannelOfficeTeamPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesChannelOfficeTeamPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesChannelOfficeTeamPairs.
     */
    distinct?: SalesChannelOfficeTeamPairScalarFieldEnum | SalesChannelOfficeTeamPairScalarFieldEnum[]
  }

  /**
   * SalesChannelOfficeTeamPair findFirstOrThrow
   */
  export type SalesChannelOfficeTeamPairFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannelOfficeTeamPair
     */
    select?: SalesChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannelOfficeTeamPair
     */
    omit?: SalesChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * Filter, which SalesChannelOfficeTeamPair to fetch.
     */
    where?: SalesChannelOfficeTeamPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesChannelOfficeTeamPairs to fetch.
     */
    orderBy?: SalesChannelOfficeTeamPairOrderByWithRelationInput | SalesChannelOfficeTeamPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesChannelOfficeTeamPairs.
     */
    cursor?: SalesChannelOfficeTeamPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesChannelOfficeTeamPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesChannelOfficeTeamPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesChannelOfficeTeamPairs.
     */
    distinct?: SalesChannelOfficeTeamPairScalarFieldEnum | SalesChannelOfficeTeamPairScalarFieldEnum[]
  }

  /**
   * SalesChannelOfficeTeamPair findMany
   */
  export type SalesChannelOfficeTeamPairFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannelOfficeTeamPair
     */
    select?: SalesChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannelOfficeTeamPair
     */
    omit?: SalesChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * Filter, which SalesChannelOfficeTeamPairs to fetch.
     */
    where?: SalesChannelOfficeTeamPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesChannelOfficeTeamPairs to fetch.
     */
    orderBy?: SalesChannelOfficeTeamPairOrderByWithRelationInput | SalesChannelOfficeTeamPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesChannelOfficeTeamPairs.
     */
    cursor?: SalesChannelOfficeTeamPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesChannelOfficeTeamPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesChannelOfficeTeamPairs.
     */
    skip?: number
    distinct?: SalesChannelOfficeTeamPairScalarFieldEnum | SalesChannelOfficeTeamPairScalarFieldEnum[]
  }

  /**
   * SalesChannelOfficeTeamPair create
   */
  export type SalesChannelOfficeTeamPairCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannelOfficeTeamPair
     */
    select?: SalesChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannelOfficeTeamPair
     */
    omit?: SalesChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesChannelOfficeTeamPair.
     */
    data: XOR<SalesChannelOfficeTeamPairCreateInput, SalesChannelOfficeTeamPairUncheckedCreateInput>
  }

  /**
   * SalesChannelOfficeTeamPair createMany
   */
  export type SalesChannelOfficeTeamPairCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesChannelOfficeTeamPairs.
     */
    data: SalesChannelOfficeTeamPairCreateManyInput | SalesChannelOfficeTeamPairCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesChannelOfficeTeamPair createManyAndReturn
   */
  export type SalesChannelOfficeTeamPairCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannelOfficeTeamPair
     */
    select?: SalesChannelOfficeTeamPairSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannelOfficeTeamPair
     */
    omit?: SalesChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * The data used to create many SalesChannelOfficeTeamPairs.
     */
    data: SalesChannelOfficeTeamPairCreateManyInput | SalesChannelOfficeTeamPairCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelOfficeTeamPairIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesChannelOfficeTeamPair update
   */
  export type SalesChannelOfficeTeamPairUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannelOfficeTeamPair
     */
    select?: SalesChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannelOfficeTeamPair
     */
    omit?: SalesChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesChannelOfficeTeamPair.
     */
    data: XOR<SalesChannelOfficeTeamPairUpdateInput, SalesChannelOfficeTeamPairUncheckedUpdateInput>
    /**
     * Choose, which SalesChannelOfficeTeamPair to update.
     */
    where: SalesChannelOfficeTeamPairWhereUniqueInput
  }

  /**
   * SalesChannelOfficeTeamPair updateMany
   */
  export type SalesChannelOfficeTeamPairUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesChannelOfficeTeamPairs.
     */
    data: XOR<SalesChannelOfficeTeamPairUpdateManyMutationInput, SalesChannelOfficeTeamPairUncheckedUpdateManyInput>
    /**
     * Filter which SalesChannelOfficeTeamPairs to update
     */
    where?: SalesChannelOfficeTeamPairWhereInput
    /**
     * Limit how many SalesChannelOfficeTeamPairs to update.
     */
    limit?: number
  }

  /**
   * SalesChannelOfficeTeamPair updateManyAndReturn
   */
  export type SalesChannelOfficeTeamPairUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannelOfficeTeamPair
     */
    select?: SalesChannelOfficeTeamPairSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannelOfficeTeamPair
     */
    omit?: SalesChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * The data used to update SalesChannelOfficeTeamPairs.
     */
    data: XOR<SalesChannelOfficeTeamPairUpdateManyMutationInput, SalesChannelOfficeTeamPairUncheckedUpdateManyInput>
    /**
     * Filter which SalesChannelOfficeTeamPairs to update
     */
    where?: SalesChannelOfficeTeamPairWhereInput
    /**
     * Limit how many SalesChannelOfficeTeamPairs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelOfficeTeamPairIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalesChannelOfficeTeamPair upsert
   */
  export type SalesChannelOfficeTeamPairUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannelOfficeTeamPair
     */
    select?: SalesChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannelOfficeTeamPair
     */
    omit?: SalesChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesChannelOfficeTeamPair to update in case it exists.
     */
    where: SalesChannelOfficeTeamPairWhereUniqueInput
    /**
     * In case the SalesChannelOfficeTeamPair found by the `where` argument doesn't exist, create a new SalesChannelOfficeTeamPair with this data.
     */
    create: XOR<SalesChannelOfficeTeamPairCreateInput, SalesChannelOfficeTeamPairUncheckedCreateInput>
    /**
     * In case the SalesChannelOfficeTeamPair was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesChannelOfficeTeamPairUpdateInput, SalesChannelOfficeTeamPairUncheckedUpdateInput>
  }

  /**
   * SalesChannelOfficeTeamPair delete
   */
  export type SalesChannelOfficeTeamPairDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannelOfficeTeamPair
     */
    select?: SalesChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannelOfficeTeamPair
     */
    omit?: SalesChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * Filter which SalesChannelOfficeTeamPair to delete.
     */
    where: SalesChannelOfficeTeamPairWhereUniqueInput
  }

  /**
   * SalesChannelOfficeTeamPair deleteMany
   */
  export type SalesChannelOfficeTeamPairDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesChannelOfficeTeamPairs to delete
     */
    where?: SalesChannelOfficeTeamPairWhereInput
    /**
     * Limit how many SalesChannelOfficeTeamPairs to delete.
     */
    limit?: number
  }

  /**
   * SalesChannelOfficeTeamPair without action
   */
  export type SalesChannelOfficeTeamPairDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesChannelOfficeTeamPair
     */
    select?: SalesChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesChannelOfficeTeamPair
     */
    omit?: SalesChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesChannelOfficeTeamPairInclude<ExtArgs> | null
  }


  /**
   * Model MarketingChannel
   */

  export type AggregateMarketingChannel = {
    _count: MarketingChannelCountAggregateOutputType | null
    _avg: MarketingChannelAvgAggregateOutputType | null
    _sum: MarketingChannelSumAggregateOutputType | null
    _min: MarketingChannelMinAggregateOutputType | null
    _max: MarketingChannelMaxAggregateOutputType | null
  }

  export type MarketingChannelAvgAggregateOutputType = {
    id: number | null
  }

  export type MarketingChannelSumAggregateOutputType = {
    id: number | null
  }

  export type MarketingChannelMinAggregateOutputType = {
    id: number | null
    marketingChannelCode: string | null
    marketingChannelName: string | null
    marketingChannelDesc: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketingChannelMaxAggregateOutputType = {
    id: number | null
    marketingChannelCode: string | null
    marketingChannelName: string | null
    marketingChannelDesc: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketingChannelCountAggregateOutputType = {
    id: number
    marketingChannelCode: number
    marketingChannelName: number
    marketingChannelDesc: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarketingChannelAvgAggregateInputType = {
    id?: true
  }

  export type MarketingChannelSumAggregateInputType = {
    id?: true
  }

  export type MarketingChannelMinAggregateInputType = {
    id?: true
    marketingChannelCode?: true
    marketingChannelName?: true
    marketingChannelDesc?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketingChannelMaxAggregateInputType = {
    id?: true
    marketingChannelCode?: true
    marketingChannelName?: true
    marketingChannelDesc?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketingChannelCountAggregateInputType = {
    id?: true
    marketingChannelCode?: true
    marketingChannelName?: true
    marketingChannelDesc?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarketingChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingChannel to aggregate.
     */
    where?: MarketingChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingChannels to fetch.
     */
    orderBy?: MarketingChannelOrderByWithRelationInput | MarketingChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketingChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketingChannels
    **/
    _count?: true | MarketingChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketingChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketingChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketingChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketingChannelMaxAggregateInputType
  }

  export type GetMarketingChannelAggregateType<T extends MarketingChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketingChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketingChannel[P]>
      : GetScalarType<T[P], AggregateMarketingChannel[P]>
  }




  export type MarketingChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketingChannelWhereInput
    orderBy?: MarketingChannelOrderByWithAggregationInput | MarketingChannelOrderByWithAggregationInput[]
    by: MarketingChannelScalarFieldEnum[] | MarketingChannelScalarFieldEnum
    having?: MarketingChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketingChannelCountAggregateInputType | true
    _avg?: MarketingChannelAvgAggregateInputType
    _sum?: MarketingChannelSumAggregateInputType
    _min?: MarketingChannelMinAggregateInputType
    _max?: MarketingChannelMaxAggregateInputType
  }

  export type MarketingChannelGroupByOutputType = {
    id: number
    marketingChannelCode: string
    marketingChannelName: string
    marketingChannelDesc: string | null
    createdAt: Date
    updatedAt: Date
    _count: MarketingChannelCountAggregateOutputType | null
    _avg: MarketingChannelAvgAggregateOutputType | null
    _sum: MarketingChannelSumAggregateOutputType | null
    _min: MarketingChannelMinAggregateOutputType | null
    _max: MarketingChannelMaxAggregateOutputType | null
  }

  type GetMarketingChannelGroupByPayload<T extends MarketingChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketingChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketingChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketingChannelGroupByOutputType[P]>
            : GetScalarType<T[P], MarketingChannelGroupByOutputType[P]>
        }
      >
    >


  export type MarketingChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketingChannelCode?: boolean
    marketingChannelName?: boolean
    marketingChannelDesc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    channelOfficePairs?: boolean | MarketingChannel$channelOfficePairsArgs<ExtArgs>
    businessUnitMarketingPairs?: boolean | MarketingChannel$businessUnitMarketingPairsArgs<ExtArgs>
    _count?: boolean | MarketingChannelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketingChannel"]>

  export type MarketingChannelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketingChannelCode?: boolean
    marketingChannelName?: boolean
    marketingChannelDesc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketingChannel"]>

  export type MarketingChannelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketingChannelCode?: boolean
    marketingChannelName?: boolean
    marketingChannelDesc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketingChannel"]>

  export type MarketingChannelSelectScalar = {
    id?: boolean
    marketingChannelCode?: boolean
    marketingChannelName?: boolean
    marketingChannelDesc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MarketingChannelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "marketingChannelCode" | "marketingChannelName" | "marketingChannelDesc" | "createdAt" | "updatedAt", ExtArgs["result"]["marketingChannel"]>
  export type MarketingChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channelOfficePairs?: boolean | MarketingChannel$channelOfficePairsArgs<ExtArgs>
    businessUnitMarketingPairs?: boolean | MarketingChannel$businessUnitMarketingPairsArgs<ExtArgs>
    _count?: boolean | MarketingChannelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MarketingChannelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MarketingChannelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MarketingChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketingChannel"
    objects: {
      channelOfficePairs: Prisma.$MarketingChannelOfficeTeamPairPayload<ExtArgs>[]
      businessUnitMarketingPairs: Prisma.$BusinessUnitMarketingPairPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      marketingChannelCode: string
      marketingChannelName: string
      marketingChannelDesc: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["marketingChannel"]>
    composites: {}
  }

  type MarketingChannelGetPayload<S extends boolean | null | undefined | MarketingChannelDefaultArgs> = $Result.GetResult<Prisma.$MarketingChannelPayload, S>

  type MarketingChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketingChannelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketingChannelCountAggregateInputType | true
    }

  export interface MarketingChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketingChannel'], meta: { name: 'MarketingChannel' } }
    /**
     * Find zero or one MarketingChannel that matches the filter.
     * @param {MarketingChannelFindUniqueArgs} args - Arguments to find a MarketingChannel
     * @example
     * // Get one MarketingChannel
     * const marketingChannel = await prisma.marketingChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketingChannelFindUniqueArgs>(args: SelectSubset<T, MarketingChannelFindUniqueArgs<ExtArgs>>): Prisma__MarketingChannelClient<$Result.GetResult<Prisma.$MarketingChannelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketingChannel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketingChannelFindUniqueOrThrowArgs} args - Arguments to find a MarketingChannel
     * @example
     * // Get one MarketingChannel
     * const marketingChannel = await prisma.marketingChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketingChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketingChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketingChannelClient<$Result.GetResult<Prisma.$MarketingChannelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketingChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingChannelFindFirstArgs} args - Arguments to find a MarketingChannel
     * @example
     * // Get one MarketingChannel
     * const marketingChannel = await prisma.marketingChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketingChannelFindFirstArgs>(args?: SelectSubset<T, MarketingChannelFindFirstArgs<ExtArgs>>): Prisma__MarketingChannelClient<$Result.GetResult<Prisma.$MarketingChannelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketingChannel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingChannelFindFirstOrThrowArgs} args - Arguments to find a MarketingChannel
     * @example
     * // Get one MarketingChannel
     * const marketingChannel = await prisma.marketingChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketingChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketingChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketingChannelClient<$Result.GetResult<Prisma.$MarketingChannelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketingChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketingChannels
     * const marketingChannels = await prisma.marketingChannel.findMany()
     * 
     * // Get first 10 MarketingChannels
     * const marketingChannels = await prisma.marketingChannel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketingChannelWithIdOnly = await prisma.marketingChannel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketingChannelFindManyArgs>(args?: SelectSubset<T, MarketingChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingChannelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketingChannel.
     * @param {MarketingChannelCreateArgs} args - Arguments to create a MarketingChannel.
     * @example
     * // Create one MarketingChannel
     * const MarketingChannel = await prisma.marketingChannel.create({
     *   data: {
     *     // ... data to create a MarketingChannel
     *   }
     * })
     * 
     */
    create<T extends MarketingChannelCreateArgs>(args: SelectSubset<T, MarketingChannelCreateArgs<ExtArgs>>): Prisma__MarketingChannelClient<$Result.GetResult<Prisma.$MarketingChannelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketingChannels.
     * @param {MarketingChannelCreateManyArgs} args - Arguments to create many MarketingChannels.
     * @example
     * // Create many MarketingChannels
     * const marketingChannel = await prisma.marketingChannel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketingChannelCreateManyArgs>(args?: SelectSubset<T, MarketingChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketingChannels and returns the data saved in the database.
     * @param {MarketingChannelCreateManyAndReturnArgs} args - Arguments to create many MarketingChannels.
     * @example
     * // Create many MarketingChannels
     * const marketingChannel = await prisma.marketingChannel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketingChannels and only return the `id`
     * const marketingChannelWithIdOnly = await prisma.marketingChannel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketingChannelCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketingChannelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingChannelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MarketingChannel.
     * @param {MarketingChannelDeleteArgs} args - Arguments to delete one MarketingChannel.
     * @example
     * // Delete one MarketingChannel
     * const MarketingChannel = await prisma.marketingChannel.delete({
     *   where: {
     *     // ... filter to delete one MarketingChannel
     *   }
     * })
     * 
     */
    delete<T extends MarketingChannelDeleteArgs>(args: SelectSubset<T, MarketingChannelDeleteArgs<ExtArgs>>): Prisma__MarketingChannelClient<$Result.GetResult<Prisma.$MarketingChannelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketingChannel.
     * @param {MarketingChannelUpdateArgs} args - Arguments to update one MarketingChannel.
     * @example
     * // Update one MarketingChannel
     * const marketingChannel = await prisma.marketingChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketingChannelUpdateArgs>(args: SelectSubset<T, MarketingChannelUpdateArgs<ExtArgs>>): Prisma__MarketingChannelClient<$Result.GetResult<Prisma.$MarketingChannelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketingChannels.
     * @param {MarketingChannelDeleteManyArgs} args - Arguments to filter MarketingChannels to delete.
     * @example
     * // Delete a few MarketingChannels
     * const { count } = await prisma.marketingChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketingChannelDeleteManyArgs>(args?: SelectSubset<T, MarketingChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketingChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketingChannels
     * const marketingChannel = await prisma.marketingChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketingChannelUpdateManyArgs>(args: SelectSubset<T, MarketingChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketingChannels and returns the data updated in the database.
     * @param {MarketingChannelUpdateManyAndReturnArgs} args - Arguments to update many MarketingChannels.
     * @example
     * // Update many MarketingChannels
     * const marketingChannel = await prisma.marketingChannel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MarketingChannels and only return the `id`
     * const marketingChannelWithIdOnly = await prisma.marketingChannel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MarketingChannelUpdateManyAndReturnArgs>(args: SelectSubset<T, MarketingChannelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingChannelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MarketingChannel.
     * @param {MarketingChannelUpsertArgs} args - Arguments to update or create a MarketingChannel.
     * @example
     * // Update or create a MarketingChannel
     * const marketingChannel = await prisma.marketingChannel.upsert({
     *   create: {
     *     // ... data to create a MarketingChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketingChannel we want to update
     *   }
     * })
     */
    upsert<T extends MarketingChannelUpsertArgs>(args: SelectSubset<T, MarketingChannelUpsertArgs<ExtArgs>>): Prisma__MarketingChannelClient<$Result.GetResult<Prisma.$MarketingChannelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MarketingChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingChannelCountArgs} args - Arguments to filter MarketingChannels to count.
     * @example
     * // Count the number of MarketingChannels
     * const count = await prisma.marketingChannel.count({
     *   where: {
     *     // ... the filter for the MarketingChannels we want to count
     *   }
     * })
    **/
    count<T extends MarketingChannelCountArgs>(
      args?: Subset<T, MarketingChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketingChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketingChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketingChannelAggregateArgs>(args: Subset<T, MarketingChannelAggregateArgs>): Prisma.PrismaPromise<GetMarketingChannelAggregateType<T>>

    /**
     * Group by MarketingChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketingChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketingChannelGroupByArgs['orderBy'] }
        : { orderBy?: MarketingChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketingChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketingChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketingChannel model
   */
  readonly fields: MarketingChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketingChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketingChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channelOfficePairs<T extends MarketingChannel$channelOfficePairsArgs<ExtArgs> = {}>(args?: Subset<T, MarketingChannel$channelOfficePairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingChannelOfficeTeamPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    businessUnitMarketingPairs<T extends MarketingChannel$businessUnitMarketingPairsArgs<ExtArgs> = {}>(args?: Subset<T, MarketingChannel$businessUnitMarketingPairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitMarketingPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketingChannel model
   */
  interface MarketingChannelFieldRefs {
    readonly id: FieldRef<"MarketingChannel", 'Int'>
    readonly marketingChannelCode: FieldRef<"MarketingChannel", 'String'>
    readonly marketingChannelName: FieldRef<"MarketingChannel", 'String'>
    readonly marketingChannelDesc: FieldRef<"MarketingChannel", 'String'>
    readonly createdAt: FieldRef<"MarketingChannel", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketingChannel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketingChannel findUnique
   */
  export type MarketingChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannel
     */
    select?: MarketingChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannel
     */
    omit?: MarketingChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelInclude<ExtArgs> | null
    /**
     * Filter, which MarketingChannel to fetch.
     */
    where: MarketingChannelWhereUniqueInput
  }

  /**
   * MarketingChannel findUniqueOrThrow
   */
  export type MarketingChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannel
     */
    select?: MarketingChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannel
     */
    omit?: MarketingChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelInclude<ExtArgs> | null
    /**
     * Filter, which MarketingChannel to fetch.
     */
    where: MarketingChannelWhereUniqueInput
  }

  /**
   * MarketingChannel findFirst
   */
  export type MarketingChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannel
     */
    select?: MarketingChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannel
     */
    omit?: MarketingChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelInclude<ExtArgs> | null
    /**
     * Filter, which MarketingChannel to fetch.
     */
    where?: MarketingChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingChannels to fetch.
     */
    orderBy?: MarketingChannelOrderByWithRelationInput | MarketingChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingChannels.
     */
    cursor?: MarketingChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingChannels.
     */
    distinct?: MarketingChannelScalarFieldEnum | MarketingChannelScalarFieldEnum[]
  }

  /**
   * MarketingChannel findFirstOrThrow
   */
  export type MarketingChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannel
     */
    select?: MarketingChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannel
     */
    omit?: MarketingChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelInclude<ExtArgs> | null
    /**
     * Filter, which MarketingChannel to fetch.
     */
    where?: MarketingChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingChannels to fetch.
     */
    orderBy?: MarketingChannelOrderByWithRelationInput | MarketingChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingChannels.
     */
    cursor?: MarketingChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingChannels.
     */
    distinct?: MarketingChannelScalarFieldEnum | MarketingChannelScalarFieldEnum[]
  }

  /**
   * MarketingChannel findMany
   */
  export type MarketingChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannel
     */
    select?: MarketingChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannel
     */
    omit?: MarketingChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelInclude<ExtArgs> | null
    /**
     * Filter, which MarketingChannels to fetch.
     */
    where?: MarketingChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingChannels to fetch.
     */
    orderBy?: MarketingChannelOrderByWithRelationInput | MarketingChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketingChannels.
     */
    cursor?: MarketingChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingChannels.
     */
    skip?: number
    distinct?: MarketingChannelScalarFieldEnum | MarketingChannelScalarFieldEnum[]
  }

  /**
   * MarketingChannel create
   */
  export type MarketingChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannel
     */
    select?: MarketingChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannel
     */
    omit?: MarketingChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketingChannel.
     */
    data: XOR<MarketingChannelCreateInput, MarketingChannelUncheckedCreateInput>
  }

  /**
   * MarketingChannel createMany
   */
  export type MarketingChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketingChannels.
     */
    data: MarketingChannelCreateManyInput | MarketingChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketingChannel createManyAndReturn
   */
  export type MarketingChannelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannel
     */
    select?: MarketingChannelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannel
     */
    omit?: MarketingChannelOmit<ExtArgs> | null
    /**
     * The data used to create many MarketingChannels.
     */
    data: MarketingChannelCreateManyInput | MarketingChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketingChannel update
   */
  export type MarketingChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannel
     */
    select?: MarketingChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannel
     */
    omit?: MarketingChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketingChannel.
     */
    data: XOR<MarketingChannelUpdateInput, MarketingChannelUncheckedUpdateInput>
    /**
     * Choose, which MarketingChannel to update.
     */
    where: MarketingChannelWhereUniqueInput
  }

  /**
   * MarketingChannel updateMany
   */
  export type MarketingChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketingChannels.
     */
    data: XOR<MarketingChannelUpdateManyMutationInput, MarketingChannelUncheckedUpdateManyInput>
    /**
     * Filter which MarketingChannels to update
     */
    where?: MarketingChannelWhereInput
    /**
     * Limit how many MarketingChannels to update.
     */
    limit?: number
  }

  /**
   * MarketingChannel updateManyAndReturn
   */
  export type MarketingChannelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannel
     */
    select?: MarketingChannelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannel
     */
    omit?: MarketingChannelOmit<ExtArgs> | null
    /**
     * The data used to update MarketingChannels.
     */
    data: XOR<MarketingChannelUpdateManyMutationInput, MarketingChannelUncheckedUpdateManyInput>
    /**
     * Filter which MarketingChannels to update
     */
    where?: MarketingChannelWhereInput
    /**
     * Limit how many MarketingChannels to update.
     */
    limit?: number
  }

  /**
   * MarketingChannel upsert
   */
  export type MarketingChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannel
     */
    select?: MarketingChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannel
     */
    omit?: MarketingChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketingChannel to update in case it exists.
     */
    where: MarketingChannelWhereUniqueInput
    /**
     * In case the MarketingChannel found by the `where` argument doesn't exist, create a new MarketingChannel with this data.
     */
    create: XOR<MarketingChannelCreateInput, MarketingChannelUncheckedCreateInput>
    /**
     * In case the MarketingChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketingChannelUpdateInput, MarketingChannelUncheckedUpdateInput>
  }

  /**
   * MarketingChannel delete
   */
  export type MarketingChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannel
     */
    select?: MarketingChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannel
     */
    omit?: MarketingChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelInclude<ExtArgs> | null
    /**
     * Filter which MarketingChannel to delete.
     */
    where: MarketingChannelWhereUniqueInput
  }

  /**
   * MarketingChannel deleteMany
   */
  export type MarketingChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingChannels to delete
     */
    where?: MarketingChannelWhereInput
    /**
     * Limit how many MarketingChannels to delete.
     */
    limit?: number
  }

  /**
   * MarketingChannel.channelOfficePairs
   */
  export type MarketingChannel$channelOfficePairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannelOfficeTeamPair
     */
    select?: MarketingChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannelOfficeTeamPair
     */
    omit?: MarketingChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelOfficeTeamPairInclude<ExtArgs> | null
    where?: MarketingChannelOfficeTeamPairWhereInput
    orderBy?: MarketingChannelOfficeTeamPairOrderByWithRelationInput | MarketingChannelOfficeTeamPairOrderByWithRelationInput[]
    cursor?: MarketingChannelOfficeTeamPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketingChannelOfficeTeamPairScalarFieldEnum | MarketingChannelOfficeTeamPairScalarFieldEnum[]
  }

  /**
   * MarketingChannel.businessUnitMarketingPairs
   */
  export type MarketingChannel$businessUnitMarketingPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitMarketingPair
     */
    select?: BusinessUnitMarketingPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitMarketingPair
     */
    omit?: BusinessUnitMarketingPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitMarketingPairInclude<ExtArgs> | null
    where?: BusinessUnitMarketingPairWhereInput
    orderBy?: BusinessUnitMarketingPairOrderByWithRelationInput | BusinessUnitMarketingPairOrderByWithRelationInput[]
    cursor?: BusinessUnitMarketingPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessUnitMarketingPairScalarFieldEnum | BusinessUnitMarketingPairScalarFieldEnum[]
  }

  /**
   * MarketingChannel without action
   */
  export type MarketingChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannel
     */
    select?: MarketingChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannel
     */
    omit?: MarketingChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelInclude<ExtArgs> | null
  }


  /**
   * Model MarketingOffice
   */

  export type AggregateMarketingOffice = {
    _count: MarketingOfficeCountAggregateOutputType | null
    _avg: MarketingOfficeAvgAggregateOutputType | null
    _sum: MarketingOfficeSumAggregateOutputType | null
    _min: MarketingOfficeMinAggregateOutputType | null
    _max: MarketingOfficeMaxAggregateOutputType | null
  }

  export type MarketingOfficeAvgAggregateOutputType = {
    id: number | null
  }

  export type MarketingOfficeSumAggregateOutputType = {
    id: number | null
  }

  export type MarketingOfficeMinAggregateOutputType = {
    id: number | null
    marketingOfficeId: string | null
    organizationName: string | null
    marketingOfficeDesc: string | null
    street1: string | null
    street2: string | null
    city: string | null
    state: string | null
    region: string | null
    country: string | null
    pinCode: string | null
    validFrom: Date | null
    validTo: Date | null
    company: string | null
    parentUnit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketingOfficeMaxAggregateOutputType = {
    id: number | null
    marketingOfficeId: string | null
    organizationName: string | null
    marketingOfficeDesc: string | null
    street1: string | null
    street2: string | null
    city: string | null
    state: string | null
    region: string | null
    country: string | null
    pinCode: string | null
    validFrom: Date | null
    validTo: Date | null
    company: string | null
    parentUnit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketingOfficeCountAggregateOutputType = {
    id: number
    marketingOfficeId: number
    organizationName: number
    marketingOfficeDesc: number
    street1: number
    street2: number
    city: number
    state: number
    region: number
    country: number
    pinCode: number
    validFrom: number
    validTo: number
    company: number
    parentUnit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarketingOfficeAvgAggregateInputType = {
    id?: true
  }

  export type MarketingOfficeSumAggregateInputType = {
    id?: true
  }

  export type MarketingOfficeMinAggregateInputType = {
    id?: true
    marketingOfficeId?: true
    organizationName?: true
    marketingOfficeDesc?: true
    street1?: true
    street2?: true
    city?: true
    state?: true
    region?: true
    country?: true
    pinCode?: true
    validFrom?: true
    validTo?: true
    company?: true
    parentUnit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketingOfficeMaxAggregateInputType = {
    id?: true
    marketingOfficeId?: true
    organizationName?: true
    marketingOfficeDesc?: true
    street1?: true
    street2?: true
    city?: true
    state?: true
    region?: true
    country?: true
    pinCode?: true
    validFrom?: true
    validTo?: true
    company?: true
    parentUnit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketingOfficeCountAggregateInputType = {
    id?: true
    marketingOfficeId?: true
    organizationName?: true
    marketingOfficeDesc?: true
    street1?: true
    street2?: true
    city?: true
    state?: true
    region?: true
    country?: true
    pinCode?: true
    validFrom?: true
    validTo?: true
    company?: true
    parentUnit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarketingOfficeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingOffice to aggregate.
     */
    where?: MarketingOfficeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingOffices to fetch.
     */
    orderBy?: MarketingOfficeOrderByWithRelationInput | MarketingOfficeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketingOfficeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingOffices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingOffices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketingOffices
    **/
    _count?: true | MarketingOfficeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketingOfficeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketingOfficeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketingOfficeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketingOfficeMaxAggregateInputType
  }

  export type GetMarketingOfficeAggregateType<T extends MarketingOfficeAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketingOffice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketingOffice[P]>
      : GetScalarType<T[P], AggregateMarketingOffice[P]>
  }




  export type MarketingOfficeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketingOfficeWhereInput
    orderBy?: MarketingOfficeOrderByWithAggregationInput | MarketingOfficeOrderByWithAggregationInput[]
    by: MarketingOfficeScalarFieldEnum[] | MarketingOfficeScalarFieldEnum
    having?: MarketingOfficeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketingOfficeCountAggregateInputType | true
    _avg?: MarketingOfficeAvgAggregateInputType
    _sum?: MarketingOfficeSumAggregateInputType
    _min?: MarketingOfficeMinAggregateInputType
    _max?: MarketingOfficeMaxAggregateInputType
  }

  export type MarketingOfficeGroupByOutputType = {
    id: number
    marketingOfficeId: string
    organizationName: string
    marketingOfficeDesc: string | null
    street1: string
    street2: string | null
    city: string
    state: string
    region: string | null
    country: string
    pinCode: string
    validFrom: Date
    validTo: Date
    company: string
    parentUnit: string | null
    createdAt: Date
    updatedAt: Date
    _count: MarketingOfficeCountAggregateOutputType | null
    _avg: MarketingOfficeAvgAggregateOutputType | null
    _sum: MarketingOfficeSumAggregateOutputType | null
    _min: MarketingOfficeMinAggregateOutputType | null
    _max: MarketingOfficeMaxAggregateOutputType | null
  }

  type GetMarketingOfficeGroupByPayload<T extends MarketingOfficeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketingOfficeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketingOfficeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketingOfficeGroupByOutputType[P]>
            : GetScalarType<T[P], MarketingOfficeGroupByOutputType[P]>
        }
      >
    >


  export type MarketingOfficeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketingOfficeId?: boolean
    organizationName?: boolean
    marketingOfficeDesc?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    region?: boolean
    country?: boolean
    pinCode?: boolean
    validFrom?: boolean
    validTo?: boolean
    company?: boolean
    parentUnit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeTeamPairs?: boolean | MarketingOffice$officeTeamPairsArgs<ExtArgs>
    businessUnitMarketingPairs?: boolean | MarketingOffice$businessUnitMarketingPairsArgs<ExtArgs>
    _count?: boolean | MarketingOfficeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketingOffice"]>

  export type MarketingOfficeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketingOfficeId?: boolean
    organizationName?: boolean
    marketingOfficeDesc?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    region?: boolean
    country?: boolean
    pinCode?: boolean
    validFrom?: boolean
    validTo?: boolean
    company?: boolean
    parentUnit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketingOffice"]>

  export type MarketingOfficeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketingOfficeId?: boolean
    organizationName?: boolean
    marketingOfficeDesc?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    region?: boolean
    country?: boolean
    pinCode?: boolean
    validFrom?: boolean
    validTo?: boolean
    company?: boolean
    parentUnit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketingOffice"]>

  export type MarketingOfficeSelectScalar = {
    id?: boolean
    marketingOfficeId?: boolean
    organizationName?: boolean
    marketingOfficeDesc?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    region?: boolean
    country?: boolean
    pinCode?: boolean
    validFrom?: boolean
    validTo?: boolean
    company?: boolean
    parentUnit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MarketingOfficeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "marketingOfficeId" | "organizationName" | "marketingOfficeDesc" | "street1" | "street2" | "city" | "state" | "region" | "country" | "pinCode" | "validFrom" | "validTo" | "company" | "parentUnit" | "createdAt" | "updatedAt", ExtArgs["result"]["marketingOffice"]>
  export type MarketingOfficeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    officeTeamPairs?: boolean | MarketingOffice$officeTeamPairsArgs<ExtArgs>
    businessUnitMarketingPairs?: boolean | MarketingOffice$businessUnitMarketingPairsArgs<ExtArgs>
    _count?: boolean | MarketingOfficeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MarketingOfficeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MarketingOfficeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MarketingOfficePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketingOffice"
    objects: {
      officeTeamPairs: Prisma.$MarketingChannelOfficeTeamPairPayload<ExtArgs>[]
      businessUnitMarketingPairs: Prisma.$BusinessUnitMarketingPairPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      marketingOfficeId: string
      organizationName: string
      marketingOfficeDesc: string | null
      street1: string
      street2: string | null
      city: string
      state: string
      region: string | null
      country: string
      pinCode: string
      validFrom: Date
      validTo: Date
      company: string
      parentUnit: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["marketingOffice"]>
    composites: {}
  }

  type MarketingOfficeGetPayload<S extends boolean | null | undefined | MarketingOfficeDefaultArgs> = $Result.GetResult<Prisma.$MarketingOfficePayload, S>

  type MarketingOfficeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketingOfficeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketingOfficeCountAggregateInputType | true
    }

  export interface MarketingOfficeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketingOffice'], meta: { name: 'MarketingOffice' } }
    /**
     * Find zero or one MarketingOffice that matches the filter.
     * @param {MarketingOfficeFindUniqueArgs} args - Arguments to find a MarketingOffice
     * @example
     * // Get one MarketingOffice
     * const marketingOffice = await prisma.marketingOffice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketingOfficeFindUniqueArgs>(args: SelectSubset<T, MarketingOfficeFindUniqueArgs<ExtArgs>>): Prisma__MarketingOfficeClient<$Result.GetResult<Prisma.$MarketingOfficePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketingOffice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketingOfficeFindUniqueOrThrowArgs} args - Arguments to find a MarketingOffice
     * @example
     * // Get one MarketingOffice
     * const marketingOffice = await prisma.marketingOffice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketingOfficeFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketingOfficeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketingOfficeClient<$Result.GetResult<Prisma.$MarketingOfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketingOffice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingOfficeFindFirstArgs} args - Arguments to find a MarketingOffice
     * @example
     * // Get one MarketingOffice
     * const marketingOffice = await prisma.marketingOffice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketingOfficeFindFirstArgs>(args?: SelectSubset<T, MarketingOfficeFindFirstArgs<ExtArgs>>): Prisma__MarketingOfficeClient<$Result.GetResult<Prisma.$MarketingOfficePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketingOffice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingOfficeFindFirstOrThrowArgs} args - Arguments to find a MarketingOffice
     * @example
     * // Get one MarketingOffice
     * const marketingOffice = await prisma.marketingOffice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketingOfficeFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketingOfficeFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketingOfficeClient<$Result.GetResult<Prisma.$MarketingOfficePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketingOffices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingOfficeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketingOffices
     * const marketingOffices = await prisma.marketingOffice.findMany()
     * 
     * // Get first 10 MarketingOffices
     * const marketingOffices = await prisma.marketingOffice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketingOfficeWithIdOnly = await prisma.marketingOffice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketingOfficeFindManyArgs>(args?: SelectSubset<T, MarketingOfficeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingOfficePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketingOffice.
     * @param {MarketingOfficeCreateArgs} args - Arguments to create a MarketingOffice.
     * @example
     * // Create one MarketingOffice
     * const MarketingOffice = await prisma.marketingOffice.create({
     *   data: {
     *     // ... data to create a MarketingOffice
     *   }
     * })
     * 
     */
    create<T extends MarketingOfficeCreateArgs>(args: SelectSubset<T, MarketingOfficeCreateArgs<ExtArgs>>): Prisma__MarketingOfficeClient<$Result.GetResult<Prisma.$MarketingOfficePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketingOffices.
     * @param {MarketingOfficeCreateManyArgs} args - Arguments to create many MarketingOffices.
     * @example
     * // Create many MarketingOffices
     * const marketingOffice = await prisma.marketingOffice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketingOfficeCreateManyArgs>(args?: SelectSubset<T, MarketingOfficeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketingOffices and returns the data saved in the database.
     * @param {MarketingOfficeCreateManyAndReturnArgs} args - Arguments to create many MarketingOffices.
     * @example
     * // Create many MarketingOffices
     * const marketingOffice = await prisma.marketingOffice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketingOffices and only return the `id`
     * const marketingOfficeWithIdOnly = await prisma.marketingOffice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketingOfficeCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketingOfficeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingOfficePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MarketingOffice.
     * @param {MarketingOfficeDeleteArgs} args - Arguments to delete one MarketingOffice.
     * @example
     * // Delete one MarketingOffice
     * const MarketingOffice = await prisma.marketingOffice.delete({
     *   where: {
     *     // ... filter to delete one MarketingOffice
     *   }
     * })
     * 
     */
    delete<T extends MarketingOfficeDeleteArgs>(args: SelectSubset<T, MarketingOfficeDeleteArgs<ExtArgs>>): Prisma__MarketingOfficeClient<$Result.GetResult<Prisma.$MarketingOfficePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketingOffice.
     * @param {MarketingOfficeUpdateArgs} args - Arguments to update one MarketingOffice.
     * @example
     * // Update one MarketingOffice
     * const marketingOffice = await prisma.marketingOffice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketingOfficeUpdateArgs>(args: SelectSubset<T, MarketingOfficeUpdateArgs<ExtArgs>>): Prisma__MarketingOfficeClient<$Result.GetResult<Prisma.$MarketingOfficePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketingOffices.
     * @param {MarketingOfficeDeleteManyArgs} args - Arguments to filter MarketingOffices to delete.
     * @example
     * // Delete a few MarketingOffices
     * const { count } = await prisma.marketingOffice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketingOfficeDeleteManyArgs>(args?: SelectSubset<T, MarketingOfficeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketingOffices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingOfficeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketingOffices
     * const marketingOffice = await prisma.marketingOffice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketingOfficeUpdateManyArgs>(args: SelectSubset<T, MarketingOfficeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketingOffices and returns the data updated in the database.
     * @param {MarketingOfficeUpdateManyAndReturnArgs} args - Arguments to update many MarketingOffices.
     * @example
     * // Update many MarketingOffices
     * const marketingOffice = await prisma.marketingOffice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MarketingOffices and only return the `id`
     * const marketingOfficeWithIdOnly = await prisma.marketingOffice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MarketingOfficeUpdateManyAndReturnArgs>(args: SelectSubset<T, MarketingOfficeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingOfficePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MarketingOffice.
     * @param {MarketingOfficeUpsertArgs} args - Arguments to update or create a MarketingOffice.
     * @example
     * // Update or create a MarketingOffice
     * const marketingOffice = await prisma.marketingOffice.upsert({
     *   create: {
     *     // ... data to create a MarketingOffice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketingOffice we want to update
     *   }
     * })
     */
    upsert<T extends MarketingOfficeUpsertArgs>(args: SelectSubset<T, MarketingOfficeUpsertArgs<ExtArgs>>): Prisma__MarketingOfficeClient<$Result.GetResult<Prisma.$MarketingOfficePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MarketingOffices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingOfficeCountArgs} args - Arguments to filter MarketingOffices to count.
     * @example
     * // Count the number of MarketingOffices
     * const count = await prisma.marketingOffice.count({
     *   where: {
     *     // ... the filter for the MarketingOffices we want to count
     *   }
     * })
    **/
    count<T extends MarketingOfficeCountArgs>(
      args?: Subset<T, MarketingOfficeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketingOfficeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketingOffice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingOfficeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketingOfficeAggregateArgs>(args: Subset<T, MarketingOfficeAggregateArgs>): Prisma.PrismaPromise<GetMarketingOfficeAggregateType<T>>

    /**
     * Group by MarketingOffice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingOfficeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketingOfficeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketingOfficeGroupByArgs['orderBy'] }
        : { orderBy?: MarketingOfficeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketingOfficeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketingOfficeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketingOffice model
   */
  readonly fields: MarketingOfficeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketingOffice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketingOfficeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    officeTeamPairs<T extends MarketingOffice$officeTeamPairsArgs<ExtArgs> = {}>(args?: Subset<T, MarketingOffice$officeTeamPairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingChannelOfficeTeamPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    businessUnitMarketingPairs<T extends MarketingOffice$businessUnitMarketingPairsArgs<ExtArgs> = {}>(args?: Subset<T, MarketingOffice$businessUnitMarketingPairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitMarketingPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketingOffice model
   */
  interface MarketingOfficeFieldRefs {
    readonly id: FieldRef<"MarketingOffice", 'Int'>
    readonly marketingOfficeId: FieldRef<"MarketingOffice", 'String'>
    readonly organizationName: FieldRef<"MarketingOffice", 'String'>
    readonly marketingOfficeDesc: FieldRef<"MarketingOffice", 'String'>
    readonly street1: FieldRef<"MarketingOffice", 'String'>
    readonly street2: FieldRef<"MarketingOffice", 'String'>
    readonly city: FieldRef<"MarketingOffice", 'String'>
    readonly state: FieldRef<"MarketingOffice", 'String'>
    readonly region: FieldRef<"MarketingOffice", 'String'>
    readonly country: FieldRef<"MarketingOffice", 'String'>
    readonly pinCode: FieldRef<"MarketingOffice", 'String'>
    readonly validFrom: FieldRef<"MarketingOffice", 'DateTime'>
    readonly validTo: FieldRef<"MarketingOffice", 'DateTime'>
    readonly company: FieldRef<"MarketingOffice", 'String'>
    readonly parentUnit: FieldRef<"MarketingOffice", 'String'>
    readonly createdAt: FieldRef<"MarketingOffice", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketingOffice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketingOffice findUnique
   */
  export type MarketingOfficeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingOffice
     */
    select?: MarketingOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingOffice
     */
    omit?: MarketingOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingOfficeInclude<ExtArgs> | null
    /**
     * Filter, which MarketingOffice to fetch.
     */
    where: MarketingOfficeWhereUniqueInput
  }

  /**
   * MarketingOffice findUniqueOrThrow
   */
  export type MarketingOfficeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingOffice
     */
    select?: MarketingOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingOffice
     */
    omit?: MarketingOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingOfficeInclude<ExtArgs> | null
    /**
     * Filter, which MarketingOffice to fetch.
     */
    where: MarketingOfficeWhereUniqueInput
  }

  /**
   * MarketingOffice findFirst
   */
  export type MarketingOfficeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingOffice
     */
    select?: MarketingOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingOffice
     */
    omit?: MarketingOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingOfficeInclude<ExtArgs> | null
    /**
     * Filter, which MarketingOffice to fetch.
     */
    where?: MarketingOfficeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingOffices to fetch.
     */
    orderBy?: MarketingOfficeOrderByWithRelationInput | MarketingOfficeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingOffices.
     */
    cursor?: MarketingOfficeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingOffices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingOffices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingOffices.
     */
    distinct?: MarketingOfficeScalarFieldEnum | MarketingOfficeScalarFieldEnum[]
  }

  /**
   * MarketingOffice findFirstOrThrow
   */
  export type MarketingOfficeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingOffice
     */
    select?: MarketingOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingOffice
     */
    omit?: MarketingOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingOfficeInclude<ExtArgs> | null
    /**
     * Filter, which MarketingOffice to fetch.
     */
    where?: MarketingOfficeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingOffices to fetch.
     */
    orderBy?: MarketingOfficeOrderByWithRelationInput | MarketingOfficeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingOffices.
     */
    cursor?: MarketingOfficeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingOffices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingOffices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingOffices.
     */
    distinct?: MarketingOfficeScalarFieldEnum | MarketingOfficeScalarFieldEnum[]
  }

  /**
   * MarketingOffice findMany
   */
  export type MarketingOfficeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingOffice
     */
    select?: MarketingOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingOffice
     */
    omit?: MarketingOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingOfficeInclude<ExtArgs> | null
    /**
     * Filter, which MarketingOffices to fetch.
     */
    where?: MarketingOfficeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingOffices to fetch.
     */
    orderBy?: MarketingOfficeOrderByWithRelationInput | MarketingOfficeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketingOffices.
     */
    cursor?: MarketingOfficeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingOffices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingOffices.
     */
    skip?: number
    distinct?: MarketingOfficeScalarFieldEnum | MarketingOfficeScalarFieldEnum[]
  }

  /**
   * MarketingOffice create
   */
  export type MarketingOfficeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingOffice
     */
    select?: MarketingOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingOffice
     */
    omit?: MarketingOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingOfficeInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketingOffice.
     */
    data: XOR<MarketingOfficeCreateInput, MarketingOfficeUncheckedCreateInput>
  }

  /**
   * MarketingOffice createMany
   */
  export type MarketingOfficeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketingOffices.
     */
    data: MarketingOfficeCreateManyInput | MarketingOfficeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketingOffice createManyAndReturn
   */
  export type MarketingOfficeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingOffice
     */
    select?: MarketingOfficeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingOffice
     */
    omit?: MarketingOfficeOmit<ExtArgs> | null
    /**
     * The data used to create many MarketingOffices.
     */
    data: MarketingOfficeCreateManyInput | MarketingOfficeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketingOffice update
   */
  export type MarketingOfficeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingOffice
     */
    select?: MarketingOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingOffice
     */
    omit?: MarketingOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingOfficeInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketingOffice.
     */
    data: XOR<MarketingOfficeUpdateInput, MarketingOfficeUncheckedUpdateInput>
    /**
     * Choose, which MarketingOffice to update.
     */
    where: MarketingOfficeWhereUniqueInput
  }

  /**
   * MarketingOffice updateMany
   */
  export type MarketingOfficeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketingOffices.
     */
    data: XOR<MarketingOfficeUpdateManyMutationInput, MarketingOfficeUncheckedUpdateManyInput>
    /**
     * Filter which MarketingOffices to update
     */
    where?: MarketingOfficeWhereInput
    /**
     * Limit how many MarketingOffices to update.
     */
    limit?: number
  }

  /**
   * MarketingOffice updateManyAndReturn
   */
  export type MarketingOfficeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingOffice
     */
    select?: MarketingOfficeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingOffice
     */
    omit?: MarketingOfficeOmit<ExtArgs> | null
    /**
     * The data used to update MarketingOffices.
     */
    data: XOR<MarketingOfficeUpdateManyMutationInput, MarketingOfficeUncheckedUpdateManyInput>
    /**
     * Filter which MarketingOffices to update
     */
    where?: MarketingOfficeWhereInput
    /**
     * Limit how many MarketingOffices to update.
     */
    limit?: number
  }

  /**
   * MarketingOffice upsert
   */
  export type MarketingOfficeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingOffice
     */
    select?: MarketingOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingOffice
     */
    omit?: MarketingOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingOfficeInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketingOffice to update in case it exists.
     */
    where: MarketingOfficeWhereUniqueInput
    /**
     * In case the MarketingOffice found by the `where` argument doesn't exist, create a new MarketingOffice with this data.
     */
    create: XOR<MarketingOfficeCreateInput, MarketingOfficeUncheckedCreateInput>
    /**
     * In case the MarketingOffice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketingOfficeUpdateInput, MarketingOfficeUncheckedUpdateInput>
  }

  /**
   * MarketingOffice delete
   */
  export type MarketingOfficeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingOffice
     */
    select?: MarketingOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingOffice
     */
    omit?: MarketingOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingOfficeInclude<ExtArgs> | null
    /**
     * Filter which MarketingOffice to delete.
     */
    where: MarketingOfficeWhereUniqueInput
  }

  /**
   * MarketingOffice deleteMany
   */
  export type MarketingOfficeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingOffices to delete
     */
    where?: MarketingOfficeWhereInput
    /**
     * Limit how many MarketingOffices to delete.
     */
    limit?: number
  }

  /**
   * MarketingOffice.officeTeamPairs
   */
  export type MarketingOffice$officeTeamPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannelOfficeTeamPair
     */
    select?: MarketingChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannelOfficeTeamPair
     */
    omit?: MarketingChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelOfficeTeamPairInclude<ExtArgs> | null
    where?: MarketingChannelOfficeTeamPairWhereInput
    orderBy?: MarketingChannelOfficeTeamPairOrderByWithRelationInput | MarketingChannelOfficeTeamPairOrderByWithRelationInput[]
    cursor?: MarketingChannelOfficeTeamPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketingChannelOfficeTeamPairScalarFieldEnum | MarketingChannelOfficeTeamPairScalarFieldEnum[]
  }

  /**
   * MarketingOffice.businessUnitMarketingPairs
   */
  export type MarketingOffice$businessUnitMarketingPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitMarketingPair
     */
    select?: BusinessUnitMarketingPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitMarketingPair
     */
    omit?: BusinessUnitMarketingPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitMarketingPairInclude<ExtArgs> | null
    where?: BusinessUnitMarketingPairWhereInput
    orderBy?: BusinessUnitMarketingPairOrderByWithRelationInput | BusinessUnitMarketingPairOrderByWithRelationInput[]
    cursor?: BusinessUnitMarketingPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessUnitMarketingPairScalarFieldEnum | BusinessUnitMarketingPairScalarFieldEnum[]
  }

  /**
   * MarketingOffice without action
   */
  export type MarketingOfficeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingOffice
     */
    select?: MarketingOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingOffice
     */
    omit?: MarketingOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingOfficeInclude<ExtArgs> | null
  }


  /**
   * Model MarketingTeam
   */

  export type AggregateMarketingTeam = {
    _count: MarketingTeamCountAggregateOutputType | null
    _avg: MarketingTeamAvgAggregateOutputType | null
    _sum: MarketingTeamSumAggregateOutputType | null
    _min: MarketingTeamMinAggregateOutputType | null
    _max: MarketingTeamMaxAggregateOutputType | null
  }

  export type MarketingTeamAvgAggregateOutputType = {
    id: number | null
  }

  export type MarketingTeamSumAggregateOutputType = {
    id: number | null
  }

  export type MarketingTeamMinAggregateOutputType = {
    id: number | null
    marketingTeamCode: string | null
    marketingTeamName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketingTeamMaxAggregateOutputType = {
    id: number | null
    marketingTeamCode: string | null
    marketingTeamName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketingTeamCountAggregateOutputType = {
    id: number
    marketingTeamCode: number
    marketingTeamName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarketingTeamAvgAggregateInputType = {
    id?: true
  }

  export type MarketingTeamSumAggregateInputType = {
    id?: true
  }

  export type MarketingTeamMinAggregateInputType = {
    id?: true
    marketingTeamCode?: true
    marketingTeamName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketingTeamMaxAggregateInputType = {
    id?: true
    marketingTeamCode?: true
    marketingTeamName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketingTeamCountAggregateInputType = {
    id?: true
    marketingTeamCode?: true
    marketingTeamName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarketingTeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingTeam to aggregate.
     */
    where?: MarketingTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingTeams to fetch.
     */
    orderBy?: MarketingTeamOrderByWithRelationInput | MarketingTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketingTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketingTeams
    **/
    _count?: true | MarketingTeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketingTeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketingTeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketingTeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketingTeamMaxAggregateInputType
  }

  export type GetMarketingTeamAggregateType<T extends MarketingTeamAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketingTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketingTeam[P]>
      : GetScalarType<T[P], AggregateMarketingTeam[P]>
  }




  export type MarketingTeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketingTeamWhereInput
    orderBy?: MarketingTeamOrderByWithAggregationInput | MarketingTeamOrderByWithAggregationInput[]
    by: MarketingTeamScalarFieldEnum[] | MarketingTeamScalarFieldEnum
    having?: MarketingTeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketingTeamCountAggregateInputType | true
    _avg?: MarketingTeamAvgAggregateInputType
    _sum?: MarketingTeamSumAggregateInputType
    _min?: MarketingTeamMinAggregateInputType
    _max?: MarketingTeamMaxAggregateInputType
  }

  export type MarketingTeamGroupByOutputType = {
    id: number
    marketingTeamCode: string
    marketingTeamName: string
    createdAt: Date
    updatedAt: Date
    _count: MarketingTeamCountAggregateOutputType | null
    _avg: MarketingTeamAvgAggregateOutputType | null
    _sum: MarketingTeamSumAggregateOutputType | null
    _min: MarketingTeamMinAggregateOutputType | null
    _max: MarketingTeamMaxAggregateOutputType | null
  }

  type GetMarketingTeamGroupByPayload<T extends MarketingTeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketingTeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketingTeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketingTeamGroupByOutputType[P]>
            : GetScalarType<T[P], MarketingTeamGroupByOutputType[P]>
        }
      >
    >


  export type MarketingTeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketingTeamCode?: boolean
    marketingTeamName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeTeamPairs?: boolean | MarketingTeam$officeTeamPairsArgs<ExtArgs>
    businessUnitMarketingPairs?: boolean | MarketingTeam$businessUnitMarketingPairsArgs<ExtArgs>
    _count?: boolean | MarketingTeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketingTeam"]>

  export type MarketingTeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketingTeamCode?: boolean
    marketingTeamName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketingTeam"]>

  export type MarketingTeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketingTeamCode?: boolean
    marketingTeamName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketingTeam"]>

  export type MarketingTeamSelectScalar = {
    id?: boolean
    marketingTeamCode?: boolean
    marketingTeamName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MarketingTeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "marketingTeamCode" | "marketingTeamName" | "createdAt" | "updatedAt", ExtArgs["result"]["marketingTeam"]>
  export type MarketingTeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    officeTeamPairs?: boolean | MarketingTeam$officeTeamPairsArgs<ExtArgs>
    businessUnitMarketingPairs?: boolean | MarketingTeam$businessUnitMarketingPairsArgs<ExtArgs>
    _count?: boolean | MarketingTeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MarketingTeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MarketingTeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MarketingTeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketingTeam"
    objects: {
      officeTeamPairs: Prisma.$MarketingChannelOfficeTeamPairPayload<ExtArgs>[]
      businessUnitMarketingPairs: Prisma.$BusinessUnitMarketingPairPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      marketingTeamCode: string
      marketingTeamName: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["marketingTeam"]>
    composites: {}
  }

  type MarketingTeamGetPayload<S extends boolean | null | undefined | MarketingTeamDefaultArgs> = $Result.GetResult<Prisma.$MarketingTeamPayload, S>

  type MarketingTeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketingTeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketingTeamCountAggregateInputType | true
    }

  export interface MarketingTeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketingTeam'], meta: { name: 'MarketingTeam' } }
    /**
     * Find zero or one MarketingTeam that matches the filter.
     * @param {MarketingTeamFindUniqueArgs} args - Arguments to find a MarketingTeam
     * @example
     * // Get one MarketingTeam
     * const marketingTeam = await prisma.marketingTeam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketingTeamFindUniqueArgs>(args: SelectSubset<T, MarketingTeamFindUniqueArgs<ExtArgs>>): Prisma__MarketingTeamClient<$Result.GetResult<Prisma.$MarketingTeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketingTeam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketingTeamFindUniqueOrThrowArgs} args - Arguments to find a MarketingTeam
     * @example
     * // Get one MarketingTeam
     * const marketingTeam = await prisma.marketingTeam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketingTeamFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketingTeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketingTeamClient<$Result.GetResult<Prisma.$MarketingTeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketingTeam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamFindFirstArgs} args - Arguments to find a MarketingTeam
     * @example
     * // Get one MarketingTeam
     * const marketingTeam = await prisma.marketingTeam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketingTeamFindFirstArgs>(args?: SelectSubset<T, MarketingTeamFindFirstArgs<ExtArgs>>): Prisma__MarketingTeamClient<$Result.GetResult<Prisma.$MarketingTeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketingTeam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamFindFirstOrThrowArgs} args - Arguments to find a MarketingTeam
     * @example
     * // Get one MarketingTeam
     * const marketingTeam = await prisma.marketingTeam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketingTeamFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketingTeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketingTeamClient<$Result.GetResult<Prisma.$MarketingTeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketingTeams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketingTeams
     * const marketingTeams = await prisma.marketingTeam.findMany()
     * 
     * // Get first 10 MarketingTeams
     * const marketingTeams = await prisma.marketingTeam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketingTeamWithIdOnly = await prisma.marketingTeam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketingTeamFindManyArgs>(args?: SelectSubset<T, MarketingTeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingTeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketingTeam.
     * @param {MarketingTeamCreateArgs} args - Arguments to create a MarketingTeam.
     * @example
     * // Create one MarketingTeam
     * const MarketingTeam = await prisma.marketingTeam.create({
     *   data: {
     *     // ... data to create a MarketingTeam
     *   }
     * })
     * 
     */
    create<T extends MarketingTeamCreateArgs>(args: SelectSubset<T, MarketingTeamCreateArgs<ExtArgs>>): Prisma__MarketingTeamClient<$Result.GetResult<Prisma.$MarketingTeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketingTeams.
     * @param {MarketingTeamCreateManyArgs} args - Arguments to create many MarketingTeams.
     * @example
     * // Create many MarketingTeams
     * const marketingTeam = await prisma.marketingTeam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketingTeamCreateManyArgs>(args?: SelectSubset<T, MarketingTeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketingTeams and returns the data saved in the database.
     * @param {MarketingTeamCreateManyAndReturnArgs} args - Arguments to create many MarketingTeams.
     * @example
     * // Create many MarketingTeams
     * const marketingTeam = await prisma.marketingTeam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketingTeams and only return the `id`
     * const marketingTeamWithIdOnly = await prisma.marketingTeam.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketingTeamCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketingTeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingTeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MarketingTeam.
     * @param {MarketingTeamDeleteArgs} args - Arguments to delete one MarketingTeam.
     * @example
     * // Delete one MarketingTeam
     * const MarketingTeam = await prisma.marketingTeam.delete({
     *   where: {
     *     // ... filter to delete one MarketingTeam
     *   }
     * })
     * 
     */
    delete<T extends MarketingTeamDeleteArgs>(args: SelectSubset<T, MarketingTeamDeleteArgs<ExtArgs>>): Prisma__MarketingTeamClient<$Result.GetResult<Prisma.$MarketingTeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketingTeam.
     * @param {MarketingTeamUpdateArgs} args - Arguments to update one MarketingTeam.
     * @example
     * // Update one MarketingTeam
     * const marketingTeam = await prisma.marketingTeam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketingTeamUpdateArgs>(args: SelectSubset<T, MarketingTeamUpdateArgs<ExtArgs>>): Prisma__MarketingTeamClient<$Result.GetResult<Prisma.$MarketingTeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketingTeams.
     * @param {MarketingTeamDeleteManyArgs} args - Arguments to filter MarketingTeams to delete.
     * @example
     * // Delete a few MarketingTeams
     * const { count } = await prisma.marketingTeam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketingTeamDeleteManyArgs>(args?: SelectSubset<T, MarketingTeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketingTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketingTeams
     * const marketingTeam = await prisma.marketingTeam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketingTeamUpdateManyArgs>(args: SelectSubset<T, MarketingTeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketingTeams and returns the data updated in the database.
     * @param {MarketingTeamUpdateManyAndReturnArgs} args - Arguments to update many MarketingTeams.
     * @example
     * // Update many MarketingTeams
     * const marketingTeam = await prisma.marketingTeam.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MarketingTeams and only return the `id`
     * const marketingTeamWithIdOnly = await prisma.marketingTeam.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MarketingTeamUpdateManyAndReturnArgs>(args: SelectSubset<T, MarketingTeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingTeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MarketingTeam.
     * @param {MarketingTeamUpsertArgs} args - Arguments to update or create a MarketingTeam.
     * @example
     * // Update or create a MarketingTeam
     * const marketingTeam = await prisma.marketingTeam.upsert({
     *   create: {
     *     // ... data to create a MarketingTeam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketingTeam we want to update
     *   }
     * })
     */
    upsert<T extends MarketingTeamUpsertArgs>(args: SelectSubset<T, MarketingTeamUpsertArgs<ExtArgs>>): Prisma__MarketingTeamClient<$Result.GetResult<Prisma.$MarketingTeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MarketingTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamCountArgs} args - Arguments to filter MarketingTeams to count.
     * @example
     * // Count the number of MarketingTeams
     * const count = await prisma.marketingTeam.count({
     *   where: {
     *     // ... the filter for the MarketingTeams we want to count
     *   }
     * })
    **/
    count<T extends MarketingTeamCountArgs>(
      args?: Subset<T, MarketingTeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketingTeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketingTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketingTeamAggregateArgs>(args: Subset<T, MarketingTeamAggregateArgs>): Prisma.PrismaPromise<GetMarketingTeamAggregateType<T>>

    /**
     * Group by MarketingTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketingTeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketingTeamGroupByArgs['orderBy'] }
        : { orderBy?: MarketingTeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketingTeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketingTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketingTeam model
   */
  readonly fields: MarketingTeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketingTeam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketingTeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    officeTeamPairs<T extends MarketingTeam$officeTeamPairsArgs<ExtArgs> = {}>(args?: Subset<T, MarketingTeam$officeTeamPairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingChannelOfficeTeamPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    businessUnitMarketingPairs<T extends MarketingTeam$businessUnitMarketingPairsArgs<ExtArgs> = {}>(args?: Subset<T, MarketingTeam$businessUnitMarketingPairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitMarketingPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketingTeam model
   */
  interface MarketingTeamFieldRefs {
    readonly id: FieldRef<"MarketingTeam", 'Int'>
    readonly marketingTeamCode: FieldRef<"MarketingTeam", 'String'>
    readonly marketingTeamName: FieldRef<"MarketingTeam", 'String'>
    readonly createdAt: FieldRef<"MarketingTeam", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketingTeam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketingTeam findUnique
   */
  export type MarketingTeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeam
     */
    select?: MarketingTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeam
     */
    omit?: MarketingTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTeamInclude<ExtArgs> | null
    /**
     * Filter, which MarketingTeam to fetch.
     */
    where: MarketingTeamWhereUniqueInput
  }

  /**
   * MarketingTeam findUniqueOrThrow
   */
  export type MarketingTeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeam
     */
    select?: MarketingTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeam
     */
    omit?: MarketingTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTeamInclude<ExtArgs> | null
    /**
     * Filter, which MarketingTeam to fetch.
     */
    where: MarketingTeamWhereUniqueInput
  }

  /**
   * MarketingTeam findFirst
   */
  export type MarketingTeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeam
     */
    select?: MarketingTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeam
     */
    omit?: MarketingTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTeamInclude<ExtArgs> | null
    /**
     * Filter, which MarketingTeam to fetch.
     */
    where?: MarketingTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingTeams to fetch.
     */
    orderBy?: MarketingTeamOrderByWithRelationInput | MarketingTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingTeams.
     */
    cursor?: MarketingTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingTeams.
     */
    distinct?: MarketingTeamScalarFieldEnum | MarketingTeamScalarFieldEnum[]
  }

  /**
   * MarketingTeam findFirstOrThrow
   */
  export type MarketingTeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeam
     */
    select?: MarketingTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeam
     */
    omit?: MarketingTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTeamInclude<ExtArgs> | null
    /**
     * Filter, which MarketingTeam to fetch.
     */
    where?: MarketingTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingTeams to fetch.
     */
    orderBy?: MarketingTeamOrderByWithRelationInput | MarketingTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingTeams.
     */
    cursor?: MarketingTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingTeams.
     */
    distinct?: MarketingTeamScalarFieldEnum | MarketingTeamScalarFieldEnum[]
  }

  /**
   * MarketingTeam findMany
   */
  export type MarketingTeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeam
     */
    select?: MarketingTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeam
     */
    omit?: MarketingTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTeamInclude<ExtArgs> | null
    /**
     * Filter, which MarketingTeams to fetch.
     */
    where?: MarketingTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingTeams to fetch.
     */
    orderBy?: MarketingTeamOrderByWithRelationInput | MarketingTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketingTeams.
     */
    cursor?: MarketingTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingTeams.
     */
    skip?: number
    distinct?: MarketingTeamScalarFieldEnum | MarketingTeamScalarFieldEnum[]
  }

  /**
   * MarketingTeam create
   */
  export type MarketingTeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeam
     */
    select?: MarketingTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeam
     */
    omit?: MarketingTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTeamInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketingTeam.
     */
    data: XOR<MarketingTeamCreateInput, MarketingTeamUncheckedCreateInput>
  }

  /**
   * MarketingTeam createMany
   */
  export type MarketingTeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketingTeams.
     */
    data: MarketingTeamCreateManyInput | MarketingTeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketingTeam createManyAndReturn
   */
  export type MarketingTeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeam
     */
    select?: MarketingTeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeam
     */
    omit?: MarketingTeamOmit<ExtArgs> | null
    /**
     * The data used to create many MarketingTeams.
     */
    data: MarketingTeamCreateManyInput | MarketingTeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketingTeam update
   */
  export type MarketingTeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeam
     */
    select?: MarketingTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeam
     */
    omit?: MarketingTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTeamInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketingTeam.
     */
    data: XOR<MarketingTeamUpdateInput, MarketingTeamUncheckedUpdateInput>
    /**
     * Choose, which MarketingTeam to update.
     */
    where: MarketingTeamWhereUniqueInput
  }

  /**
   * MarketingTeam updateMany
   */
  export type MarketingTeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketingTeams.
     */
    data: XOR<MarketingTeamUpdateManyMutationInput, MarketingTeamUncheckedUpdateManyInput>
    /**
     * Filter which MarketingTeams to update
     */
    where?: MarketingTeamWhereInput
    /**
     * Limit how many MarketingTeams to update.
     */
    limit?: number
  }

  /**
   * MarketingTeam updateManyAndReturn
   */
  export type MarketingTeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeam
     */
    select?: MarketingTeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeam
     */
    omit?: MarketingTeamOmit<ExtArgs> | null
    /**
     * The data used to update MarketingTeams.
     */
    data: XOR<MarketingTeamUpdateManyMutationInput, MarketingTeamUncheckedUpdateManyInput>
    /**
     * Filter which MarketingTeams to update
     */
    where?: MarketingTeamWhereInput
    /**
     * Limit how many MarketingTeams to update.
     */
    limit?: number
  }

  /**
   * MarketingTeam upsert
   */
  export type MarketingTeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeam
     */
    select?: MarketingTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeam
     */
    omit?: MarketingTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTeamInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketingTeam to update in case it exists.
     */
    where: MarketingTeamWhereUniqueInput
    /**
     * In case the MarketingTeam found by the `where` argument doesn't exist, create a new MarketingTeam with this data.
     */
    create: XOR<MarketingTeamCreateInput, MarketingTeamUncheckedCreateInput>
    /**
     * In case the MarketingTeam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketingTeamUpdateInput, MarketingTeamUncheckedUpdateInput>
  }

  /**
   * MarketingTeam delete
   */
  export type MarketingTeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeam
     */
    select?: MarketingTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeam
     */
    omit?: MarketingTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTeamInclude<ExtArgs> | null
    /**
     * Filter which MarketingTeam to delete.
     */
    where: MarketingTeamWhereUniqueInput
  }

  /**
   * MarketingTeam deleteMany
   */
  export type MarketingTeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingTeams to delete
     */
    where?: MarketingTeamWhereInput
    /**
     * Limit how many MarketingTeams to delete.
     */
    limit?: number
  }

  /**
   * MarketingTeam.officeTeamPairs
   */
  export type MarketingTeam$officeTeamPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannelOfficeTeamPair
     */
    select?: MarketingChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannelOfficeTeamPair
     */
    omit?: MarketingChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelOfficeTeamPairInclude<ExtArgs> | null
    where?: MarketingChannelOfficeTeamPairWhereInput
    orderBy?: MarketingChannelOfficeTeamPairOrderByWithRelationInput | MarketingChannelOfficeTeamPairOrderByWithRelationInput[]
    cursor?: MarketingChannelOfficeTeamPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MarketingChannelOfficeTeamPairScalarFieldEnum | MarketingChannelOfficeTeamPairScalarFieldEnum[]
  }

  /**
   * MarketingTeam.businessUnitMarketingPairs
   */
  export type MarketingTeam$businessUnitMarketingPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitMarketingPair
     */
    select?: BusinessUnitMarketingPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitMarketingPair
     */
    omit?: BusinessUnitMarketingPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitMarketingPairInclude<ExtArgs> | null
    where?: BusinessUnitMarketingPairWhereInput
    orderBy?: BusinessUnitMarketingPairOrderByWithRelationInput | BusinessUnitMarketingPairOrderByWithRelationInput[]
    cursor?: BusinessUnitMarketingPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessUnitMarketingPairScalarFieldEnum | BusinessUnitMarketingPairScalarFieldEnum[]
  }

  /**
   * MarketingTeam without action
   */
  export type MarketingTeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeam
     */
    select?: MarketingTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeam
     */
    omit?: MarketingTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingTeamInclude<ExtArgs> | null
  }


  /**
   * Model MarketingChannelOfficeTeamPair
   */

  export type AggregateMarketingChannelOfficeTeamPair = {
    _count: MarketingChannelOfficeTeamPairCountAggregateOutputType | null
    _avg: MarketingChannelOfficeTeamPairAvgAggregateOutputType | null
    _sum: MarketingChannelOfficeTeamPairSumAggregateOutputType | null
    _min: MarketingChannelOfficeTeamPairMinAggregateOutputType | null
    _max: MarketingChannelOfficeTeamPairMaxAggregateOutputType | null
  }

  export type MarketingChannelOfficeTeamPairAvgAggregateOutputType = {
    id: number | null
  }

  export type MarketingChannelOfficeTeamPairSumAggregateOutputType = {
    id: number | null
  }

  export type MarketingChannelOfficeTeamPairMinAggregateOutputType = {
    id: number | null
    marketingChannelCode: string | null
    marketingOfficeId: string | null
    marketingTeamCode: string | null
  }

  export type MarketingChannelOfficeTeamPairMaxAggregateOutputType = {
    id: number | null
    marketingChannelCode: string | null
    marketingOfficeId: string | null
    marketingTeamCode: string | null
  }

  export type MarketingChannelOfficeTeamPairCountAggregateOutputType = {
    id: number
    marketingChannelCode: number
    marketingOfficeId: number
    marketingTeamCode: number
    _all: number
  }


  export type MarketingChannelOfficeTeamPairAvgAggregateInputType = {
    id?: true
  }

  export type MarketingChannelOfficeTeamPairSumAggregateInputType = {
    id?: true
  }

  export type MarketingChannelOfficeTeamPairMinAggregateInputType = {
    id?: true
    marketingChannelCode?: true
    marketingOfficeId?: true
    marketingTeamCode?: true
  }

  export type MarketingChannelOfficeTeamPairMaxAggregateInputType = {
    id?: true
    marketingChannelCode?: true
    marketingOfficeId?: true
    marketingTeamCode?: true
  }

  export type MarketingChannelOfficeTeamPairCountAggregateInputType = {
    id?: true
    marketingChannelCode?: true
    marketingOfficeId?: true
    marketingTeamCode?: true
    _all?: true
  }

  export type MarketingChannelOfficeTeamPairAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingChannelOfficeTeamPair to aggregate.
     */
    where?: MarketingChannelOfficeTeamPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingChannelOfficeTeamPairs to fetch.
     */
    orderBy?: MarketingChannelOfficeTeamPairOrderByWithRelationInput | MarketingChannelOfficeTeamPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketingChannelOfficeTeamPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingChannelOfficeTeamPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingChannelOfficeTeamPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketingChannelOfficeTeamPairs
    **/
    _count?: true | MarketingChannelOfficeTeamPairCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MarketingChannelOfficeTeamPairAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MarketingChannelOfficeTeamPairSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketingChannelOfficeTeamPairMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketingChannelOfficeTeamPairMaxAggregateInputType
  }

  export type GetMarketingChannelOfficeTeamPairAggregateType<T extends MarketingChannelOfficeTeamPairAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketingChannelOfficeTeamPair]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketingChannelOfficeTeamPair[P]>
      : GetScalarType<T[P], AggregateMarketingChannelOfficeTeamPair[P]>
  }




  export type MarketingChannelOfficeTeamPairGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketingChannelOfficeTeamPairWhereInput
    orderBy?: MarketingChannelOfficeTeamPairOrderByWithAggregationInput | MarketingChannelOfficeTeamPairOrderByWithAggregationInput[]
    by: MarketingChannelOfficeTeamPairScalarFieldEnum[] | MarketingChannelOfficeTeamPairScalarFieldEnum
    having?: MarketingChannelOfficeTeamPairScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketingChannelOfficeTeamPairCountAggregateInputType | true
    _avg?: MarketingChannelOfficeTeamPairAvgAggregateInputType
    _sum?: MarketingChannelOfficeTeamPairSumAggregateInputType
    _min?: MarketingChannelOfficeTeamPairMinAggregateInputType
    _max?: MarketingChannelOfficeTeamPairMaxAggregateInputType
  }

  export type MarketingChannelOfficeTeamPairGroupByOutputType = {
    id: number
    marketingChannelCode: string
    marketingOfficeId: string
    marketingTeamCode: string
    _count: MarketingChannelOfficeTeamPairCountAggregateOutputType | null
    _avg: MarketingChannelOfficeTeamPairAvgAggregateOutputType | null
    _sum: MarketingChannelOfficeTeamPairSumAggregateOutputType | null
    _min: MarketingChannelOfficeTeamPairMinAggregateOutputType | null
    _max: MarketingChannelOfficeTeamPairMaxAggregateOutputType | null
  }

  type GetMarketingChannelOfficeTeamPairGroupByPayload<T extends MarketingChannelOfficeTeamPairGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketingChannelOfficeTeamPairGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketingChannelOfficeTeamPairGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketingChannelOfficeTeamPairGroupByOutputType[P]>
            : GetScalarType<T[P], MarketingChannelOfficeTeamPairGroupByOutputType[P]>
        }
      >
    >


  export type MarketingChannelOfficeTeamPairSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketingChannelCode?: boolean
    marketingOfficeId?: boolean
    marketingTeamCode?: boolean
    marketingChannel?: boolean | MarketingChannelDefaultArgs<ExtArgs>
    marketingOffice?: boolean | MarketingOfficeDefaultArgs<ExtArgs>
    marketingTeam?: boolean | MarketingTeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketingChannelOfficeTeamPair"]>

  export type MarketingChannelOfficeTeamPairSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketingChannelCode?: boolean
    marketingOfficeId?: boolean
    marketingTeamCode?: boolean
    marketingChannel?: boolean | MarketingChannelDefaultArgs<ExtArgs>
    marketingOffice?: boolean | MarketingOfficeDefaultArgs<ExtArgs>
    marketingTeam?: boolean | MarketingTeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketingChannelOfficeTeamPair"]>

  export type MarketingChannelOfficeTeamPairSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marketingChannelCode?: boolean
    marketingOfficeId?: boolean
    marketingTeamCode?: boolean
    marketingChannel?: boolean | MarketingChannelDefaultArgs<ExtArgs>
    marketingOffice?: boolean | MarketingOfficeDefaultArgs<ExtArgs>
    marketingTeam?: boolean | MarketingTeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marketingChannelOfficeTeamPair"]>

  export type MarketingChannelOfficeTeamPairSelectScalar = {
    id?: boolean
    marketingChannelCode?: boolean
    marketingOfficeId?: boolean
    marketingTeamCode?: boolean
  }

  export type MarketingChannelOfficeTeamPairOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "marketingChannelCode" | "marketingOfficeId" | "marketingTeamCode", ExtArgs["result"]["marketingChannelOfficeTeamPair"]>
  export type MarketingChannelOfficeTeamPairInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marketingChannel?: boolean | MarketingChannelDefaultArgs<ExtArgs>
    marketingOffice?: boolean | MarketingOfficeDefaultArgs<ExtArgs>
    marketingTeam?: boolean | MarketingTeamDefaultArgs<ExtArgs>
  }
  export type MarketingChannelOfficeTeamPairIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marketingChannel?: boolean | MarketingChannelDefaultArgs<ExtArgs>
    marketingOffice?: boolean | MarketingOfficeDefaultArgs<ExtArgs>
    marketingTeam?: boolean | MarketingTeamDefaultArgs<ExtArgs>
  }
  export type MarketingChannelOfficeTeamPairIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marketingChannel?: boolean | MarketingChannelDefaultArgs<ExtArgs>
    marketingOffice?: boolean | MarketingOfficeDefaultArgs<ExtArgs>
    marketingTeam?: boolean | MarketingTeamDefaultArgs<ExtArgs>
  }

  export type $MarketingChannelOfficeTeamPairPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketingChannelOfficeTeamPair"
    objects: {
      marketingChannel: Prisma.$MarketingChannelPayload<ExtArgs>
      marketingOffice: Prisma.$MarketingOfficePayload<ExtArgs>
      marketingTeam: Prisma.$MarketingTeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      marketingChannelCode: string
      marketingOfficeId: string
      marketingTeamCode: string
    }, ExtArgs["result"]["marketingChannelOfficeTeamPair"]>
    composites: {}
  }

  type MarketingChannelOfficeTeamPairGetPayload<S extends boolean | null | undefined | MarketingChannelOfficeTeamPairDefaultArgs> = $Result.GetResult<Prisma.$MarketingChannelOfficeTeamPairPayload, S>

  type MarketingChannelOfficeTeamPairCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketingChannelOfficeTeamPairFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketingChannelOfficeTeamPairCountAggregateInputType | true
    }

  export interface MarketingChannelOfficeTeamPairDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketingChannelOfficeTeamPair'], meta: { name: 'MarketingChannelOfficeTeamPair' } }
    /**
     * Find zero or one MarketingChannelOfficeTeamPair that matches the filter.
     * @param {MarketingChannelOfficeTeamPairFindUniqueArgs} args - Arguments to find a MarketingChannelOfficeTeamPair
     * @example
     * // Get one MarketingChannelOfficeTeamPair
     * const marketingChannelOfficeTeamPair = await prisma.marketingChannelOfficeTeamPair.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketingChannelOfficeTeamPairFindUniqueArgs>(args: SelectSubset<T, MarketingChannelOfficeTeamPairFindUniqueArgs<ExtArgs>>): Prisma__MarketingChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$MarketingChannelOfficeTeamPairPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketingChannelOfficeTeamPair that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketingChannelOfficeTeamPairFindUniqueOrThrowArgs} args - Arguments to find a MarketingChannelOfficeTeamPair
     * @example
     * // Get one MarketingChannelOfficeTeamPair
     * const marketingChannelOfficeTeamPair = await prisma.marketingChannelOfficeTeamPair.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketingChannelOfficeTeamPairFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketingChannelOfficeTeamPairFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketingChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$MarketingChannelOfficeTeamPairPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketingChannelOfficeTeamPair that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingChannelOfficeTeamPairFindFirstArgs} args - Arguments to find a MarketingChannelOfficeTeamPair
     * @example
     * // Get one MarketingChannelOfficeTeamPair
     * const marketingChannelOfficeTeamPair = await prisma.marketingChannelOfficeTeamPair.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketingChannelOfficeTeamPairFindFirstArgs>(args?: SelectSubset<T, MarketingChannelOfficeTeamPairFindFirstArgs<ExtArgs>>): Prisma__MarketingChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$MarketingChannelOfficeTeamPairPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketingChannelOfficeTeamPair that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingChannelOfficeTeamPairFindFirstOrThrowArgs} args - Arguments to find a MarketingChannelOfficeTeamPair
     * @example
     * // Get one MarketingChannelOfficeTeamPair
     * const marketingChannelOfficeTeamPair = await prisma.marketingChannelOfficeTeamPair.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketingChannelOfficeTeamPairFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketingChannelOfficeTeamPairFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketingChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$MarketingChannelOfficeTeamPairPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketingChannelOfficeTeamPairs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingChannelOfficeTeamPairFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketingChannelOfficeTeamPairs
     * const marketingChannelOfficeTeamPairs = await prisma.marketingChannelOfficeTeamPair.findMany()
     * 
     * // Get first 10 MarketingChannelOfficeTeamPairs
     * const marketingChannelOfficeTeamPairs = await prisma.marketingChannelOfficeTeamPair.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketingChannelOfficeTeamPairWithIdOnly = await prisma.marketingChannelOfficeTeamPair.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketingChannelOfficeTeamPairFindManyArgs>(args?: SelectSubset<T, MarketingChannelOfficeTeamPairFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingChannelOfficeTeamPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketingChannelOfficeTeamPair.
     * @param {MarketingChannelOfficeTeamPairCreateArgs} args - Arguments to create a MarketingChannelOfficeTeamPair.
     * @example
     * // Create one MarketingChannelOfficeTeamPair
     * const MarketingChannelOfficeTeamPair = await prisma.marketingChannelOfficeTeamPair.create({
     *   data: {
     *     // ... data to create a MarketingChannelOfficeTeamPair
     *   }
     * })
     * 
     */
    create<T extends MarketingChannelOfficeTeamPairCreateArgs>(args: SelectSubset<T, MarketingChannelOfficeTeamPairCreateArgs<ExtArgs>>): Prisma__MarketingChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$MarketingChannelOfficeTeamPairPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketingChannelOfficeTeamPairs.
     * @param {MarketingChannelOfficeTeamPairCreateManyArgs} args - Arguments to create many MarketingChannelOfficeTeamPairs.
     * @example
     * // Create many MarketingChannelOfficeTeamPairs
     * const marketingChannelOfficeTeamPair = await prisma.marketingChannelOfficeTeamPair.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketingChannelOfficeTeamPairCreateManyArgs>(args?: SelectSubset<T, MarketingChannelOfficeTeamPairCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketingChannelOfficeTeamPairs and returns the data saved in the database.
     * @param {MarketingChannelOfficeTeamPairCreateManyAndReturnArgs} args - Arguments to create many MarketingChannelOfficeTeamPairs.
     * @example
     * // Create many MarketingChannelOfficeTeamPairs
     * const marketingChannelOfficeTeamPair = await prisma.marketingChannelOfficeTeamPair.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketingChannelOfficeTeamPairs and only return the `id`
     * const marketingChannelOfficeTeamPairWithIdOnly = await prisma.marketingChannelOfficeTeamPair.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketingChannelOfficeTeamPairCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketingChannelOfficeTeamPairCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingChannelOfficeTeamPairPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MarketingChannelOfficeTeamPair.
     * @param {MarketingChannelOfficeTeamPairDeleteArgs} args - Arguments to delete one MarketingChannelOfficeTeamPair.
     * @example
     * // Delete one MarketingChannelOfficeTeamPair
     * const MarketingChannelOfficeTeamPair = await prisma.marketingChannelOfficeTeamPair.delete({
     *   where: {
     *     // ... filter to delete one MarketingChannelOfficeTeamPair
     *   }
     * })
     * 
     */
    delete<T extends MarketingChannelOfficeTeamPairDeleteArgs>(args: SelectSubset<T, MarketingChannelOfficeTeamPairDeleteArgs<ExtArgs>>): Prisma__MarketingChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$MarketingChannelOfficeTeamPairPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketingChannelOfficeTeamPair.
     * @param {MarketingChannelOfficeTeamPairUpdateArgs} args - Arguments to update one MarketingChannelOfficeTeamPair.
     * @example
     * // Update one MarketingChannelOfficeTeamPair
     * const marketingChannelOfficeTeamPair = await prisma.marketingChannelOfficeTeamPair.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketingChannelOfficeTeamPairUpdateArgs>(args: SelectSubset<T, MarketingChannelOfficeTeamPairUpdateArgs<ExtArgs>>): Prisma__MarketingChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$MarketingChannelOfficeTeamPairPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketingChannelOfficeTeamPairs.
     * @param {MarketingChannelOfficeTeamPairDeleteManyArgs} args - Arguments to filter MarketingChannelOfficeTeamPairs to delete.
     * @example
     * // Delete a few MarketingChannelOfficeTeamPairs
     * const { count } = await prisma.marketingChannelOfficeTeamPair.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketingChannelOfficeTeamPairDeleteManyArgs>(args?: SelectSubset<T, MarketingChannelOfficeTeamPairDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketingChannelOfficeTeamPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingChannelOfficeTeamPairUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketingChannelOfficeTeamPairs
     * const marketingChannelOfficeTeamPair = await prisma.marketingChannelOfficeTeamPair.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketingChannelOfficeTeamPairUpdateManyArgs>(args: SelectSubset<T, MarketingChannelOfficeTeamPairUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketingChannelOfficeTeamPairs and returns the data updated in the database.
     * @param {MarketingChannelOfficeTeamPairUpdateManyAndReturnArgs} args - Arguments to update many MarketingChannelOfficeTeamPairs.
     * @example
     * // Update many MarketingChannelOfficeTeamPairs
     * const marketingChannelOfficeTeamPair = await prisma.marketingChannelOfficeTeamPair.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MarketingChannelOfficeTeamPairs and only return the `id`
     * const marketingChannelOfficeTeamPairWithIdOnly = await prisma.marketingChannelOfficeTeamPair.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MarketingChannelOfficeTeamPairUpdateManyAndReturnArgs>(args: SelectSubset<T, MarketingChannelOfficeTeamPairUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingChannelOfficeTeamPairPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MarketingChannelOfficeTeamPair.
     * @param {MarketingChannelOfficeTeamPairUpsertArgs} args - Arguments to update or create a MarketingChannelOfficeTeamPair.
     * @example
     * // Update or create a MarketingChannelOfficeTeamPair
     * const marketingChannelOfficeTeamPair = await prisma.marketingChannelOfficeTeamPair.upsert({
     *   create: {
     *     // ... data to create a MarketingChannelOfficeTeamPair
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketingChannelOfficeTeamPair we want to update
     *   }
     * })
     */
    upsert<T extends MarketingChannelOfficeTeamPairUpsertArgs>(args: SelectSubset<T, MarketingChannelOfficeTeamPairUpsertArgs<ExtArgs>>): Prisma__MarketingChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$MarketingChannelOfficeTeamPairPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MarketingChannelOfficeTeamPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingChannelOfficeTeamPairCountArgs} args - Arguments to filter MarketingChannelOfficeTeamPairs to count.
     * @example
     * // Count the number of MarketingChannelOfficeTeamPairs
     * const count = await prisma.marketingChannelOfficeTeamPair.count({
     *   where: {
     *     // ... the filter for the MarketingChannelOfficeTeamPairs we want to count
     *   }
     * })
    **/
    count<T extends MarketingChannelOfficeTeamPairCountArgs>(
      args?: Subset<T, MarketingChannelOfficeTeamPairCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketingChannelOfficeTeamPairCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketingChannelOfficeTeamPair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingChannelOfficeTeamPairAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketingChannelOfficeTeamPairAggregateArgs>(args: Subset<T, MarketingChannelOfficeTeamPairAggregateArgs>): Prisma.PrismaPromise<GetMarketingChannelOfficeTeamPairAggregateType<T>>

    /**
     * Group by MarketingChannelOfficeTeamPair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingChannelOfficeTeamPairGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketingChannelOfficeTeamPairGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketingChannelOfficeTeamPairGroupByArgs['orderBy'] }
        : { orderBy?: MarketingChannelOfficeTeamPairGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketingChannelOfficeTeamPairGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketingChannelOfficeTeamPairGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketingChannelOfficeTeamPair model
   */
  readonly fields: MarketingChannelOfficeTeamPairFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketingChannelOfficeTeamPair.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketingChannelOfficeTeamPairClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    marketingChannel<T extends MarketingChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MarketingChannelDefaultArgs<ExtArgs>>): Prisma__MarketingChannelClient<$Result.GetResult<Prisma.$MarketingChannelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    marketingOffice<T extends MarketingOfficeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MarketingOfficeDefaultArgs<ExtArgs>>): Prisma__MarketingOfficeClient<$Result.GetResult<Prisma.$MarketingOfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    marketingTeam<T extends MarketingTeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MarketingTeamDefaultArgs<ExtArgs>>): Prisma__MarketingTeamClient<$Result.GetResult<Prisma.$MarketingTeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketingChannelOfficeTeamPair model
   */
  interface MarketingChannelOfficeTeamPairFieldRefs {
    readonly id: FieldRef<"MarketingChannelOfficeTeamPair", 'Int'>
    readonly marketingChannelCode: FieldRef<"MarketingChannelOfficeTeamPair", 'String'>
    readonly marketingOfficeId: FieldRef<"MarketingChannelOfficeTeamPair", 'String'>
    readonly marketingTeamCode: FieldRef<"MarketingChannelOfficeTeamPair", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MarketingChannelOfficeTeamPair findUnique
   */
  export type MarketingChannelOfficeTeamPairFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannelOfficeTeamPair
     */
    select?: MarketingChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannelOfficeTeamPair
     */
    omit?: MarketingChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * Filter, which MarketingChannelOfficeTeamPair to fetch.
     */
    where: MarketingChannelOfficeTeamPairWhereUniqueInput
  }

  /**
   * MarketingChannelOfficeTeamPair findUniqueOrThrow
   */
  export type MarketingChannelOfficeTeamPairFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannelOfficeTeamPair
     */
    select?: MarketingChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannelOfficeTeamPair
     */
    omit?: MarketingChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * Filter, which MarketingChannelOfficeTeamPair to fetch.
     */
    where: MarketingChannelOfficeTeamPairWhereUniqueInput
  }

  /**
   * MarketingChannelOfficeTeamPair findFirst
   */
  export type MarketingChannelOfficeTeamPairFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannelOfficeTeamPair
     */
    select?: MarketingChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannelOfficeTeamPair
     */
    omit?: MarketingChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * Filter, which MarketingChannelOfficeTeamPair to fetch.
     */
    where?: MarketingChannelOfficeTeamPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingChannelOfficeTeamPairs to fetch.
     */
    orderBy?: MarketingChannelOfficeTeamPairOrderByWithRelationInput | MarketingChannelOfficeTeamPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingChannelOfficeTeamPairs.
     */
    cursor?: MarketingChannelOfficeTeamPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingChannelOfficeTeamPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingChannelOfficeTeamPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingChannelOfficeTeamPairs.
     */
    distinct?: MarketingChannelOfficeTeamPairScalarFieldEnum | MarketingChannelOfficeTeamPairScalarFieldEnum[]
  }

  /**
   * MarketingChannelOfficeTeamPair findFirstOrThrow
   */
  export type MarketingChannelOfficeTeamPairFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannelOfficeTeamPair
     */
    select?: MarketingChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannelOfficeTeamPair
     */
    omit?: MarketingChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * Filter, which MarketingChannelOfficeTeamPair to fetch.
     */
    where?: MarketingChannelOfficeTeamPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingChannelOfficeTeamPairs to fetch.
     */
    orderBy?: MarketingChannelOfficeTeamPairOrderByWithRelationInput | MarketingChannelOfficeTeamPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingChannelOfficeTeamPairs.
     */
    cursor?: MarketingChannelOfficeTeamPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingChannelOfficeTeamPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingChannelOfficeTeamPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingChannelOfficeTeamPairs.
     */
    distinct?: MarketingChannelOfficeTeamPairScalarFieldEnum | MarketingChannelOfficeTeamPairScalarFieldEnum[]
  }

  /**
   * MarketingChannelOfficeTeamPair findMany
   */
  export type MarketingChannelOfficeTeamPairFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannelOfficeTeamPair
     */
    select?: MarketingChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannelOfficeTeamPair
     */
    omit?: MarketingChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * Filter, which MarketingChannelOfficeTeamPairs to fetch.
     */
    where?: MarketingChannelOfficeTeamPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingChannelOfficeTeamPairs to fetch.
     */
    orderBy?: MarketingChannelOfficeTeamPairOrderByWithRelationInput | MarketingChannelOfficeTeamPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketingChannelOfficeTeamPairs.
     */
    cursor?: MarketingChannelOfficeTeamPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingChannelOfficeTeamPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingChannelOfficeTeamPairs.
     */
    skip?: number
    distinct?: MarketingChannelOfficeTeamPairScalarFieldEnum | MarketingChannelOfficeTeamPairScalarFieldEnum[]
  }

  /**
   * MarketingChannelOfficeTeamPair create
   */
  export type MarketingChannelOfficeTeamPairCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannelOfficeTeamPair
     */
    select?: MarketingChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannelOfficeTeamPair
     */
    omit?: MarketingChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * The data needed to create a MarketingChannelOfficeTeamPair.
     */
    data: XOR<MarketingChannelOfficeTeamPairCreateInput, MarketingChannelOfficeTeamPairUncheckedCreateInput>
  }

  /**
   * MarketingChannelOfficeTeamPair createMany
   */
  export type MarketingChannelOfficeTeamPairCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketingChannelOfficeTeamPairs.
     */
    data: MarketingChannelOfficeTeamPairCreateManyInput | MarketingChannelOfficeTeamPairCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketingChannelOfficeTeamPair createManyAndReturn
   */
  export type MarketingChannelOfficeTeamPairCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannelOfficeTeamPair
     */
    select?: MarketingChannelOfficeTeamPairSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannelOfficeTeamPair
     */
    omit?: MarketingChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * The data used to create many MarketingChannelOfficeTeamPairs.
     */
    data: MarketingChannelOfficeTeamPairCreateManyInput | MarketingChannelOfficeTeamPairCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelOfficeTeamPairIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketingChannelOfficeTeamPair update
   */
  export type MarketingChannelOfficeTeamPairUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannelOfficeTeamPair
     */
    select?: MarketingChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannelOfficeTeamPair
     */
    omit?: MarketingChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * The data needed to update a MarketingChannelOfficeTeamPair.
     */
    data: XOR<MarketingChannelOfficeTeamPairUpdateInput, MarketingChannelOfficeTeamPairUncheckedUpdateInput>
    /**
     * Choose, which MarketingChannelOfficeTeamPair to update.
     */
    where: MarketingChannelOfficeTeamPairWhereUniqueInput
  }

  /**
   * MarketingChannelOfficeTeamPair updateMany
   */
  export type MarketingChannelOfficeTeamPairUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketingChannelOfficeTeamPairs.
     */
    data: XOR<MarketingChannelOfficeTeamPairUpdateManyMutationInput, MarketingChannelOfficeTeamPairUncheckedUpdateManyInput>
    /**
     * Filter which MarketingChannelOfficeTeamPairs to update
     */
    where?: MarketingChannelOfficeTeamPairWhereInput
    /**
     * Limit how many MarketingChannelOfficeTeamPairs to update.
     */
    limit?: number
  }

  /**
   * MarketingChannelOfficeTeamPair updateManyAndReturn
   */
  export type MarketingChannelOfficeTeamPairUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannelOfficeTeamPair
     */
    select?: MarketingChannelOfficeTeamPairSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannelOfficeTeamPair
     */
    omit?: MarketingChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * The data used to update MarketingChannelOfficeTeamPairs.
     */
    data: XOR<MarketingChannelOfficeTeamPairUpdateManyMutationInput, MarketingChannelOfficeTeamPairUncheckedUpdateManyInput>
    /**
     * Filter which MarketingChannelOfficeTeamPairs to update
     */
    where?: MarketingChannelOfficeTeamPairWhereInput
    /**
     * Limit how many MarketingChannelOfficeTeamPairs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelOfficeTeamPairIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MarketingChannelOfficeTeamPair upsert
   */
  export type MarketingChannelOfficeTeamPairUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannelOfficeTeamPair
     */
    select?: MarketingChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannelOfficeTeamPair
     */
    omit?: MarketingChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * The filter to search for the MarketingChannelOfficeTeamPair to update in case it exists.
     */
    where: MarketingChannelOfficeTeamPairWhereUniqueInput
    /**
     * In case the MarketingChannelOfficeTeamPair found by the `where` argument doesn't exist, create a new MarketingChannelOfficeTeamPair with this data.
     */
    create: XOR<MarketingChannelOfficeTeamPairCreateInput, MarketingChannelOfficeTeamPairUncheckedCreateInput>
    /**
     * In case the MarketingChannelOfficeTeamPair was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketingChannelOfficeTeamPairUpdateInput, MarketingChannelOfficeTeamPairUncheckedUpdateInput>
  }

  /**
   * MarketingChannelOfficeTeamPair delete
   */
  export type MarketingChannelOfficeTeamPairDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannelOfficeTeamPair
     */
    select?: MarketingChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannelOfficeTeamPair
     */
    omit?: MarketingChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * Filter which MarketingChannelOfficeTeamPair to delete.
     */
    where: MarketingChannelOfficeTeamPairWhereUniqueInput
  }

  /**
   * MarketingChannelOfficeTeamPair deleteMany
   */
  export type MarketingChannelOfficeTeamPairDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingChannelOfficeTeamPairs to delete
     */
    where?: MarketingChannelOfficeTeamPairWhereInput
    /**
     * Limit how many MarketingChannelOfficeTeamPairs to delete.
     */
    limit?: number
  }

  /**
   * MarketingChannelOfficeTeamPair without action
   */
  export type MarketingChannelOfficeTeamPairDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingChannelOfficeTeamPair
     */
    select?: MarketingChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingChannelOfficeTeamPair
     */
    omit?: MarketingChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MarketingChannelOfficeTeamPairInclude<ExtArgs> | null
  }


  /**
   * Model ServiceChannel
   */

  export type AggregateServiceChannel = {
    _count: ServiceChannelCountAggregateOutputType | null
    _avg: ServiceChannelAvgAggregateOutputType | null
    _sum: ServiceChannelSumAggregateOutputType | null
    _min: ServiceChannelMinAggregateOutputType | null
    _max: ServiceChannelMaxAggregateOutputType | null
  }

  export type ServiceChannelAvgAggregateOutputType = {
    id: number | null
  }

  export type ServiceChannelSumAggregateOutputType = {
    id: number | null
  }

  export type ServiceChannelMinAggregateOutputType = {
    id: number | null
    serviceChannelCode: string | null
    serviceChannelName: string | null
    serviceChannelDesc: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceChannelMaxAggregateOutputType = {
    id: number | null
    serviceChannelCode: string | null
    serviceChannelName: string | null
    serviceChannelDesc: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceChannelCountAggregateOutputType = {
    id: number
    serviceChannelCode: number
    serviceChannelName: number
    serviceChannelDesc: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceChannelAvgAggregateInputType = {
    id?: true
  }

  export type ServiceChannelSumAggregateInputType = {
    id?: true
  }

  export type ServiceChannelMinAggregateInputType = {
    id?: true
    serviceChannelCode?: true
    serviceChannelName?: true
    serviceChannelDesc?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceChannelMaxAggregateInputType = {
    id?: true
    serviceChannelCode?: true
    serviceChannelName?: true
    serviceChannelDesc?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceChannelCountAggregateInputType = {
    id?: true
    serviceChannelCode?: true
    serviceChannelName?: true
    serviceChannelDesc?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceChannel to aggregate.
     */
    where?: ServiceChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceChannels to fetch.
     */
    orderBy?: ServiceChannelOrderByWithRelationInput | ServiceChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceChannels
    **/
    _count?: true | ServiceChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceChannelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceChannelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceChannelMaxAggregateInputType
  }

  export type GetServiceChannelAggregateType<T extends ServiceChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceChannel[P]>
      : GetScalarType<T[P], AggregateServiceChannel[P]>
  }




  export type ServiceChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceChannelWhereInput
    orderBy?: ServiceChannelOrderByWithAggregationInput | ServiceChannelOrderByWithAggregationInput[]
    by: ServiceChannelScalarFieldEnum[] | ServiceChannelScalarFieldEnum
    having?: ServiceChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceChannelCountAggregateInputType | true
    _avg?: ServiceChannelAvgAggregateInputType
    _sum?: ServiceChannelSumAggregateInputType
    _min?: ServiceChannelMinAggregateInputType
    _max?: ServiceChannelMaxAggregateInputType
  }

  export type ServiceChannelGroupByOutputType = {
    id: number
    serviceChannelCode: string
    serviceChannelName: string
    serviceChannelDesc: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceChannelCountAggregateOutputType | null
    _avg: ServiceChannelAvgAggregateOutputType | null
    _sum: ServiceChannelSumAggregateOutputType | null
    _min: ServiceChannelMinAggregateOutputType | null
    _max: ServiceChannelMaxAggregateOutputType | null
  }

  type GetServiceChannelGroupByPayload<T extends ServiceChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceChannelGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceChannelGroupByOutputType[P]>
        }
      >
    >


  export type ServiceChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceChannelCode?: boolean
    serviceChannelName?: boolean
    serviceChannelDesc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    channelOfficePairs?: boolean | ServiceChannel$channelOfficePairsArgs<ExtArgs>
    businessUnitServicePairs?: boolean | ServiceChannel$businessUnitServicePairsArgs<ExtArgs>
    _count?: boolean | ServiceChannelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceChannel"]>

  export type ServiceChannelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceChannelCode?: boolean
    serviceChannelName?: boolean
    serviceChannelDesc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceChannel"]>

  export type ServiceChannelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceChannelCode?: boolean
    serviceChannelName?: boolean
    serviceChannelDesc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceChannel"]>

  export type ServiceChannelSelectScalar = {
    id?: boolean
    serviceChannelCode?: boolean
    serviceChannelName?: boolean
    serviceChannelDesc?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceChannelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceChannelCode" | "serviceChannelName" | "serviceChannelDesc" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceChannel"]>
  export type ServiceChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channelOfficePairs?: boolean | ServiceChannel$channelOfficePairsArgs<ExtArgs>
    businessUnitServicePairs?: boolean | ServiceChannel$businessUnitServicePairsArgs<ExtArgs>
    _count?: boolean | ServiceChannelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceChannelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceChannelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceChannel"
    objects: {
      channelOfficePairs: Prisma.$ServiceChannelOfficeTeamPairPayload<ExtArgs>[]
      businessUnitServicePairs: Prisma.$BusinessUnitServicePairPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serviceChannelCode: string
      serviceChannelName: string
      serviceChannelDesc: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceChannel"]>
    composites: {}
  }

  type ServiceChannelGetPayload<S extends boolean | null | undefined | ServiceChannelDefaultArgs> = $Result.GetResult<Prisma.$ServiceChannelPayload, S>

  type ServiceChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceChannelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceChannelCountAggregateInputType | true
    }

  export interface ServiceChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceChannel'], meta: { name: 'ServiceChannel' } }
    /**
     * Find zero or one ServiceChannel that matches the filter.
     * @param {ServiceChannelFindUniqueArgs} args - Arguments to find a ServiceChannel
     * @example
     * // Get one ServiceChannel
     * const serviceChannel = await prisma.serviceChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceChannelFindUniqueArgs>(args: SelectSubset<T, ServiceChannelFindUniqueArgs<ExtArgs>>): Prisma__ServiceChannelClient<$Result.GetResult<Prisma.$ServiceChannelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceChannel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceChannelFindUniqueOrThrowArgs} args - Arguments to find a ServiceChannel
     * @example
     * // Get one ServiceChannel
     * const serviceChannel = await prisma.serviceChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceChannelClient<$Result.GetResult<Prisma.$ServiceChannelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChannelFindFirstArgs} args - Arguments to find a ServiceChannel
     * @example
     * // Get one ServiceChannel
     * const serviceChannel = await prisma.serviceChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceChannelFindFirstArgs>(args?: SelectSubset<T, ServiceChannelFindFirstArgs<ExtArgs>>): Prisma__ServiceChannelClient<$Result.GetResult<Prisma.$ServiceChannelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceChannel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChannelFindFirstOrThrowArgs} args - Arguments to find a ServiceChannel
     * @example
     * // Get one ServiceChannel
     * const serviceChannel = await prisma.serviceChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceChannelClient<$Result.GetResult<Prisma.$ServiceChannelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceChannels
     * const serviceChannels = await prisma.serviceChannel.findMany()
     * 
     * // Get first 10 ServiceChannels
     * const serviceChannels = await prisma.serviceChannel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceChannelWithIdOnly = await prisma.serviceChannel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceChannelFindManyArgs>(args?: SelectSubset<T, ServiceChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceChannelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceChannel.
     * @param {ServiceChannelCreateArgs} args - Arguments to create a ServiceChannel.
     * @example
     * // Create one ServiceChannel
     * const ServiceChannel = await prisma.serviceChannel.create({
     *   data: {
     *     // ... data to create a ServiceChannel
     *   }
     * })
     * 
     */
    create<T extends ServiceChannelCreateArgs>(args: SelectSubset<T, ServiceChannelCreateArgs<ExtArgs>>): Prisma__ServiceChannelClient<$Result.GetResult<Prisma.$ServiceChannelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceChannels.
     * @param {ServiceChannelCreateManyArgs} args - Arguments to create many ServiceChannels.
     * @example
     * // Create many ServiceChannels
     * const serviceChannel = await prisma.serviceChannel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceChannelCreateManyArgs>(args?: SelectSubset<T, ServiceChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceChannels and returns the data saved in the database.
     * @param {ServiceChannelCreateManyAndReturnArgs} args - Arguments to create many ServiceChannels.
     * @example
     * // Create many ServiceChannels
     * const serviceChannel = await prisma.serviceChannel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceChannels and only return the `id`
     * const serviceChannelWithIdOnly = await prisma.serviceChannel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceChannelCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceChannelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceChannelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceChannel.
     * @param {ServiceChannelDeleteArgs} args - Arguments to delete one ServiceChannel.
     * @example
     * // Delete one ServiceChannel
     * const ServiceChannel = await prisma.serviceChannel.delete({
     *   where: {
     *     // ... filter to delete one ServiceChannel
     *   }
     * })
     * 
     */
    delete<T extends ServiceChannelDeleteArgs>(args: SelectSubset<T, ServiceChannelDeleteArgs<ExtArgs>>): Prisma__ServiceChannelClient<$Result.GetResult<Prisma.$ServiceChannelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceChannel.
     * @param {ServiceChannelUpdateArgs} args - Arguments to update one ServiceChannel.
     * @example
     * // Update one ServiceChannel
     * const serviceChannel = await prisma.serviceChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceChannelUpdateArgs>(args: SelectSubset<T, ServiceChannelUpdateArgs<ExtArgs>>): Prisma__ServiceChannelClient<$Result.GetResult<Prisma.$ServiceChannelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceChannels.
     * @param {ServiceChannelDeleteManyArgs} args - Arguments to filter ServiceChannels to delete.
     * @example
     * // Delete a few ServiceChannels
     * const { count } = await prisma.serviceChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceChannelDeleteManyArgs>(args?: SelectSubset<T, ServiceChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceChannels
     * const serviceChannel = await prisma.serviceChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceChannelUpdateManyArgs>(args: SelectSubset<T, ServiceChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceChannels and returns the data updated in the database.
     * @param {ServiceChannelUpdateManyAndReturnArgs} args - Arguments to update many ServiceChannels.
     * @example
     * // Update many ServiceChannels
     * const serviceChannel = await prisma.serviceChannel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceChannels and only return the `id`
     * const serviceChannelWithIdOnly = await prisma.serviceChannel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceChannelUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceChannelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceChannelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceChannel.
     * @param {ServiceChannelUpsertArgs} args - Arguments to update or create a ServiceChannel.
     * @example
     * // Update or create a ServiceChannel
     * const serviceChannel = await prisma.serviceChannel.upsert({
     *   create: {
     *     // ... data to create a ServiceChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceChannel we want to update
     *   }
     * })
     */
    upsert<T extends ServiceChannelUpsertArgs>(args: SelectSubset<T, ServiceChannelUpsertArgs<ExtArgs>>): Prisma__ServiceChannelClient<$Result.GetResult<Prisma.$ServiceChannelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChannelCountArgs} args - Arguments to filter ServiceChannels to count.
     * @example
     * // Count the number of ServiceChannels
     * const count = await prisma.serviceChannel.count({
     *   where: {
     *     // ... the filter for the ServiceChannels we want to count
     *   }
     * })
    **/
    count<T extends ServiceChannelCountArgs>(
      args?: Subset<T, ServiceChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceChannelAggregateArgs>(args: Subset<T, ServiceChannelAggregateArgs>): Prisma.PrismaPromise<GetServiceChannelAggregateType<T>>

    /**
     * Group by ServiceChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceChannelGroupByArgs['orderBy'] }
        : { orderBy?: ServiceChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceChannel model
   */
  readonly fields: ServiceChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channelOfficePairs<T extends ServiceChannel$channelOfficePairsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceChannel$channelOfficePairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceChannelOfficeTeamPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    businessUnitServicePairs<T extends ServiceChannel$businessUnitServicePairsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceChannel$businessUnitServicePairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitServicePairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceChannel model
   */
  interface ServiceChannelFieldRefs {
    readonly id: FieldRef<"ServiceChannel", 'Int'>
    readonly serviceChannelCode: FieldRef<"ServiceChannel", 'String'>
    readonly serviceChannelName: FieldRef<"ServiceChannel", 'String'>
    readonly serviceChannelDesc: FieldRef<"ServiceChannel", 'String'>
    readonly createdAt: FieldRef<"ServiceChannel", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceChannel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceChannel findUnique
   */
  export type ServiceChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannel
     */
    select?: ServiceChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannel
     */
    omit?: ServiceChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelInclude<ExtArgs> | null
    /**
     * Filter, which ServiceChannel to fetch.
     */
    where: ServiceChannelWhereUniqueInput
  }

  /**
   * ServiceChannel findUniqueOrThrow
   */
  export type ServiceChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannel
     */
    select?: ServiceChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannel
     */
    omit?: ServiceChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelInclude<ExtArgs> | null
    /**
     * Filter, which ServiceChannel to fetch.
     */
    where: ServiceChannelWhereUniqueInput
  }

  /**
   * ServiceChannel findFirst
   */
  export type ServiceChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannel
     */
    select?: ServiceChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannel
     */
    omit?: ServiceChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelInclude<ExtArgs> | null
    /**
     * Filter, which ServiceChannel to fetch.
     */
    where?: ServiceChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceChannels to fetch.
     */
    orderBy?: ServiceChannelOrderByWithRelationInput | ServiceChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceChannels.
     */
    cursor?: ServiceChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceChannels.
     */
    distinct?: ServiceChannelScalarFieldEnum | ServiceChannelScalarFieldEnum[]
  }

  /**
   * ServiceChannel findFirstOrThrow
   */
  export type ServiceChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannel
     */
    select?: ServiceChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannel
     */
    omit?: ServiceChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelInclude<ExtArgs> | null
    /**
     * Filter, which ServiceChannel to fetch.
     */
    where?: ServiceChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceChannels to fetch.
     */
    orderBy?: ServiceChannelOrderByWithRelationInput | ServiceChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceChannels.
     */
    cursor?: ServiceChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceChannels.
     */
    distinct?: ServiceChannelScalarFieldEnum | ServiceChannelScalarFieldEnum[]
  }

  /**
   * ServiceChannel findMany
   */
  export type ServiceChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannel
     */
    select?: ServiceChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannel
     */
    omit?: ServiceChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelInclude<ExtArgs> | null
    /**
     * Filter, which ServiceChannels to fetch.
     */
    where?: ServiceChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceChannels to fetch.
     */
    orderBy?: ServiceChannelOrderByWithRelationInput | ServiceChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceChannels.
     */
    cursor?: ServiceChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceChannels.
     */
    skip?: number
    distinct?: ServiceChannelScalarFieldEnum | ServiceChannelScalarFieldEnum[]
  }

  /**
   * ServiceChannel create
   */
  export type ServiceChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannel
     */
    select?: ServiceChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannel
     */
    omit?: ServiceChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceChannel.
     */
    data: XOR<ServiceChannelCreateInput, ServiceChannelUncheckedCreateInput>
  }

  /**
   * ServiceChannel createMany
   */
  export type ServiceChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceChannels.
     */
    data: ServiceChannelCreateManyInput | ServiceChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceChannel createManyAndReturn
   */
  export type ServiceChannelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannel
     */
    select?: ServiceChannelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannel
     */
    omit?: ServiceChannelOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceChannels.
     */
    data: ServiceChannelCreateManyInput | ServiceChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceChannel update
   */
  export type ServiceChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannel
     */
    select?: ServiceChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannel
     */
    omit?: ServiceChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceChannel.
     */
    data: XOR<ServiceChannelUpdateInput, ServiceChannelUncheckedUpdateInput>
    /**
     * Choose, which ServiceChannel to update.
     */
    where: ServiceChannelWhereUniqueInput
  }

  /**
   * ServiceChannel updateMany
   */
  export type ServiceChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceChannels.
     */
    data: XOR<ServiceChannelUpdateManyMutationInput, ServiceChannelUncheckedUpdateManyInput>
    /**
     * Filter which ServiceChannels to update
     */
    where?: ServiceChannelWhereInput
    /**
     * Limit how many ServiceChannels to update.
     */
    limit?: number
  }

  /**
   * ServiceChannel updateManyAndReturn
   */
  export type ServiceChannelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannel
     */
    select?: ServiceChannelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannel
     */
    omit?: ServiceChannelOmit<ExtArgs> | null
    /**
     * The data used to update ServiceChannels.
     */
    data: XOR<ServiceChannelUpdateManyMutationInput, ServiceChannelUncheckedUpdateManyInput>
    /**
     * Filter which ServiceChannels to update
     */
    where?: ServiceChannelWhereInput
    /**
     * Limit how many ServiceChannels to update.
     */
    limit?: number
  }

  /**
   * ServiceChannel upsert
   */
  export type ServiceChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannel
     */
    select?: ServiceChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannel
     */
    omit?: ServiceChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceChannel to update in case it exists.
     */
    where: ServiceChannelWhereUniqueInput
    /**
     * In case the ServiceChannel found by the `where` argument doesn't exist, create a new ServiceChannel with this data.
     */
    create: XOR<ServiceChannelCreateInput, ServiceChannelUncheckedCreateInput>
    /**
     * In case the ServiceChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceChannelUpdateInput, ServiceChannelUncheckedUpdateInput>
  }

  /**
   * ServiceChannel delete
   */
  export type ServiceChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannel
     */
    select?: ServiceChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannel
     */
    omit?: ServiceChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelInclude<ExtArgs> | null
    /**
     * Filter which ServiceChannel to delete.
     */
    where: ServiceChannelWhereUniqueInput
  }

  /**
   * ServiceChannel deleteMany
   */
  export type ServiceChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceChannels to delete
     */
    where?: ServiceChannelWhereInput
    /**
     * Limit how many ServiceChannels to delete.
     */
    limit?: number
  }

  /**
   * ServiceChannel.channelOfficePairs
   */
  export type ServiceChannel$channelOfficePairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannelOfficeTeamPair
     */
    select?: ServiceChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannelOfficeTeamPair
     */
    omit?: ServiceChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelOfficeTeamPairInclude<ExtArgs> | null
    where?: ServiceChannelOfficeTeamPairWhereInput
    orderBy?: ServiceChannelOfficeTeamPairOrderByWithRelationInput | ServiceChannelOfficeTeamPairOrderByWithRelationInput[]
    cursor?: ServiceChannelOfficeTeamPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceChannelOfficeTeamPairScalarFieldEnum | ServiceChannelOfficeTeamPairScalarFieldEnum[]
  }

  /**
   * ServiceChannel.businessUnitServicePairs
   */
  export type ServiceChannel$businessUnitServicePairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitServicePair
     */
    select?: BusinessUnitServicePairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitServicePair
     */
    omit?: BusinessUnitServicePairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitServicePairInclude<ExtArgs> | null
    where?: BusinessUnitServicePairWhereInput
    orderBy?: BusinessUnitServicePairOrderByWithRelationInput | BusinessUnitServicePairOrderByWithRelationInput[]
    cursor?: BusinessUnitServicePairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessUnitServicePairScalarFieldEnum | BusinessUnitServicePairScalarFieldEnum[]
  }

  /**
   * ServiceChannel without action
   */
  export type ServiceChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannel
     */
    select?: ServiceChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannel
     */
    omit?: ServiceChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelInclude<ExtArgs> | null
  }


  /**
   * Model ServiceOffice
   */

  export type AggregateServiceOffice = {
    _count: ServiceOfficeCountAggregateOutputType | null
    _avg: ServiceOfficeAvgAggregateOutputType | null
    _sum: ServiceOfficeSumAggregateOutputType | null
    _min: ServiceOfficeMinAggregateOutputType | null
    _max: ServiceOfficeMaxAggregateOutputType | null
  }

  export type ServiceOfficeAvgAggregateOutputType = {
    id: number | null
  }

  export type ServiceOfficeSumAggregateOutputType = {
    id: number | null
  }

  export type ServiceOfficeMinAggregateOutputType = {
    id: number | null
    serviceOfficeId: string | null
    organizationName: string | null
    serviceOfficeDesc: string | null
    street1: string | null
    street2: string | null
    city: string | null
    state: string | null
    region: string | null
    country: string | null
    pinCode: string | null
    validFrom: Date | null
    validTo: Date | null
    company: string | null
    parentUnit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceOfficeMaxAggregateOutputType = {
    id: number | null
    serviceOfficeId: string | null
    organizationName: string | null
    serviceOfficeDesc: string | null
    street1: string | null
    street2: string | null
    city: string | null
    state: string | null
    region: string | null
    country: string | null
    pinCode: string | null
    validFrom: Date | null
    validTo: Date | null
    company: string | null
    parentUnit: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceOfficeCountAggregateOutputType = {
    id: number
    serviceOfficeId: number
    organizationName: number
    serviceOfficeDesc: number
    street1: number
    street2: number
    city: number
    state: number
    region: number
    country: number
    pinCode: number
    validFrom: number
    validTo: number
    company: number
    parentUnit: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceOfficeAvgAggregateInputType = {
    id?: true
  }

  export type ServiceOfficeSumAggregateInputType = {
    id?: true
  }

  export type ServiceOfficeMinAggregateInputType = {
    id?: true
    serviceOfficeId?: true
    organizationName?: true
    serviceOfficeDesc?: true
    street1?: true
    street2?: true
    city?: true
    state?: true
    region?: true
    country?: true
    pinCode?: true
    validFrom?: true
    validTo?: true
    company?: true
    parentUnit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceOfficeMaxAggregateInputType = {
    id?: true
    serviceOfficeId?: true
    organizationName?: true
    serviceOfficeDesc?: true
    street1?: true
    street2?: true
    city?: true
    state?: true
    region?: true
    country?: true
    pinCode?: true
    validFrom?: true
    validTo?: true
    company?: true
    parentUnit?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceOfficeCountAggregateInputType = {
    id?: true
    serviceOfficeId?: true
    organizationName?: true
    serviceOfficeDesc?: true
    street1?: true
    street2?: true
    city?: true
    state?: true
    region?: true
    country?: true
    pinCode?: true
    validFrom?: true
    validTo?: true
    company?: true
    parentUnit?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceOfficeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceOffice to aggregate.
     */
    where?: ServiceOfficeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceOffices to fetch.
     */
    orderBy?: ServiceOfficeOrderByWithRelationInput | ServiceOfficeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceOfficeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceOffices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceOffices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceOffices
    **/
    _count?: true | ServiceOfficeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceOfficeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceOfficeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceOfficeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceOfficeMaxAggregateInputType
  }

  export type GetServiceOfficeAggregateType<T extends ServiceOfficeAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceOffice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceOffice[P]>
      : GetScalarType<T[P], AggregateServiceOffice[P]>
  }




  export type ServiceOfficeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceOfficeWhereInput
    orderBy?: ServiceOfficeOrderByWithAggregationInput | ServiceOfficeOrderByWithAggregationInput[]
    by: ServiceOfficeScalarFieldEnum[] | ServiceOfficeScalarFieldEnum
    having?: ServiceOfficeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceOfficeCountAggregateInputType | true
    _avg?: ServiceOfficeAvgAggregateInputType
    _sum?: ServiceOfficeSumAggregateInputType
    _min?: ServiceOfficeMinAggregateInputType
    _max?: ServiceOfficeMaxAggregateInputType
  }

  export type ServiceOfficeGroupByOutputType = {
    id: number
    serviceOfficeId: string
    organizationName: string
    serviceOfficeDesc: string | null
    street1: string
    street2: string | null
    city: string
    state: string
    region: string | null
    country: string
    pinCode: string
    validFrom: Date
    validTo: Date
    company: string
    parentUnit: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceOfficeCountAggregateOutputType | null
    _avg: ServiceOfficeAvgAggregateOutputType | null
    _sum: ServiceOfficeSumAggregateOutputType | null
    _min: ServiceOfficeMinAggregateOutputType | null
    _max: ServiceOfficeMaxAggregateOutputType | null
  }

  type GetServiceOfficeGroupByPayload<T extends ServiceOfficeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceOfficeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceOfficeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceOfficeGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceOfficeGroupByOutputType[P]>
        }
      >
    >


  export type ServiceOfficeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceOfficeId?: boolean
    organizationName?: boolean
    serviceOfficeDesc?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    region?: boolean
    country?: boolean
    pinCode?: boolean
    validFrom?: boolean
    validTo?: boolean
    company?: boolean
    parentUnit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeTeamPairs?: boolean | ServiceOffice$officeTeamPairsArgs<ExtArgs>
    businessUnitServicePairs?: boolean | ServiceOffice$businessUnitServicePairsArgs<ExtArgs>
    _count?: boolean | ServiceOfficeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceOffice"]>

  export type ServiceOfficeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceOfficeId?: boolean
    organizationName?: boolean
    serviceOfficeDesc?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    region?: boolean
    country?: boolean
    pinCode?: boolean
    validFrom?: boolean
    validTo?: boolean
    company?: boolean
    parentUnit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceOffice"]>

  export type ServiceOfficeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceOfficeId?: boolean
    organizationName?: boolean
    serviceOfficeDesc?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    region?: boolean
    country?: boolean
    pinCode?: boolean
    validFrom?: boolean
    validTo?: boolean
    company?: boolean
    parentUnit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceOffice"]>

  export type ServiceOfficeSelectScalar = {
    id?: boolean
    serviceOfficeId?: boolean
    organizationName?: boolean
    serviceOfficeDesc?: boolean
    street1?: boolean
    street2?: boolean
    city?: boolean
    state?: boolean
    region?: boolean
    country?: boolean
    pinCode?: boolean
    validFrom?: boolean
    validTo?: boolean
    company?: boolean
    parentUnit?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceOfficeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceOfficeId" | "organizationName" | "serviceOfficeDesc" | "street1" | "street2" | "city" | "state" | "region" | "country" | "pinCode" | "validFrom" | "validTo" | "company" | "parentUnit" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceOffice"]>
  export type ServiceOfficeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    officeTeamPairs?: boolean | ServiceOffice$officeTeamPairsArgs<ExtArgs>
    businessUnitServicePairs?: boolean | ServiceOffice$businessUnitServicePairsArgs<ExtArgs>
    _count?: boolean | ServiceOfficeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceOfficeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceOfficeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceOfficePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceOffice"
    objects: {
      officeTeamPairs: Prisma.$ServiceChannelOfficeTeamPairPayload<ExtArgs>[]
      businessUnitServicePairs: Prisma.$BusinessUnitServicePairPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serviceOfficeId: string
      organizationName: string
      serviceOfficeDesc: string | null
      street1: string
      street2: string | null
      city: string
      state: string
      region: string | null
      country: string
      pinCode: string
      validFrom: Date
      validTo: Date
      company: string
      parentUnit: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceOffice"]>
    composites: {}
  }

  type ServiceOfficeGetPayload<S extends boolean | null | undefined | ServiceOfficeDefaultArgs> = $Result.GetResult<Prisma.$ServiceOfficePayload, S>

  type ServiceOfficeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceOfficeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceOfficeCountAggregateInputType | true
    }

  export interface ServiceOfficeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceOffice'], meta: { name: 'ServiceOffice' } }
    /**
     * Find zero or one ServiceOffice that matches the filter.
     * @param {ServiceOfficeFindUniqueArgs} args - Arguments to find a ServiceOffice
     * @example
     * // Get one ServiceOffice
     * const serviceOffice = await prisma.serviceOffice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceOfficeFindUniqueArgs>(args: SelectSubset<T, ServiceOfficeFindUniqueArgs<ExtArgs>>): Prisma__ServiceOfficeClient<$Result.GetResult<Prisma.$ServiceOfficePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceOffice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceOfficeFindUniqueOrThrowArgs} args - Arguments to find a ServiceOffice
     * @example
     * // Get one ServiceOffice
     * const serviceOffice = await prisma.serviceOffice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceOfficeFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceOfficeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceOfficeClient<$Result.GetResult<Prisma.$ServiceOfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceOffice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOfficeFindFirstArgs} args - Arguments to find a ServiceOffice
     * @example
     * // Get one ServiceOffice
     * const serviceOffice = await prisma.serviceOffice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceOfficeFindFirstArgs>(args?: SelectSubset<T, ServiceOfficeFindFirstArgs<ExtArgs>>): Prisma__ServiceOfficeClient<$Result.GetResult<Prisma.$ServiceOfficePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceOffice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOfficeFindFirstOrThrowArgs} args - Arguments to find a ServiceOffice
     * @example
     * // Get one ServiceOffice
     * const serviceOffice = await prisma.serviceOffice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceOfficeFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceOfficeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceOfficeClient<$Result.GetResult<Prisma.$ServiceOfficePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceOffices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOfficeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceOffices
     * const serviceOffices = await prisma.serviceOffice.findMany()
     * 
     * // Get first 10 ServiceOffices
     * const serviceOffices = await prisma.serviceOffice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceOfficeWithIdOnly = await prisma.serviceOffice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceOfficeFindManyArgs>(args?: SelectSubset<T, ServiceOfficeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceOfficePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceOffice.
     * @param {ServiceOfficeCreateArgs} args - Arguments to create a ServiceOffice.
     * @example
     * // Create one ServiceOffice
     * const ServiceOffice = await prisma.serviceOffice.create({
     *   data: {
     *     // ... data to create a ServiceOffice
     *   }
     * })
     * 
     */
    create<T extends ServiceOfficeCreateArgs>(args: SelectSubset<T, ServiceOfficeCreateArgs<ExtArgs>>): Prisma__ServiceOfficeClient<$Result.GetResult<Prisma.$ServiceOfficePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceOffices.
     * @param {ServiceOfficeCreateManyArgs} args - Arguments to create many ServiceOffices.
     * @example
     * // Create many ServiceOffices
     * const serviceOffice = await prisma.serviceOffice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceOfficeCreateManyArgs>(args?: SelectSubset<T, ServiceOfficeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceOffices and returns the data saved in the database.
     * @param {ServiceOfficeCreateManyAndReturnArgs} args - Arguments to create many ServiceOffices.
     * @example
     * // Create many ServiceOffices
     * const serviceOffice = await prisma.serviceOffice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceOffices and only return the `id`
     * const serviceOfficeWithIdOnly = await prisma.serviceOffice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceOfficeCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceOfficeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceOfficePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceOffice.
     * @param {ServiceOfficeDeleteArgs} args - Arguments to delete one ServiceOffice.
     * @example
     * // Delete one ServiceOffice
     * const ServiceOffice = await prisma.serviceOffice.delete({
     *   where: {
     *     // ... filter to delete one ServiceOffice
     *   }
     * })
     * 
     */
    delete<T extends ServiceOfficeDeleteArgs>(args: SelectSubset<T, ServiceOfficeDeleteArgs<ExtArgs>>): Prisma__ServiceOfficeClient<$Result.GetResult<Prisma.$ServiceOfficePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceOffice.
     * @param {ServiceOfficeUpdateArgs} args - Arguments to update one ServiceOffice.
     * @example
     * // Update one ServiceOffice
     * const serviceOffice = await prisma.serviceOffice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceOfficeUpdateArgs>(args: SelectSubset<T, ServiceOfficeUpdateArgs<ExtArgs>>): Prisma__ServiceOfficeClient<$Result.GetResult<Prisma.$ServiceOfficePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceOffices.
     * @param {ServiceOfficeDeleteManyArgs} args - Arguments to filter ServiceOffices to delete.
     * @example
     * // Delete a few ServiceOffices
     * const { count } = await prisma.serviceOffice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceOfficeDeleteManyArgs>(args?: SelectSubset<T, ServiceOfficeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceOffices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOfficeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceOffices
     * const serviceOffice = await prisma.serviceOffice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceOfficeUpdateManyArgs>(args: SelectSubset<T, ServiceOfficeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceOffices and returns the data updated in the database.
     * @param {ServiceOfficeUpdateManyAndReturnArgs} args - Arguments to update many ServiceOffices.
     * @example
     * // Update many ServiceOffices
     * const serviceOffice = await prisma.serviceOffice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceOffices and only return the `id`
     * const serviceOfficeWithIdOnly = await prisma.serviceOffice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceOfficeUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceOfficeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceOfficePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceOffice.
     * @param {ServiceOfficeUpsertArgs} args - Arguments to update or create a ServiceOffice.
     * @example
     * // Update or create a ServiceOffice
     * const serviceOffice = await prisma.serviceOffice.upsert({
     *   create: {
     *     // ... data to create a ServiceOffice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceOffice we want to update
     *   }
     * })
     */
    upsert<T extends ServiceOfficeUpsertArgs>(args: SelectSubset<T, ServiceOfficeUpsertArgs<ExtArgs>>): Prisma__ServiceOfficeClient<$Result.GetResult<Prisma.$ServiceOfficePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceOffices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOfficeCountArgs} args - Arguments to filter ServiceOffices to count.
     * @example
     * // Count the number of ServiceOffices
     * const count = await prisma.serviceOffice.count({
     *   where: {
     *     // ... the filter for the ServiceOffices we want to count
     *   }
     * })
    **/
    count<T extends ServiceOfficeCountArgs>(
      args?: Subset<T, ServiceOfficeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceOfficeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceOffice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOfficeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceOfficeAggregateArgs>(args: Subset<T, ServiceOfficeAggregateArgs>): Prisma.PrismaPromise<GetServiceOfficeAggregateType<T>>

    /**
     * Group by ServiceOffice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceOfficeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceOfficeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceOfficeGroupByArgs['orderBy'] }
        : { orderBy?: ServiceOfficeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceOfficeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceOfficeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceOffice model
   */
  readonly fields: ServiceOfficeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceOffice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceOfficeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    officeTeamPairs<T extends ServiceOffice$officeTeamPairsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceOffice$officeTeamPairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceChannelOfficeTeamPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    businessUnitServicePairs<T extends ServiceOffice$businessUnitServicePairsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceOffice$businessUnitServicePairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitServicePairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceOffice model
   */
  interface ServiceOfficeFieldRefs {
    readonly id: FieldRef<"ServiceOffice", 'Int'>
    readonly serviceOfficeId: FieldRef<"ServiceOffice", 'String'>
    readonly organizationName: FieldRef<"ServiceOffice", 'String'>
    readonly serviceOfficeDesc: FieldRef<"ServiceOffice", 'String'>
    readonly street1: FieldRef<"ServiceOffice", 'String'>
    readonly street2: FieldRef<"ServiceOffice", 'String'>
    readonly city: FieldRef<"ServiceOffice", 'String'>
    readonly state: FieldRef<"ServiceOffice", 'String'>
    readonly region: FieldRef<"ServiceOffice", 'String'>
    readonly country: FieldRef<"ServiceOffice", 'String'>
    readonly pinCode: FieldRef<"ServiceOffice", 'String'>
    readonly validFrom: FieldRef<"ServiceOffice", 'DateTime'>
    readonly validTo: FieldRef<"ServiceOffice", 'DateTime'>
    readonly company: FieldRef<"ServiceOffice", 'String'>
    readonly parentUnit: FieldRef<"ServiceOffice", 'String'>
    readonly createdAt: FieldRef<"ServiceOffice", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceOffice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceOffice findUnique
   */
  export type ServiceOfficeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOffice
     */
    select?: ServiceOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOffice
     */
    omit?: ServiceOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOfficeInclude<ExtArgs> | null
    /**
     * Filter, which ServiceOffice to fetch.
     */
    where: ServiceOfficeWhereUniqueInput
  }

  /**
   * ServiceOffice findUniqueOrThrow
   */
  export type ServiceOfficeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOffice
     */
    select?: ServiceOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOffice
     */
    omit?: ServiceOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOfficeInclude<ExtArgs> | null
    /**
     * Filter, which ServiceOffice to fetch.
     */
    where: ServiceOfficeWhereUniqueInput
  }

  /**
   * ServiceOffice findFirst
   */
  export type ServiceOfficeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOffice
     */
    select?: ServiceOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOffice
     */
    omit?: ServiceOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOfficeInclude<ExtArgs> | null
    /**
     * Filter, which ServiceOffice to fetch.
     */
    where?: ServiceOfficeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceOffices to fetch.
     */
    orderBy?: ServiceOfficeOrderByWithRelationInput | ServiceOfficeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceOffices.
     */
    cursor?: ServiceOfficeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceOffices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceOffices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceOffices.
     */
    distinct?: ServiceOfficeScalarFieldEnum | ServiceOfficeScalarFieldEnum[]
  }

  /**
   * ServiceOffice findFirstOrThrow
   */
  export type ServiceOfficeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOffice
     */
    select?: ServiceOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOffice
     */
    omit?: ServiceOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOfficeInclude<ExtArgs> | null
    /**
     * Filter, which ServiceOffice to fetch.
     */
    where?: ServiceOfficeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceOffices to fetch.
     */
    orderBy?: ServiceOfficeOrderByWithRelationInput | ServiceOfficeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceOffices.
     */
    cursor?: ServiceOfficeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceOffices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceOffices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceOffices.
     */
    distinct?: ServiceOfficeScalarFieldEnum | ServiceOfficeScalarFieldEnum[]
  }

  /**
   * ServiceOffice findMany
   */
  export type ServiceOfficeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOffice
     */
    select?: ServiceOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOffice
     */
    omit?: ServiceOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOfficeInclude<ExtArgs> | null
    /**
     * Filter, which ServiceOffices to fetch.
     */
    where?: ServiceOfficeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceOffices to fetch.
     */
    orderBy?: ServiceOfficeOrderByWithRelationInput | ServiceOfficeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceOffices.
     */
    cursor?: ServiceOfficeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceOffices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceOffices.
     */
    skip?: number
    distinct?: ServiceOfficeScalarFieldEnum | ServiceOfficeScalarFieldEnum[]
  }

  /**
   * ServiceOffice create
   */
  export type ServiceOfficeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOffice
     */
    select?: ServiceOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOffice
     */
    omit?: ServiceOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOfficeInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceOffice.
     */
    data: XOR<ServiceOfficeCreateInput, ServiceOfficeUncheckedCreateInput>
  }

  /**
   * ServiceOffice createMany
   */
  export type ServiceOfficeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceOffices.
     */
    data: ServiceOfficeCreateManyInput | ServiceOfficeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceOffice createManyAndReturn
   */
  export type ServiceOfficeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOffice
     */
    select?: ServiceOfficeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOffice
     */
    omit?: ServiceOfficeOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceOffices.
     */
    data: ServiceOfficeCreateManyInput | ServiceOfficeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceOffice update
   */
  export type ServiceOfficeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOffice
     */
    select?: ServiceOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOffice
     */
    omit?: ServiceOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOfficeInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceOffice.
     */
    data: XOR<ServiceOfficeUpdateInput, ServiceOfficeUncheckedUpdateInput>
    /**
     * Choose, which ServiceOffice to update.
     */
    where: ServiceOfficeWhereUniqueInput
  }

  /**
   * ServiceOffice updateMany
   */
  export type ServiceOfficeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceOffices.
     */
    data: XOR<ServiceOfficeUpdateManyMutationInput, ServiceOfficeUncheckedUpdateManyInput>
    /**
     * Filter which ServiceOffices to update
     */
    where?: ServiceOfficeWhereInput
    /**
     * Limit how many ServiceOffices to update.
     */
    limit?: number
  }

  /**
   * ServiceOffice updateManyAndReturn
   */
  export type ServiceOfficeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOffice
     */
    select?: ServiceOfficeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOffice
     */
    omit?: ServiceOfficeOmit<ExtArgs> | null
    /**
     * The data used to update ServiceOffices.
     */
    data: XOR<ServiceOfficeUpdateManyMutationInput, ServiceOfficeUncheckedUpdateManyInput>
    /**
     * Filter which ServiceOffices to update
     */
    where?: ServiceOfficeWhereInput
    /**
     * Limit how many ServiceOffices to update.
     */
    limit?: number
  }

  /**
   * ServiceOffice upsert
   */
  export type ServiceOfficeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOffice
     */
    select?: ServiceOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOffice
     */
    omit?: ServiceOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOfficeInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceOffice to update in case it exists.
     */
    where: ServiceOfficeWhereUniqueInput
    /**
     * In case the ServiceOffice found by the `where` argument doesn't exist, create a new ServiceOffice with this data.
     */
    create: XOR<ServiceOfficeCreateInput, ServiceOfficeUncheckedCreateInput>
    /**
     * In case the ServiceOffice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceOfficeUpdateInput, ServiceOfficeUncheckedUpdateInput>
  }

  /**
   * ServiceOffice delete
   */
  export type ServiceOfficeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOffice
     */
    select?: ServiceOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOffice
     */
    omit?: ServiceOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOfficeInclude<ExtArgs> | null
    /**
     * Filter which ServiceOffice to delete.
     */
    where: ServiceOfficeWhereUniqueInput
  }

  /**
   * ServiceOffice deleteMany
   */
  export type ServiceOfficeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceOffices to delete
     */
    where?: ServiceOfficeWhereInput
    /**
     * Limit how many ServiceOffices to delete.
     */
    limit?: number
  }

  /**
   * ServiceOffice.officeTeamPairs
   */
  export type ServiceOffice$officeTeamPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannelOfficeTeamPair
     */
    select?: ServiceChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannelOfficeTeamPair
     */
    omit?: ServiceChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelOfficeTeamPairInclude<ExtArgs> | null
    where?: ServiceChannelOfficeTeamPairWhereInput
    orderBy?: ServiceChannelOfficeTeamPairOrderByWithRelationInput | ServiceChannelOfficeTeamPairOrderByWithRelationInput[]
    cursor?: ServiceChannelOfficeTeamPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceChannelOfficeTeamPairScalarFieldEnum | ServiceChannelOfficeTeamPairScalarFieldEnum[]
  }

  /**
   * ServiceOffice.businessUnitServicePairs
   */
  export type ServiceOffice$businessUnitServicePairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitServicePair
     */
    select?: BusinessUnitServicePairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitServicePair
     */
    omit?: BusinessUnitServicePairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitServicePairInclude<ExtArgs> | null
    where?: BusinessUnitServicePairWhereInput
    orderBy?: BusinessUnitServicePairOrderByWithRelationInput | BusinessUnitServicePairOrderByWithRelationInput[]
    cursor?: BusinessUnitServicePairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessUnitServicePairScalarFieldEnum | BusinessUnitServicePairScalarFieldEnum[]
  }

  /**
   * ServiceOffice without action
   */
  export type ServiceOfficeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceOffice
     */
    select?: ServiceOfficeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceOffice
     */
    omit?: ServiceOfficeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceOfficeInclude<ExtArgs> | null
  }


  /**
   * Model ServiceTeam
   */

  export type AggregateServiceTeam = {
    _count: ServiceTeamCountAggregateOutputType | null
    _avg: ServiceTeamAvgAggregateOutputType | null
    _sum: ServiceTeamSumAggregateOutputType | null
    _min: ServiceTeamMinAggregateOutputType | null
    _max: ServiceTeamMaxAggregateOutputType | null
  }

  export type ServiceTeamAvgAggregateOutputType = {
    id: number | null
  }

  export type ServiceTeamSumAggregateOutputType = {
    id: number | null
  }

  export type ServiceTeamMinAggregateOutputType = {
    id: number | null
    serviceTeamCode: string | null
    serviceTeamName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceTeamMaxAggregateOutputType = {
    id: number | null
    serviceTeamCode: string | null
    serviceTeamName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceTeamCountAggregateOutputType = {
    id: number
    serviceTeamCode: number
    serviceTeamName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceTeamAvgAggregateInputType = {
    id?: true
  }

  export type ServiceTeamSumAggregateInputType = {
    id?: true
  }

  export type ServiceTeamMinAggregateInputType = {
    id?: true
    serviceTeamCode?: true
    serviceTeamName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceTeamMaxAggregateInputType = {
    id?: true
    serviceTeamCode?: true
    serviceTeamName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceTeamCountAggregateInputType = {
    id?: true
    serviceTeamCode?: true
    serviceTeamName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceTeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceTeam to aggregate.
     */
    where?: ServiceTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTeams to fetch.
     */
    orderBy?: ServiceTeamOrderByWithRelationInput | ServiceTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceTeams
    **/
    _count?: true | ServiceTeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceTeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceTeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceTeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceTeamMaxAggregateInputType
  }

  export type GetServiceTeamAggregateType<T extends ServiceTeamAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceTeam[P]>
      : GetScalarType<T[P], AggregateServiceTeam[P]>
  }




  export type ServiceTeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceTeamWhereInput
    orderBy?: ServiceTeamOrderByWithAggregationInput | ServiceTeamOrderByWithAggregationInput[]
    by: ServiceTeamScalarFieldEnum[] | ServiceTeamScalarFieldEnum
    having?: ServiceTeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceTeamCountAggregateInputType | true
    _avg?: ServiceTeamAvgAggregateInputType
    _sum?: ServiceTeamSumAggregateInputType
    _min?: ServiceTeamMinAggregateInputType
    _max?: ServiceTeamMaxAggregateInputType
  }

  export type ServiceTeamGroupByOutputType = {
    id: number
    serviceTeamCode: string
    serviceTeamName: string
    createdAt: Date
    updatedAt: Date
    _count: ServiceTeamCountAggregateOutputType | null
    _avg: ServiceTeamAvgAggregateOutputType | null
    _sum: ServiceTeamSumAggregateOutputType | null
    _min: ServiceTeamMinAggregateOutputType | null
    _max: ServiceTeamMaxAggregateOutputType | null
  }

  type GetServiceTeamGroupByPayload<T extends ServiceTeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceTeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceTeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceTeamGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceTeamGroupByOutputType[P]>
        }
      >
    >


  export type ServiceTeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceTeamCode?: boolean
    serviceTeamName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    officeTeamPairs?: boolean | ServiceTeam$officeTeamPairsArgs<ExtArgs>
    businessUnitServicePairs?: boolean | ServiceTeam$businessUnitServicePairsArgs<ExtArgs>
    _count?: boolean | ServiceTeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceTeam"]>

  export type ServiceTeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceTeamCode?: boolean
    serviceTeamName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceTeam"]>

  export type ServiceTeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceTeamCode?: boolean
    serviceTeamName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceTeam"]>

  export type ServiceTeamSelectScalar = {
    id?: boolean
    serviceTeamCode?: boolean
    serviceTeamName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceTeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceTeamCode" | "serviceTeamName" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceTeam"]>
  export type ServiceTeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    officeTeamPairs?: boolean | ServiceTeam$officeTeamPairsArgs<ExtArgs>
    businessUnitServicePairs?: boolean | ServiceTeam$businessUnitServicePairsArgs<ExtArgs>
    _count?: boolean | ServiceTeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceTeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ServiceTeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ServiceTeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceTeam"
    objects: {
      officeTeamPairs: Prisma.$ServiceChannelOfficeTeamPairPayload<ExtArgs>[]
      businessUnitServicePairs: Prisma.$BusinessUnitServicePairPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serviceTeamCode: string
      serviceTeamName: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceTeam"]>
    composites: {}
  }

  type ServiceTeamGetPayload<S extends boolean | null | undefined | ServiceTeamDefaultArgs> = $Result.GetResult<Prisma.$ServiceTeamPayload, S>

  type ServiceTeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceTeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceTeamCountAggregateInputType | true
    }

  export interface ServiceTeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceTeam'], meta: { name: 'ServiceTeam' } }
    /**
     * Find zero or one ServiceTeam that matches the filter.
     * @param {ServiceTeamFindUniqueArgs} args - Arguments to find a ServiceTeam
     * @example
     * // Get one ServiceTeam
     * const serviceTeam = await prisma.serviceTeam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceTeamFindUniqueArgs>(args: SelectSubset<T, ServiceTeamFindUniqueArgs<ExtArgs>>): Prisma__ServiceTeamClient<$Result.GetResult<Prisma.$ServiceTeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceTeam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceTeamFindUniqueOrThrowArgs} args - Arguments to find a ServiceTeam
     * @example
     * // Get one ServiceTeam
     * const serviceTeam = await prisma.serviceTeam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceTeamFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceTeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceTeamClient<$Result.GetResult<Prisma.$ServiceTeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceTeam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamFindFirstArgs} args - Arguments to find a ServiceTeam
     * @example
     * // Get one ServiceTeam
     * const serviceTeam = await prisma.serviceTeam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceTeamFindFirstArgs>(args?: SelectSubset<T, ServiceTeamFindFirstArgs<ExtArgs>>): Prisma__ServiceTeamClient<$Result.GetResult<Prisma.$ServiceTeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceTeam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamFindFirstOrThrowArgs} args - Arguments to find a ServiceTeam
     * @example
     * // Get one ServiceTeam
     * const serviceTeam = await prisma.serviceTeam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceTeamFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceTeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceTeamClient<$Result.GetResult<Prisma.$ServiceTeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceTeams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceTeams
     * const serviceTeams = await prisma.serviceTeam.findMany()
     * 
     * // Get first 10 ServiceTeams
     * const serviceTeams = await prisma.serviceTeam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceTeamWithIdOnly = await prisma.serviceTeam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceTeamFindManyArgs>(args?: SelectSubset<T, ServiceTeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceTeam.
     * @param {ServiceTeamCreateArgs} args - Arguments to create a ServiceTeam.
     * @example
     * // Create one ServiceTeam
     * const ServiceTeam = await prisma.serviceTeam.create({
     *   data: {
     *     // ... data to create a ServiceTeam
     *   }
     * })
     * 
     */
    create<T extends ServiceTeamCreateArgs>(args: SelectSubset<T, ServiceTeamCreateArgs<ExtArgs>>): Prisma__ServiceTeamClient<$Result.GetResult<Prisma.$ServiceTeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceTeams.
     * @param {ServiceTeamCreateManyArgs} args - Arguments to create many ServiceTeams.
     * @example
     * // Create many ServiceTeams
     * const serviceTeam = await prisma.serviceTeam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceTeamCreateManyArgs>(args?: SelectSubset<T, ServiceTeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceTeams and returns the data saved in the database.
     * @param {ServiceTeamCreateManyAndReturnArgs} args - Arguments to create many ServiceTeams.
     * @example
     * // Create many ServiceTeams
     * const serviceTeam = await prisma.serviceTeam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceTeams and only return the `id`
     * const serviceTeamWithIdOnly = await prisma.serviceTeam.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceTeamCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceTeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceTeam.
     * @param {ServiceTeamDeleteArgs} args - Arguments to delete one ServiceTeam.
     * @example
     * // Delete one ServiceTeam
     * const ServiceTeam = await prisma.serviceTeam.delete({
     *   where: {
     *     // ... filter to delete one ServiceTeam
     *   }
     * })
     * 
     */
    delete<T extends ServiceTeamDeleteArgs>(args: SelectSubset<T, ServiceTeamDeleteArgs<ExtArgs>>): Prisma__ServiceTeamClient<$Result.GetResult<Prisma.$ServiceTeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceTeam.
     * @param {ServiceTeamUpdateArgs} args - Arguments to update one ServiceTeam.
     * @example
     * // Update one ServiceTeam
     * const serviceTeam = await prisma.serviceTeam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceTeamUpdateArgs>(args: SelectSubset<T, ServiceTeamUpdateArgs<ExtArgs>>): Prisma__ServiceTeamClient<$Result.GetResult<Prisma.$ServiceTeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceTeams.
     * @param {ServiceTeamDeleteManyArgs} args - Arguments to filter ServiceTeams to delete.
     * @example
     * // Delete a few ServiceTeams
     * const { count } = await prisma.serviceTeam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceTeamDeleteManyArgs>(args?: SelectSubset<T, ServiceTeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceTeams
     * const serviceTeam = await prisma.serviceTeam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceTeamUpdateManyArgs>(args: SelectSubset<T, ServiceTeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceTeams and returns the data updated in the database.
     * @param {ServiceTeamUpdateManyAndReturnArgs} args - Arguments to update many ServiceTeams.
     * @example
     * // Update many ServiceTeams
     * const serviceTeam = await prisma.serviceTeam.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceTeams and only return the `id`
     * const serviceTeamWithIdOnly = await prisma.serviceTeam.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceTeamUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceTeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceTeam.
     * @param {ServiceTeamUpsertArgs} args - Arguments to update or create a ServiceTeam.
     * @example
     * // Update or create a ServiceTeam
     * const serviceTeam = await prisma.serviceTeam.upsert({
     *   create: {
     *     // ... data to create a ServiceTeam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceTeam we want to update
     *   }
     * })
     */
    upsert<T extends ServiceTeamUpsertArgs>(args: SelectSubset<T, ServiceTeamUpsertArgs<ExtArgs>>): Prisma__ServiceTeamClient<$Result.GetResult<Prisma.$ServiceTeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceTeams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamCountArgs} args - Arguments to filter ServiceTeams to count.
     * @example
     * // Count the number of ServiceTeams
     * const count = await prisma.serviceTeam.count({
     *   where: {
     *     // ... the filter for the ServiceTeams we want to count
     *   }
     * })
    **/
    count<T extends ServiceTeamCountArgs>(
      args?: Subset<T, ServiceTeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceTeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceTeamAggregateArgs>(args: Subset<T, ServiceTeamAggregateArgs>): Prisma.PrismaPromise<GetServiceTeamAggregateType<T>>

    /**
     * Group by ServiceTeam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceTeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceTeamGroupByArgs['orderBy'] }
        : { orderBy?: ServiceTeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceTeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceTeam model
   */
  readonly fields: ServiceTeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceTeam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceTeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    officeTeamPairs<T extends ServiceTeam$officeTeamPairsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceTeam$officeTeamPairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceChannelOfficeTeamPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    businessUnitServicePairs<T extends ServiceTeam$businessUnitServicePairsArgs<ExtArgs> = {}>(args?: Subset<T, ServiceTeam$businessUnitServicePairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitServicePairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceTeam model
   */
  interface ServiceTeamFieldRefs {
    readonly id: FieldRef<"ServiceTeam", 'Int'>
    readonly serviceTeamCode: FieldRef<"ServiceTeam", 'String'>
    readonly serviceTeamName: FieldRef<"ServiceTeam", 'String'>
    readonly createdAt: FieldRef<"ServiceTeam", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceTeam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceTeam findUnique
   */
  export type ServiceTeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeam
     */
    select?: ServiceTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeam
     */
    omit?: ServiceTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTeamInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTeam to fetch.
     */
    where: ServiceTeamWhereUniqueInput
  }

  /**
   * ServiceTeam findUniqueOrThrow
   */
  export type ServiceTeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeam
     */
    select?: ServiceTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeam
     */
    omit?: ServiceTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTeamInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTeam to fetch.
     */
    where: ServiceTeamWhereUniqueInput
  }

  /**
   * ServiceTeam findFirst
   */
  export type ServiceTeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeam
     */
    select?: ServiceTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeam
     */
    omit?: ServiceTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTeamInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTeam to fetch.
     */
    where?: ServiceTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTeams to fetch.
     */
    orderBy?: ServiceTeamOrderByWithRelationInput | ServiceTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceTeams.
     */
    cursor?: ServiceTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceTeams.
     */
    distinct?: ServiceTeamScalarFieldEnum | ServiceTeamScalarFieldEnum[]
  }

  /**
   * ServiceTeam findFirstOrThrow
   */
  export type ServiceTeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeam
     */
    select?: ServiceTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeam
     */
    omit?: ServiceTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTeamInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTeam to fetch.
     */
    where?: ServiceTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTeams to fetch.
     */
    orderBy?: ServiceTeamOrderByWithRelationInput | ServiceTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceTeams.
     */
    cursor?: ServiceTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTeams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceTeams.
     */
    distinct?: ServiceTeamScalarFieldEnum | ServiceTeamScalarFieldEnum[]
  }

  /**
   * ServiceTeam findMany
   */
  export type ServiceTeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeam
     */
    select?: ServiceTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeam
     */
    omit?: ServiceTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTeamInclude<ExtArgs> | null
    /**
     * Filter, which ServiceTeams to fetch.
     */
    where?: ServiceTeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTeams to fetch.
     */
    orderBy?: ServiceTeamOrderByWithRelationInput | ServiceTeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceTeams.
     */
    cursor?: ServiceTeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTeams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTeams.
     */
    skip?: number
    distinct?: ServiceTeamScalarFieldEnum | ServiceTeamScalarFieldEnum[]
  }

  /**
   * ServiceTeam create
   */
  export type ServiceTeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeam
     */
    select?: ServiceTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeam
     */
    omit?: ServiceTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTeamInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceTeam.
     */
    data: XOR<ServiceTeamCreateInput, ServiceTeamUncheckedCreateInput>
  }

  /**
   * ServiceTeam createMany
   */
  export type ServiceTeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceTeams.
     */
    data: ServiceTeamCreateManyInput | ServiceTeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceTeam createManyAndReturn
   */
  export type ServiceTeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeam
     */
    select?: ServiceTeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeam
     */
    omit?: ServiceTeamOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceTeams.
     */
    data: ServiceTeamCreateManyInput | ServiceTeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceTeam update
   */
  export type ServiceTeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeam
     */
    select?: ServiceTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeam
     */
    omit?: ServiceTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTeamInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceTeam.
     */
    data: XOR<ServiceTeamUpdateInput, ServiceTeamUncheckedUpdateInput>
    /**
     * Choose, which ServiceTeam to update.
     */
    where: ServiceTeamWhereUniqueInput
  }

  /**
   * ServiceTeam updateMany
   */
  export type ServiceTeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceTeams.
     */
    data: XOR<ServiceTeamUpdateManyMutationInput, ServiceTeamUncheckedUpdateManyInput>
    /**
     * Filter which ServiceTeams to update
     */
    where?: ServiceTeamWhereInput
    /**
     * Limit how many ServiceTeams to update.
     */
    limit?: number
  }

  /**
   * ServiceTeam updateManyAndReturn
   */
  export type ServiceTeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeam
     */
    select?: ServiceTeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeam
     */
    omit?: ServiceTeamOmit<ExtArgs> | null
    /**
     * The data used to update ServiceTeams.
     */
    data: XOR<ServiceTeamUpdateManyMutationInput, ServiceTeamUncheckedUpdateManyInput>
    /**
     * Filter which ServiceTeams to update
     */
    where?: ServiceTeamWhereInput
    /**
     * Limit how many ServiceTeams to update.
     */
    limit?: number
  }

  /**
   * ServiceTeam upsert
   */
  export type ServiceTeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeam
     */
    select?: ServiceTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeam
     */
    omit?: ServiceTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTeamInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceTeam to update in case it exists.
     */
    where: ServiceTeamWhereUniqueInput
    /**
     * In case the ServiceTeam found by the `where` argument doesn't exist, create a new ServiceTeam with this data.
     */
    create: XOR<ServiceTeamCreateInput, ServiceTeamUncheckedCreateInput>
    /**
     * In case the ServiceTeam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceTeamUpdateInput, ServiceTeamUncheckedUpdateInput>
  }

  /**
   * ServiceTeam delete
   */
  export type ServiceTeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeam
     */
    select?: ServiceTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeam
     */
    omit?: ServiceTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTeamInclude<ExtArgs> | null
    /**
     * Filter which ServiceTeam to delete.
     */
    where: ServiceTeamWhereUniqueInput
  }

  /**
   * ServiceTeam deleteMany
   */
  export type ServiceTeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceTeams to delete
     */
    where?: ServiceTeamWhereInput
    /**
     * Limit how many ServiceTeams to delete.
     */
    limit?: number
  }

  /**
   * ServiceTeam.officeTeamPairs
   */
  export type ServiceTeam$officeTeamPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannelOfficeTeamPair
     */
    select?: ServiceChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannelOfficeTeamPair
     */
    omit?: ServiceChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelOfficeTeamPairInclude<ExtArgs> | null
    where?: ServiceChannelOfficeTeamPairWhereInput
    orderBy?: ServiceChannelOfficeTeamPairOrderByWithRelationInput | ServiceChannelOfficeTeamPairOrderByWithRelationInput[]
    cursor?: ServiceChannelOfficeTeamPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceChannelOfficeTeamPairScalarFieldEnum | ServiceChannelOfficeTeamPairScalarFieldEnum[]
  }

  /**
   * ServiceTeam.businessUnitServicePairs
   */
  export type ServiceTeam$businessUnitServicePairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitServicePair
     */
    select?: BusinessUnitServicePairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitServicePair
     */
    omit?: BusinessUnitServicePairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitServicePairInclude<ExtArgs> | null
    where?: BusinessUnitServicePairWhereInput
    orderBy?: BusinessUnitServicePairOrderByWithRelationInput | BusinessUnitServicePairOrderByWithRelationInput[]
    cursor?: BusinessUnitServicePairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessUnitServicePairScalarFieldEnum | BusinessUnitServicePairScalarFieldEnum[]
  }

  /**
   * ServiceTeam without action
   */
  export type ServiceTeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeam
     */
    select?: ServiceTeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeam
     */
    omit?: ServiceTeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceTeamInclude<ExtArgs> | null
  }


  /**
   * Model ServiceChannelOfficeTeamPair
   */

  export type AggregateServiceChannelOfficeTeamPair = {
    _count: ServiceChannelOfficeTeamPairCountAggregateOutputType | null
    _avg: ServiceChannelOfficeTeamPairAvgAggregateOutputType | null
    _sum: ServiceChannelOfficeTeamPairSumAggregateOutputType | null
    _min: ServiceChannelOfficeTeamPairMinAggregateOutputType | null
    _max: ServiceChannelOfficeTeamPairMaxAggregateOutputType | null
  }

  export type ServiceChannelOfficeTeamPairAvgAggregateOutputType = {
    id: number | null
  }

  export type ServiceChannelOfficeTeamPairSumAggregateOutputType = {
    id: number | null
  }

  export type ServiceChannelOfficeTeamPairMinAggregateOutputType = {
    id: number | null
    serviceChannelCode: string | null
    serviceOfficeId: string | null
    serviceTeamCode: string | null
  }

  export type ServiceChannelOfficeTeamPairMaxAggregateOutputType = {
    id: number | null
    serviceChannelCode: string | null
    serviceOfficeId: string | null
    serviceTeamCode: string | null
  }

  export type ServiceChannelOfficeTeamPairCountAggregateOutputType = {
    id: number
    serviceChannelCode: number
    serviceOfficeId: number
    serviceTeamCode: number
    _all: number
  }


  export type ServiceChannelOfficeTeamPairAvgAggregateInputType = {
    id?: true
  }

  export type ServiceChannelOfficeTeamPairSumAggregateInputType = {
    id?: true
  }

  export type ServiceChannelOfficeTeamPairMinAggregateInputType = {
    id?: true
    serviceChannelCode?: true
    serviceOfficeId?: true
    serviceTeamCode?: true
  }

  export type ServiceChannelOfficeTeamPairMaxAggregateInputType = {
    id?: true
    serviceChannelCode?: true
    serviceOfficeId?: true
    serviceTeamCode?: true
  }

  export type ServiceChannelOfficeTeamPairCountAggregateInputType = {
    id?: true
    serviceChannelCode?: true
    serviceOfficeId?: true
    serviceTeamCode?: true
    _all?: true
  }

  export type ServiceChannelOfficeTeamPairAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceChannelOfficeTeamPair to aggregate.
     */
    where?: ServiceChannelOfficeTeamPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceChannelOfficeTeamPairs to fetch.
     */
    orderBy?: ServiceChannelOfficeTeamPairOrderByWithRelationInput | ServiceChannelOfficeTeamPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceChannelOfficeTeamPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceChannelOfficeTeamPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceChannelOfficeTeamPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceChannelOfficeTeamPairs
    **/
    _count?: true | ServiceChannelOfficeTeamPairCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceChannelOfficeTeamPairAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceChannelOfficeTeamPairSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceChannelOfficeTeamPairMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceChannelOfficeTeamPairMaxAggregateInputType
  }

  export type GetServiceChannelOfficeTeamPairAggregateType<T extends ServiceChannelOfficeTeamPairAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceChannelOfficeTeamPair]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceChannelOfficeTeamPair[P]>
      : GetScalarType<T[P], AggregateServiceChannelOfficeTeamPair[P]>
  }




  export type ServiceChannelOfficeTeamPairGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceChannelOfficeTeamPairWhereInput
    orderBy?: ServiceChannelOfficeTeamPairOrderByWithAggregationInput | ServiceChannelOfficeTeamPairOrderByWithAggregationInput[]
    by: ServiceChannelOfficeTeamPairScalarFieldEnum[] | ServiceChannelOfficeTeamPairScalarFieldEnum
    having?: ServiceChannelOfficeTeamPairScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceChannelOfficeTeamPairCountAggregateInputType | true
    _avg?: ServiceChannelOfficeTeamPairAvgAggregateInputType
    _sum?: ServiceChannelOfficeTeamPairSumAggregateInputType
    _min?: ServiceChannelOfficeTeamPairMinAggregateInputType
    _max?: ServiceChannelOfficeTeamPairMaxAggregateInputType
  }

  export type ServiceChannelOfficeTeamPairGroupByOutputType = {
    id: number
    serviceChannelCode: string
    serviceOfficeId: string
    serviceTeamCode: string
    _count: ServiceChannelOfficeTeamPairCountAggregateOutputType | null
    _avg: ServiceChannelOfficeTeamPairAvgAggregateOutputType | null
    _sum: ServiceChannelOfficeTeamPairSumAggregateOutputType | null
    _min: ServiceChannelOfficeTeamPairMinAggregateOutputType | null
    _max: ServiceChannelOfficeTeamPairMaxAggregateOutputType | null
  }

  type GetServiceChannelOfficeTeamPairGroupByPayload<T extends ServiceChannelOfficeTeamPairGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceChannelOfficeTeamPairGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceChannelOfficeTeamPairGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceChannelOfficeTeamPairGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceChannelOfficeTeamPairGroupByOutputType[P]>
        }
      >
    >


  export type ServiceChannelOfficeTeamPairSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceChannelCode?: boolean
    serviceOfficeId?: boolean
    serviceTeamCode?: boolean
    serviceChannel?: boolean | ServiceChannelDefaultArgs<ExtArgs>
    serviceOffice?: boolean | ServiceOfficeDefaultArgs<ExtArgs>
    serviceTeam?: boolean | ServiceTeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceChannelOfficeTeamPair"]>

  export type ServiceChannelOfficeTeamPairSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceChannelCode?: boolean
    serviceOfficeId?: boolean
    serviceTeamCode?: boolean
    serviceChannel?: boolean | ServiceChannelDefaultArgs<ExtArgs>
    serviceOffice?: boolean | ServiceOfficeDefaultArgs<ExtArgs>
    serviceTeam?: boolean | ServiceTeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceChannelOfficeTeamPair"]>

  export type ServiceChannelOfficeTeamPairSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceChannelCode?: boolean
    serviceOfficeId?: boolean
    serviceTeamCode?: boolean
    serviceChannel?: boolean | ServiceChannelDefaultArgs<ExtArgs>
    serviceOffice?: boolean | ServiceOfficeDefaultArgs<ExtArgs>
    serviceTeam?: boolean | ServiceTeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceChannelOfficeTeamPair"]>

  export type ServiceChannelOfficeTeamPairSelectScalar = {
    id?: boolean
    serviceChannelCode?: boolean
    serviceOfficeId?: boolean
    serviceTeamCode?: boolean
  }

  export type ServiceChannelOfficeTeamPairOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceChannelCode" | "serviceOfficeId" | "serviceTeamCode", ExtArgs["result"]["serviceChannelOfficeTeamPair"]>
  export type ServiceChannelOfficeTeamPairInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceChannel?: boolean | ServiceChannelDefaultArgs<ExtArgs>
    serviceOffice?: boolean | ServiceOfficeDefaultArgs<ExtArgs>
    serviceTeam?: boolean | ServiceTeamDefaultArgs<ExtArgs>
  }
  export type ServiceChannelOfficeTeamPairIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceChannel?: boolean | ServiceChannelDefaultArgs<ExtArgs>
    serviceOffice?: boolean | ServiceOfficeDefaultArgs<ExtArgs>
    serviceTeam?: boolean | ServiceTeamDefaultArgs<ExtArgs>
  }
  export type ServiceChannelOfficeTeamPairIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    serviceChannel?: boolean | ServiceChannelDefaultArgs<ExtArgs>
    serviceOffice?: boolean | ServiceOfficeDefaultArgs<ExtArgs>
    serviceTeam?: boolean | ServiceTeamDefaultArgs<ExtArgs>
  }

  export type $ServiceChannelOfficeTeamPairPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceChannelOfficeTeamPair"
    objects: {
      serviceChannel: Prisma.$ServiceChannelPayload<ExtArgs>
      serviceOffice: Prisma.$ServiceOfficePayload<ExtArgs>
      serviceTeam: Prisma.$ServiceTeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      serviceChannelCode: string
      serviceOfficeId: string
      serviceTeamCode: string
    }, ExtArgs["result"]["serviceChannelOfficeTeamPair"]>
    composites: {}
  }

  type ServiceChannelOfficeTeamPairGetPayload<S extends boolean | null | undefined | ServiceChannelOfficeTeamPairDefaultArgs> = $Result.GetResult<Prisma.$ServiceChannelOfficeTeamPairPayload, S>

  type ServiceChannelOfficeTeamPairCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceChannelOfficeTeamPairFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceChannelOfficeTeamPairCountAggregateInputType | true
    }

  export interface ServiceChannelOfficeTeamPairDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceChannelOfficeTeamPair'], meta: { name: 'ServiceChannelOfficeTeamPair' } }
    /**
     * Find zero or one ServiceChannelOfficeTeamPair that matches the filter.
     * @param {ServiceChannelOfficeTeamPairFindUniqueArgs} args - Arguments to find a ServiceChannelOfficeTeamPair
     * @example
     * // Get one ServiceChannelOfficeTeamPair
     * const serviceChannelOfficeTeamPair = await prisma.serviceChannelOfficeTeamPair.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceChannelOfficeTeamPairFindUniqueArgs>(args: SelectSubset<T, ServiceChannelOfficeTeamPairFindUniqueArgs<ExtArgs>>): Prisma__ServiceChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$ServiceChannelOfficeTeamPairPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceChannelOfficeTeamPair that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceChannelOfficeTeamPairFindUniqueOrThrowArgs} args - Arguments to find a ServiceChannelOfficeTeamPair
     * @example
     * // Get one ServiceChannelOfficeTeamPair
     * const serviceChannelOfficeTeamPair = await prisma.serviceChannelOfficeTeamPair.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceChannelOfficeTeamPairFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceChannelOfficeTeamPairFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$ServiceChannelOfficeTeamPairPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceChannelOfficeTeamPair that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChannelOfficeTeamPairFindFirstArgs} args - Arguments to find a ServiceChannelOfficeTeamPair
     * @example
     * // Get one ServiceChannelOfficeTeamPair
     * const serviceChannelOfficeTeamPair = await prisma.serviceChannelOfficeTeamPair.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceChannelOfficeTeamPairFindFirstArgs>(args?: SelectSubset<T, ServiceChannelOfficeTeamPairFindFirstArgs<ExtArgs>>): Prisma__ServiceChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$ServiceChannelOfficeTeamPairPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceChannelOfficeTeamPair that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChannelOfficeTeamPairFindFirstOrThrowArgs} args - Arguments to find a ServiceChannelOfficeTeamPair
     * @example
     * // Get one ServiceChannelOfficeTeamPair
     * const serviceChannelOfficeTeamPair = await prisma.serviceChannelOfficeTeamPair.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceChannelOfficeTeamPairFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceChannelOfficeTeamPairFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$ServiceChannelOfficeTeamPairPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceChannelOfficeTeamPairs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChannelOfficeTeamPairFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceChannelOfficeTeamPairs
     * const serviceChannelOfficeTeamPairs = await prisma.serviceChannelOfficeTeamPair.findMany()
     * 
     * // Get first 10 ServiceChannelOfficeTeamPairs
     * const serviceChannelOfficeTeamPairs = await prisma.serviceChannelOfficeTeamPair.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceChannelOfficeTeamPairWithIdOnly = await prisma.serviceChannelOfficeTeamPair.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceChannelOfficeTeamPairFindManyArgs>(args?: SelectSubset<T, ServiceChannelOfficeTeamPairFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceChannelOfficeTeamPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceChannelOfficeTeamPair.
     * @param {ServiceChannelOfficeTeamPairCreateArgs} args - Arguments to create a ServiceChannelOfficeTeamPair.
     * @example
     * // Create one ServiceChannelOfficeTeamPair
     * const ServiceChannelOfficeTeamPair = await prisma.serviceChannelOfficeTeamPair.create({
     *   data: {
     *     // ... data to create a ServiceChannelOfficeTeamPair
     *   }
     * })
     * 
     */
    create<T extends ServiceChannelOfficeTeamPairCreateArgs>(args: SelectSubset<T, ServiceChannelOfficeTeamPairCreateArgs<ExtArgs>>): Prisma__ServiceChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$ServiceChannelOfficeTeamPairPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceChannelOfficeTeamPairs.
     * @param {ServiceChannelOfficeTeamPairCreateManyArgs} args - Arguments to create many ServiceChannelOfficeTeamPairs.
     * @example
     * // Create many ServiceChannelOfficeTeamPairs
     * const serviceChannelOfficeTeamPair = await prisma.serviceChannelOfficeTeamPair.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceChannelOfficeTeamPairCreateManyArgs>(args?: SelectSubset<T, ServiceChannelOfficeTeamPairCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceChannelOfficeTeamPairs and returns the data saved in the database.
     * @param {ServiceChannelOfficeTeamPairCreateManyAndReturnArgs} args - Arguments to create many ServiceChannelOfficeTeamPairs.
     * @example
     * // Create many ServiceChannelOfficeTeamPairs
     * const serviceChannelOfficeTeamPair = await prisma.serviceChannelOfficeTeamPair.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceChannelOfficeTeamPairs and only return the `id`
     * const serviceChannelOfficeTeamPairWithIdOnly = await prisma.serviceChannelOfficeTeamPair.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceChannelOfficeTeamPairCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceChannelOfficeTeamPairCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceChannelOfficeTeamPairPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceChannelOfficeTeamPair.
     * @param {ServiceChannelOfficeTeamPairDeleteArgs} args - Arguments to delete one ServiceChannelOfficeTeamPair.
     * @example
     * // Delete one ServiceChannelOfficeTeamPair
     * const ServiceChannelOfficeTeamPair = await prisma.serviceChannelOfficeTeamPair.delete({
     *   where: {
     *     // ... filter to delete one ServiceChannelOfficeTeamPair
     *   }
     * })
     * 
     */
    delete<T extends ServiceChannelOfficeTeamPairDeleteArgs>(args: SelectSubset<T, ServiceChannelOfficeTeamPairDeleteArgs<ExtArgs>>): Prisma__ServiceChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$ServiceChannelOfficeTeamPairPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceChannelOfficeTeamPair.
     * @param {ServiceChannelOfficeTeamPairUpdateArgs} args - Arguments to update one ServiceChannelOfficeTeamPair.
     * @example
     * // Update one ServiceChannelOfficeTeamPair
     * const serviceChannelOfficeTeamPair = await prisma.serviceChannelOfficeTeamPair.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceChannelOfficeTeamPairUpdateArgs>(args: SelectSubset<T, ServiceChannelOfficeTeamPairUpdateArgs<ExtArgs>>): Prisma__ServiceChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$ServiceChannelOfficeTeamPairPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceChannelOfficeTeamPairs.
     * @param {ServiceChannelOfficeTeamPairDeleteManyArgs} args - Arguments to filter ServiceChannelOfficeTeamPairs to delete.
     * @example
     * // Delete a few ServiceChannelOfficeTeamPairs
     * const { count } = await prisma.serviceChannelOfficeTeamPair.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceChannelOfficeTeamPairDeleteManyArgs>(args?: SelectSubset<T, ServiceChannelOfficeTeamPairDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceChannelOfficeTeamPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChannelOfficeTeamPairUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceChannelOfficeTeamPairs
     * const serviceChannelOfficeTeamPair = await prisma.serviceChannelOfficeTeamPair.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceChannelOfficeTeamPairUpdateManyArgs>(args: SelectSubset<T, ServiceChannelOfficeTeamPairUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceChannelOfficeTeamPairs and returns the data updated in the database.
     * @param {ServiceChannelOfficeTeamPairUpdateManyAndReturnArgs} args - Arguments to update many ServiceChannelOfficeTeamPairs.
     * @example
     * // Update many ServiceChannelOfficeTeamPairs
     * const serviceChannelOfficeTeamPair = await prisma.serviceChannelOfficeTeamPair.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceChannelOfficeTeamPairs and only return the `id`
     * const serviceChannelOfficeTeamPairWithIdOnly = await prisma.serviceChannelOfficeTeamPair.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceChannelOfficeTeamPairUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceChannelOfficeTeamPairUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceChannelOfficeTeamPairPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceChannelOfficeTeamPair.
     * @param {ServiceChannelOfficeTeamPairUpsertArgs} args - Arguments to update or create a ServiceChannelOfficeTeamPair.
     * @example
     * // Update or create a ServiceChannelOfficeTeamPair
     * const serviceChannelOfficeTeamPair = await prisma.serviceChannelOfficeTeamPair.upsert({
     *   create: {
     *     // ... data to create a ServiceChannelOfficeTeamPair
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceChannelOfficeTeamPair we want to update
     *   }
     * })
     */
    upsert<T extends ServiceChannelOfficeTeamPairUpsertArgs>(args: SelectSubset<T, ServiceChannelOfficeTeamPairUpsertArgs<ExtArgs>>): Prisma__ServiceChannelOfficeTeamPairClient<$Result.GetResult<Prisma.$ServiceChannelOfficeTeamPairPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceChannelOfficeTeamPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChannelOfficeTeamPairCountArgs} args - Arguments to filter ServiceChannelOfficeTeamPairs to count.
     * @example
     * // Count the number of ServiceChannelOfficeTeamPairs
     * const count = await prisma.serviceChannelOfficeTeamPair.count({
     *   where: {
     *     // ... the filter for the ServiceChannelOfficeTeamPairs we want to count
     *   }
     * })
    **/
    count<T extends ServiceChannelOfficeTeamPairCountArgs>(
      args?: Subset<T, ServiceChannelOfficeTeamPairCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceChannelOfficeTeamPairCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceChannelOfficeTeamPair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChannelOfficeTeamPairAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceChannelOfficeTeamPairAggregateArgs>(args: Subset<T, ServiceChannelOfficeTeamPairAggregateArgs>): Prisma.PrismaPromise<GetServiceChannelOfficeTeamPairAggregateType<T>>

    /**
     * Group by ServiceChannelOfficeTeamPair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceChannelOfficeTeamPairGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceChannelOfficeTeamPairGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceChannelOfficeTeamPairGroupByArgs['orderBy'] }
        : { orderBy?: ServiceChannelOfficeTeamPairGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceChannelOfficeTeamPairGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceChannelOfficeTeamPairGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceChannelOfficeTeamPair model
   */
  readonly fields: ServiceChannelOfficeTeamPairFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceChannelOfficeTeamPair.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceChannelOfficeTeamPairClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    serviceChannel<T extends ServiceChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceChannelDefaultArgs<ExtArgs>>): Prisma__ServiceChannelClient<$Result.GetResult<Prisma.$ServiceChannelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceOffice<T extends ServiceOfficeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceOfficeDefaultArgs<ExtArgs>>): Prisma__ServiceOfficeClient<$Result.GetResult<Prisma.$ServiceOfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceTeam<T extends ServiceTeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceTeamDefaultArgs<ExtArgs>>): Prisma__ServiceTeamClient<$Result.GetResult<Prisma.$ServiceTeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceChannelOfficeTeamPair model
   */
  interface ServiceChannelOfficeTeamPairFieldRefs {
    readonly id: FieldRef<"ServiceChannelOfficeTeamPair", 'Int'>
    readonly serviceChannelCode: FieldRef<"ServiceChannelOfficeTeamPair", 'String'>
    readonly serviceOfficeId: FieldRef<"ServiceChannelOfficeTeamPair", 'String'>
    readonly serviceTeamCode: FieldRef<"ServiceChannelOfficeTeamPair", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceChannelOfficeTeamPair findUnique
   */
  export type ServiceChannelOfficeTeamPairFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannelOfficeTeamPair
     */
    select?: ServiceChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannelOfficeTeamPair
     */
    omit?: ServiceChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * Filter, which ServiceChannelOfficeTeamPair to fetch.
     */
    where: ServiceChannelOfficeTeamPairWhereUniqueInput
  }

  /**
   * ServiceChannelOfficeTeamPair findUniqueOrThrow
   */
  export type ServiceChannelOfficeTeamPairFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannelOfficeTeamPair
     */
    select?: ServiceChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannelOfficeTeamPair
     */
    omit?: ServiceChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * Filter, which ServiceChannelOfficeTeamPair to fetch.
     */
    where: ServiceChannelOfficeTeamPairWhereUniqueInput
  }

  /**
   * ServiceChannelOfficeTeamPair findFirst
   */
  export type ServiceChannelOfficeTeamPairFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannelOfficeTeamPair
     */
    select?: ServiceChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannelOfficeTeamPair
     */
    omit?: ServiceChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * Filter, which ServiceChannelOfficeTeamPair to fetch.
     */
    where?: ServiceChannelOfficeTeamPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceChannelOfficeTeamPairs to fetch.
     */
    orderBy?: ServiceChannelOfficeTeamPairOrderByWithRelationInput | ServiceChannelOfficeTeamPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceChannelOfficeTeamPairs.
     */
    cursor?: ServiceChannelOfficeTeamPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceChannelOfficeTeamPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceChannelOfficeTeamPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceChannelOfficeTeamPairs.
     */
    distinct?: ServiceChannelOfficeTeamPairScalarFieldEnum | ServiceChannelOfficeTeamPairScalarFieldEnum[]
  }

  /**
   * ServiceChannelOfficeTeamPair findFirstOrThrow
   */
  export type ServiceChannelOfficeTeamPairFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannelOfficeTeamPair
     */
    select?: ServiceChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannelOfficeTeamPair
     */
    omit?: ServiceChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * Filter, which ServiceChannelOfficeTeamPair to fetch.
     */
    where?: ServiceChannelOfficeTeamPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceChannelOfficeTeamPairs to fetch.
     */
    orderBy?: ServiceChannelOfficeTeamPairOrderByWithRelationInput | ServiceChannelOfficeTeamPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceChannelOfficeTeamPairs.
     */
    cursor?: ServiceChannelOfficeTeamPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceChannelOfficeTeamPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceChannelOfficeTeamPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceChannelOfficeTeamPairs.
     */
    distinct?: ServiceChannelOfficeTeamPairScalarFieldEnum | ServiceChannelOfficeTeamPairScalarFieldEnum[]
  }

  /**
   * ServiceChannelOfficeTeamPair findMany
   */
  export type ServiceChannelOfficeTeamPairFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannelOfficeTeamPair
     */
    select?: ServiceChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannelOfficeTeamPair
     */
    omit?: ServiceChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * Filter, which ServiceChannelOfficeTeamPairs to fetch.
     */
    where?: ServiceChannelOfficeTeamPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceChannelOfficeTeamPairs to fetch.
     */
    orderBy?: ServiceChannelOfficeTeamPairOrderByWithRelationInput | ServiceChannelOfficeTeamPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceChannelOfficeTeamPairs.
     */
    cursor?: ServiceChannelOfficeTeamPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceChannelOfficeTeamPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceChannelOfficeTeamPairs.
     */
    skip?: number
    distinct?: ServiceChannelOfficeTeamPairScalarFieldEnum | ServiceChannelOfficeTeamPairScalarFieldEnum[]
  }

  /**
   * ServiceChannelOfficeTeamPair create
   */
  export type ServiceChannelOfficeTeamPairCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannelOfficeTeamPair
     */
    select?: ServiceChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannelOfficeTeamPair
     */
    omit?: ServiceChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceChannelOfficeTeamPair.
     */
    data: XOR<ServiceChannelOfficeTeamPairCreateInput, ServiceChannelOfficeTeamPairUncheckedCreateInput>
  }

  /**
   * ServiceChannelOfficeTeamPair createMany
   */
  export type ServiceChannelOfficeTeamPairCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceChannelOfficeTeamPairs.
     */
    data: ServiceChannelOfficeTeamPairCreateManyInput | ServiceChannelOfficeTeamPairCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceChannelOfficeTeamPair createManyAndReturn
   */
  export type ServiceChannelOfficeTeamPairCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannelOfficeTeamPair
     */
    select?: ServiceChannelOfficeTeamPairSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannelOfficeTeamPair
     */
    omit?: ServiceChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceChannelOfficeTeamPairs.
     */
    data: ServiceChannelOfficeTeamPairCreateManyInput | ServiceChannelOfficeTeamPairCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelOfficeTeamPairIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceChannelOfficeTeamPair update
   */
  export type ServiceChannelOfficeTeamPairUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannelOfficeTeamPair
     */
    select?: ServiceChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannelOfficeTeamPair
     */
    omit?: ServiceChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceChannelOfficeTeamPair.
     */
    data: XOR<ServiceChannelOfficeTeamPairUpdateInput, ServiceChannelOfficeTeamPairUncheckedUpdateInput>
    /**
     * Choose, which ServiceChannelOfficeTeamPair to update.
     */
    where: ServiceChannelOfficeTeamPairWhereUniqueInput
  }

  /**
   * ServiceChannelOfficeTeamPair updateMany
   */
  export type ServiceChannelOfficeTeamPairUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceChannelOfficeTeamPairs.
     */
    data: XOR<ServiceChannelOfficeTeamPairUpdateManyMutationInput, ServiceChannelOfficeTeamPairUncheckedUpdateManyInput>
    /**
     * Filter which ServiceChannelOfficeTeamPairs to update
     */
    where?: ServiceChannelOfficeTeamPairWhereInput
    /**
     * Limit how many ServiceChannelOfficeTeamPairs to update.
     */
    limit?: number
  }

  /**
   * ServiceChannelOfficeTeamPair updateManyAndReturn
   */
  export type ServiceChannelOfficeTeamPairUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannelOfficeTeamPair
     */
    select?: ServiceChannelOfficeTeamPairSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannelOfficeTeamPair
     */
    omit?: ServiceChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * The data used to update ServiceChannelOfficeTeamPairs.
     */
    data: XOR<ServiceChannelOfficeTeamPairUpdateManyMutationInput, ServiceChannelOfficeTeamPairUncheckedUpdateManyInput>
    /**
     * Filter which ServiceChannelOfficeTeamPairs to update
     */
    where?: ServiceChannelOfficeTeamPairWhereInput
    /**
     * Limit how many ServiceChannelOfficeTeamPairs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelOfficeTeamPairIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceChannelOfficeTeamPair upsert
   */
  export type ServiceChannelOfficeTeamPairUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannelOfficeTeamPair
     */
    select?: ServiceChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannelOfficeTeamPair
     */
    omit?: ServiceChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceChannelOfficeTeamPair to update in case it exists.
     */
    where: ServiceChannelOfficeTeamPairWhereUniqueInput
    /**
     * In case the ServiceChannelOfficeTeamPair found by the `where` argument doesn't exist, create a new ServiceChannelOfficeTeamPair with this data.
     */
    create: XOR<ServiceChannelOfficeTeamPairCreateInput, ServiceChannelOfficeTeamPairUncheckedCreateInput>
    /**
     * In case the ServiceChannelOfficeTeamPair was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceChannelOfficeTeamPairUpdateInput, ServiceChannelOfficeTeamPairUncheckedUpdateInput>
  }

  /**
   * ServiceChannelOfficeTeamPair delete
   */
  export type ServiceChannelOfficeTeamPairDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannelOfficeTeamPair
     */
    select?: ServiceChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannelOfficeTeamPair
     */
    omit?: ServiceChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelOfficeTeamPairInclude<ExtArgs> | null
    /**
     * Filter which ServiceChannelOfficeTeamPair to delete.
     */
    where: ServiceChannelOfficeTeamPairWhereUniqueInput
  }

  /**
   * ServiceChannelOfficeTeamPair deleteMany
   */
  export type ServiceChannelOfficeTeamPairDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceChannelOfficeTeamPairs to delete
     */
    where?: ServiceChannelOfficeTeamPairWhereInput
    /**
     * Limit how many ServiceChannelOfficeTeamPairs to delete.
     */
    limit?: number
  }

  /**
   * ServiceChannelOfficeTeamPair without action
   */
  export type ServiceChannelOfficeTeamPairDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceChannelOfficeTeamPair
     */
    select?: ServiceChannelOfficeTeamPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceChannelOfficeTeamPair
     */
    omit?: ServiceChannelOfficeTeamPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceChannelOfficeTeamPairInclude<ExtArgs> | null
  }


  /**
   * Model BusinessUnitSalesPair
   */

  export type AggregateBusinessUnitSalesPair = {
    _count: BusinessUnitSalesPairCountAggregateOutputType | null
    _min: BusinessUnitSalesPairMinAggregateOutputType | null
    _max: BusinessUnitSalesPairMaxAggregateOutputType | null
  }

  export type BusinessUnitSalesPairMinAggregateOutputType = {
    id: string | null
    businessUnitCode: string | null
    salesChannelCode: string | null
    salesOfficeId: string | null
    salesTeamCode: string | null
  }

  export type BusinessUnitSalesPairMaxAggregateOutputType = {
    id: string | null
    businessUnitCode: string | null
    salesChannelCode: string | null
    salesOfficeId: string | null
    salesTeamCode: string | null
  }

  export type BusinessUnitSalesPairCountAggregateOutputType = {
    id: number
    businessUnitCode: number
    salesChannelCode: number
    salesOfficeId: number
    salesTeamCode: number
    _all: number
  }


  export type BusinessUnitSalesPairMinAggregateInputType = {
    id?: true
    businessUnitCode?: true
    salesChannelCode?: true
    salesOfficeId?: true
    salesTeamCode?: true
  }

  export type BusinessUnitSalesPairMaxAggregateInputType = {
    id?: true
    businessUnitCode?: true
    salesChannelCode?: true
    salesOfficeId?: true
    salesTeamCode?: true
  }

  export type BusinessUnitSalesPairCountAggregateInputType = {
    id?: true
    businessUnitCode?: true
    salesChannelCode?: true
    salesOfficeId?: true
    salesTeamCode?: true
    _all?: true
  }

  export type BusinessUnitSalesPairAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessUnitSalesPair to aggregate.
     */
    where?: BusinessUnitSalesPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnitSalesPairs to fetch.
     */
    orderBy?: BusinessUnitSalesPairOrderByWithRelationInput | BusinessUnitSalesPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessUnitSalesPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnitSalesPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnitSalesPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessUnitSalesPairs
    **/
    _count?: true | BusinessUnitSalesPairCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessUnitSalesPairMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessUnitSalesPairMaxAggregateInputType
  }

  export type GetBusinessUnitSalesPairAggregateType<T extends BusinessUnitSalesPairAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessUnitSalesPair]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessUnitSalesPair[P]>
      : GetScalarType<T[P], AggregateBusinessUnitSalesPair[P]>
  }




  export type BusinessUnitSalesPairGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitSalesPairWhereInput
    orderBy?: BusinessUnitSalesPairOrderByWithAggregationInput | BusinessUnitSalesPairOrderByWithAggregationInput[]
    by: BusinessUnitSalesPairScalarFieldEnum[] | BusinessUnitSalesPairScalarFieldEnum
    having?: BusinessUnitSalesPairScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessUnitSalesPairCountAggregateInputType | true
    _min?: BusinessUnitSalesPairMinAggregateInputType
    _max?: BusinessUnitSalesPairMaxAggregateInputType
  }

  export type BusinessUnitSalesPairGroupByOutputType = {
    id: string
    businessUnitCode: string
    salesChannelCode: string
    salesOfficeId: string
    salesTeamCode: string
    _count: BusinessUnitSalesPairCountAggregateOutputType | null
    _min: BusinessUnitSalesPairMinAggregateOutputType | null
    _max: BusinessUnitSalesPairMaxAggregateOutputType | null
  }

  type GetBusinessUnitSalesPairGroupByPayload<T extends BusinessUnitSalesPairGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessUnitSalesPairGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessUnitSalesPairGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessUnitSalesPairGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessUnitSalesPairGroupByOutputType[P]>
        }
      >
    >


  export type BusinessUnitSalesPairSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessUnitCode?: boolean
    salesChannelCode?: boolean
    salesOfficeId?: boolean
    salesTeamCode?: boolean
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
    salesChannel?: boolean | SalesChannelDefaultArgs<ExtArgs>
    salesOffice?: boolean | SalesOfficeDefaultArgs<ExtArgs>
    salesTeam?: boolean | SalesTeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessUnitSalesPair"]>

  export type BusinessUnitSalesPairSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessUnitCode?: boolean
    salesChannelCode?: boolean
    salesOfficeId?: boolean
    salesTeamCode?: boolean
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
    salesChannel?: boolean | SalesChannelDefaultArgs<ExtArgs>
    salesOffice?: boolean | SalesOfficeDefaultArgs<ExtArgs>
    salesTeam?: boolean | SalesTeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessUnitSalesPair"]>

  export type BusinessUnitSalesPairSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessUnitCode?: boolean
    salesChannelCode?: boolean
    salesOfficeId?: boolean
    salesTeamCode?: boolean
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
    salesChannel?: boolean | SalesChannelDefaultArgs<ExtArgs>
    salesOffice?: boolean | SalesOfficeDefaultArgs<ExtArgs>
    salesTeam?: boolean | SalesTeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessUnitSalesPair"]>

  export type BusinessUnitSalesPairSelectScalar = {
    id?: boolean
    businessUnitCode?: boolean
    salesChannelCode?: boolean
    salesOfficeId?: boolean
    salesTeamCode?: boolean
  }

  export type BusinessUnitSalesPairOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "businessUnitCode" | "salesChannelCode" | "salesOfficeId" | "salesTeamCode", ExtArgs["result"]["businessUnitSalesPair"]>
  export type BusinessUnitSalesPairInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
    salesChannel?: boolean | SalesChannelDefaultArgs<ExtArgs>
    salesOffice?: boolean | SalesOfficeDefaultArgs<ExtArgs>
    salesTeam?: boolean | SalesTeamDefaultArgs<ExtArgs>
  }
  export type BusinessUnitSalesPairIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
    salesChannel?: boolean | SalesChannelDefaultArgs<ExtArgs>
    salesOffice?: boolean | SalesOfficeDefaultArgs<ExtArgs>
    salesTeam?: boolean | SalesTeamDefaultArgs<ExtArgs>
  }
  export type BusinessUnitSalesPairIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
    salesChannel?: boolean | SalesChannelDefaultArgs<ExtArgs>
    salesOffice?: boolean | SalesOfficeDefaultArgs<ExtArgs>
    salesTeam?: boolean | SalesTeamDefaultArgs<ExtArgs>
  }

  export type $BusinessUnitSalesPairPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessUnitSalesPair"
    objects: {
      businessUnit: Prisma.$BusinessUnitPayload<ExtArgs>
      salesChannel: Prisma.$SalesChannelPayload<ExtArgs>
      salesOffice: Prisma.$SalesOfficePayload<ExtArgs>
      salesTeam: Prisma.$SalesTeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessUnitCode: string
      salesChannelCode: string
      salesOfficeId: string
      salesTeamCode: string
    }, ExtArgs["result"]["businessUnitSalesPair"]>
    composites: {}
  }

  type BusinessUnitSalesPairGetPayload<S extends boolean | null | undefined | BusinessUnitSalesPairDefaultArgs> = $Result.GetResult<Prisma.$BusinessUnitSalesPairPayload, S>

  type BusinessUnitSalesPairCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BusinessUnitSalesPairFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BusinessUnitSalesPairCountAggregateInputType | true
    }

  export interface BusinessUnitSalesPairDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessUnitSalesPair'], meta: { name: 'BusinessUnitSalesPair' } }
    /**
     * Find zero or one BusinessUnitSalesPair that matches the filter.
     * @param {BusinessUnitSalesPairFindUniqueArgs} args - Arguments to find a BusinessUnitSalesPair
     * @example
     * // Get one BusinessUnitSalesPair
     * const businessUnitSalesPair = await prisma.businessUnitSalesPair.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessUnitSalesPairFindUniqueArgs>(args: SelectSubset<T, BusinessUnitSalesPairFindUniqueArgs<ExtArgs>>): Prisma__BusinessUnitSalesPairClient<$Result.GetResult<Prisma.$BusinessUnitSalesPairPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BusinessUnitSalesPair that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BusinessUnitSalesPairFindUniqueOrThrowArgs} args - Arguments to find a BusinessUnitSalesPair
     * @example
     * // Get one BusinessUnitSalesPair
     * const businessUnitSalesPair = await prisma.businessUnitSalesPair.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessUnitSalesPairFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessUnitSalesPairFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessUnitSalesPairClient<$Result.GetResult<Prisma.$BusinessUnitSalesPairPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessUnitSalesPair that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitSalesPairFindFirstArgs} args - Arguments to find a BusinessUnitSalesPair
     * @example
     * // Get one BusinessUnitSalesPair
     * const businessUnitSalesPair = await prisma.businessUnitSalesPair.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessUnitSalesPairFindFirstArgs>(args?: SelectSubset<T, BusinessUnitSalesPairFindFirstArgs<ExtArgs>>): Prisma__BusinessUnitSalesPairClient<$Result.GetResult<Prisma.$BusinessUnitSalesPairPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessUnitSalesPair that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitSalesPairFindFirstOrThrowArgs} args - Arguments to find a BusinessUnitSalesPair
     * @example
     * // Get one BusinessUnitSalesPair
     * const businessUnitSalesPair = await prisma.businessUnitSalesPair.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessUnitSalesPairFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessUnitSalesPairFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessUnitSalesPairClient<$Result.GetResult<Prisma.$BusinessUnitSalesPairPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BusinessUnitSalesPairs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitSalesPairFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessUnitSalesPairs
     * const businessUnitSalesPairs = await prisma.businessUnitSalesPair.findMany()
     * 
     * // Get first 10 BusinessUnitSalesPairs
     * const businessUnitSalesPairs = await prisma.businessUnitSalesPair.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessUnitSalesPairWithIdOnly = await prisma.businessUnitSalesPair.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessUnitSalesPairFindManyArgs>(args?: SelectSubset<T, BusinessUnitSalesPairFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitSalesPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BusinessUnitSalesPair.
     * @param {BusinessUnitSalesPairCreateArgs} args - Arguments to create a BusinessUnitSalesPair.
     * @example
     * // Create one BusinessUnitSalesPair
     * const BusinessUnitSalesPair = await prisma.businessUnitSalesPair.create({
     *   data: {
     *     // ... data to create a BusinessUnitSalesPair
     *   }
     * })
     * 
     */
    create<T extends BusinessUnitSalesPairCreateArgs>(args: SelectSubset<T, BusinessUnitSalesPairCreateArgs<ExtArgs>>): Prisma__BusinessUnitSalesPairClient<$Result.GetResult<Prisma.$BusinessUnitSalesPairPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BusinessUnitSalesPairs.
     * @param {BusinessUnitSalesPairCreateManyArgs} args - Arguments to create many BusinessUnitSalesPairs.
     * @example
     * // Create many BusinessUnitSalesPairs
     * const businessUnitSalesPair = await prisma.businessUnitSalesPair.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessUnitSalesPairCreateManyArgs>(args?: SelectSubset<T, BusinessUnitSalesPairCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessUnitSalesPairs and returns the data saved in the database.
     * @param {BusinessUnitSalesPairCreateManyAndReturnArgs} args - Arguments to create many BusinessUnitSalesPairs.
     * @example
     * // Create many BusinessUnitSalesPairs
     * const businessUnitSalesPair = await prisma.businessUnitSalesPair.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessUnitSalesPairs and only return the `id`
     * const businessUnitSalesPairWithIdOnly = await prisma.businessUnitSalesPair.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessUnitSalesPairCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessUnitSalesPairCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitSalesPairPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BusinessUnitSalesPair.
     * @param {BusinessUnitSalesPairDeleteArgs} args - Arguments to delete one BusinessUnitSalesPair.
     * @example
     * // Delete one BusinessUnitSalesPair
     * const BusinessUnitSalesPair = await prisma.businessUnitSalesPair.delete({
     *   where: {
     *     // ... filter to delete one BusinessUnitSalesPair
     *   }
     * })
     * 
     */
    delete<T extends BusinessUnitSalesPairDeleteArgs>(args: SelectSubset<T, BusinessUnitSalesPairDeleteArgs<ExtArgs>>): Prisma__BusinessUnitSalesPairClient<$Result.GetResult<Prisma.$BusinessUnitSalesPairPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BusinessUnitSalesPair.
     * @param {BusinessUnitSalesPairUpdateArgs} args - Arguments to update one BusinessUnitSalesPair.
     * @example
     * // Update one BusinessUnitSalesPair
     * const businessUnitSalesPair = await prisma.businessUnitSalesPair.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessUnitSalesPairUpdateArgs>(args: SelectSubset<T, BusinessUnitSalesPairUpdateArgs<ExtArgs>>): Prisma__BusinessUnitSalesPairClient<$Result.GetResult<Prisma.$BusinessUnitSalesPairPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BusinessUnitSalesPairs.
     * @param {BusinessUnitSalesPairDeleteManyArgs} args - Arguments to filter BusinessUnitSalesPairs to delete.
     * @example
     * // Delete a few BusinessUnitSalesPairs
     * const { count } = await prisma.businessUnitSalesPair.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessUnitSalesPairDeleteManyArgs>(args?: SelectSubset<T, BusinessUnitSalesPairDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessUnitSalesPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitSalesPairUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessUnitSalesPairs
     * const businessUnitSalesPair = await prisma.businessUnitSalesPair.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessUnitSalesPairUpdateManyArgs>(args: SelectSubset<T, BusinessUnitSalesPairUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessUnitSalesPairs and returns the data updated in the database.
     * @param {BusinessUnitSalesPairUpdateManyAndReturnArgs} args - Arguments to update many BusinessUnitSalesPairs.
     * @example
     * // Update many BusinessUnitSalesPairs
     * const businessUnitSalesPair = await prisma.businessUnitSalesPair.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BusinessUnitSalesPairs and only return the `id`
     * const businessUnitSalesPairWithIdOnly = await prisma.businessUnitSalesPair.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BusinessUnitSalesPairUpdateManyAndReturnArgs>(args: SelectSubset<T, BusinessUnitSalesPairUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitSalesPairPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BusinessUnitSalesPair.
     * @param {BusinessUnitSalesPairUpsertArgs} args - Arguments to update or create a BusinessUnitSalesPair.
     * @example
     * // Update or create a BusinessUnitSalesPair
     * const businessUnitSalesPair = await prisma.businessUnitSalesPair.upsert({
     *   create: {
     *     // ... data to create a BusinessUnitSalesPair
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessUnitSalesPair we want to update
     *   }
     * })
     */
    upsert<T extends BusinessUnitSalesPairUpsertArgs>(args: SelectSubset<T, BusinessUnitSalesPairUpsertArgs<ExtArgs>>): Prisma__BusinessUnitSalesPairClient<$Result.GetResult<Prisma.$BusinessUnitSalesPairPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BusinessUnitSalesPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitSalesPairCountArgs} args - Arguments to filter BusinessUnitSalesPairs to count.
     * @example
     * // Count the number of BusinessUnitSalesPairs
     * const count = await prisma.businessUnitSalesPair.count({
     *   where: {
     *     // ... the filter for the BusinessUnitSalesPairs we want to count
     *   }
     * })
    **/
    count<T extends BusinessUnitSalesPairCountArgs>(
      args?: Subset<T, BusinessUnitSalesPairCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessUnitSalesPairCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessUnitSalesPair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitSalesPairAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessUnitSalesPairAggregateArgs>(args: Subset<T, BusinessUnitSalesPairAggregateArgs>): Prisma.PrismaPromise<GetBusinessUnitSalesPairAggregateType<T>>

    /**
     * Group by BusinessUnitSalesPair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitSalesPairGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessUnitSalesPairGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessUnitSalesPairGroupByArgs['orderBy'] }
        : { orderBy?: BusinessUnitSalesPairGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessUnitSalesPairGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessUnitSalesPairGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessUnitSalesPair model
   */
  readonly fields: BusinessUnitSalesPairFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessUnitSalesPair.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessUnitSalesPairClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessUnit<T extends BusinessUnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessUnitDefaultArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    salesChannel<T extends SalesChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesChannelDefaultArgs<ExtArgs>>): Prisma__SalesChannelClient<$Result.GetResult<Prisma.$SalesChannelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    salesOffice<T extends SalesOfficeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesOfficeDefaultArgs<ExtArgs>>): Prisma__SalesOfficeClient<$Result.GetResult<Prisma.$SalesOfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    salesTeam<T extends SalesTeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesTeamDefaultArgs<ExtArgs>>): Prisma__SalesTeamClient<$Result.GetResult<Prisma.$SalesTeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessUnitSalesPair model
   */
  interface BusinessUnitSalesPairFieldRefs {
    readonly id: FieldRef<"BusinessUnitSalesPair", 'String'>
    readonly businessUnitCode: FieldRef<"BusinessUnitSalesPair", 'String'>
    readonly salesChannelCode: FieldRef<"BusinessUnitSalesPair", 'String'>
    readonly salesOfficeId: FieldRef<"BusinessUnitSalesPair", 'String'>
    readonly salesTeamCode: FieldRef<"BusinessUnitSalesPair", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BusinessUnitSalesPair findUnique
   */
  export type BusinessUnitSalesPairFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSalesPair
     */
    select?: BusinessUnitSalesPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitSalesPair
     */
    omit?: BusinessUnitSalesPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSalesPairInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnitSalesPair to fetch.
     */
    where: BusinessUnitSalesPairWhereUniqueInput
  }

  /**
   * BusinessUnitSalesPair findUniqueOrThrow
   */
  export type BusinessUnitSalesPairFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSalesPair
     */
    select?: BusinessUnitSalesPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitSalesPair
     */
    omit?: BusinessUnitSalesPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSalesPairInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnitSalesPair to fetch.
     */
    where: BusinessUnitSalesPairWhereUniqueInput
  }

  /**
   * BusinessUnitSalesPair findFirst
   */
  export type BusinessUnitSalesPairFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSalesPair
     */
    select?: BusinessUnitSalesPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitSalesPair
     */
    omit?: BusinessUnitSalesPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSalesPairInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnitSalesPair to fetch.
     */
    where?: BusinessUnitSalesPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnitSalesPairs to fetch.
     */
    orderBy?: BusinessUnitSalesPairOrderByWithRelationInput | BusinessUnitSalesPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessUnitSalesPairs.
     */
    cursor?: BusinessUnitSalesPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnitSalesPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnitSalesPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessUnitSalesPairs.
     */
    distinct?: BusinessUnitSalesPairScalarFieldEnum | BusinessUnitSalesPairScalarFieldEnum[]
  }

  /**
   * BusinessUnitSalesPair findFirstOrThrow
   */
  export type BusinessUnitSalesPairFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSalesPair
     */
    select?: BusinessUnitSalesPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitSalesPair
     */
    omit?: BusinessUnitSalesPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSalesPairInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnitSalesPair to fetch.
     */
    where?: BusinessUnitSalesPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnitSalesPairs to fetch.
     */
    orderBy?: BusinessUnitSalesPairOrderByWithRelationInput | BusinessUnitSalesPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessUnitSalesPairs.
     */
    cursor?: BusinessUnitSalesPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnitSalesPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnitSalesPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessUnitSalesPairs.
     */
    distinct?: BusinessUnitSalesPairScalarFieldEnum | BusinessUnitSalesPairScalarFieldEnum[]
  }

  /**
   * BusinessUnitSalesPair findMany
   */
  export type BusinessUnitSalesPairFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSalesPair
     */
    select?: BusinessUnitSalesPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitSalesPair
     */
    omit?: BusinessUnitSalesPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSalesPairInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnitSalesPairs to fetch.
     */
    where?: BusinessUnitSalesPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnitSalesPairs to fetch.
     */
    orderBy?: BusinessUnitSalesPairOrderByWithRelationInput | BusinessUnitSalesPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessUnitSalesPairs.
     */
    cursor?: BusinessUnitSalesPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnitSalesPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnitSalesPairs.
     */
    skip?: number
    distinct?: BusinessUnitSalesPairScalarFieldEnum | BusinessUnitSalesPairScalarFieldEnum[]
  }

  /**
   * BusinessUnitSalesPair create
   */
  export type BusinessUnitSalesPairCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSalesPair
     */
    select?: BusinessUnitSalesPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitSalesPair
     */
    omit?: BusinessUnitSalesPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSalesPairInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessUnitSalesPair.
     */
    data: XOR<BusinessUnitSalesPairCreateInput, BusinessUnitSalesPairUncheckedCreateInput>
  }

  /**
   * BusinessUnitSalesPair createMany
   */
  export type BusinessUnitSalesPairCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessUnitSalesPairs.
     */
    data: BusinessUnitSalesPairCreateManyInput | BusinessUnitSalesPairCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessUnitSalesPair createManyAndReturn
   */
  export type BusinessUnitSalesPairCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSalesPair
     */
    select?: BusinessUnitSalesPairSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitSalesPair
     */
    omit?: BusinessUnitSalesPairOmit<ExtArgs> | null
    /**
     * The data used to create many BusinessUnitSalesPairs.
     */
    data: BusinessUnitSalesPairCreateManyInput | BusinessUnitSalesPairCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSalesPairIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessUnitSalesPair update
   */
  export type BusinessUnitSalesPairUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSalesPair
     */
    select?: BusinessUnitSalesPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitSalesPair
     */
    omit?: BusinessUnitSalesPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSalesPairInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessUnitSalesPair.
     */
    data: XOR<BusinessUnitSalesPairUpdateInput, BusinessUnitSalesPairUncheckedUpdateInput>
    /**
     * Choose, which BusinessUnitSalesPair to update.
     */
    where: BusinessUnitSalesPairWhereUniqueInput
  }

  /**
   * BusinessUnitSalesPair updateMany
   */
  export type BusinessUnitSalesPairUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessUnitSalesPairs.
     */
    data: XOR<BusinessUnitSalesPairUpdateManyMutationInput, BusinessUnitSalesPairUncheckedUpdateManyInput>
    /**
     * Filter which BusinessUnitSalesPairs to update
     */
    where?: BusinessUnitSalesPairWhereInput
    /**
     * Limit how many BusinessUnitSalesPairs to update.
     */
    limit?: number
  }

  /**
   * BusinessUnitSalesPair updateManyAndReturn
   */
  export type BusinessUnitSalesPairUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSalesPair
     */
    select?: BusinessUnitSalesPairSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitSalesPair
     */
    omit?: BusinessUnitSalesPairOmit<ExtArgs> | null
    /**
     * The data used to update BusinessUnitSalesPairs.
     */
    data: XOR<BusinessUnitSalesPairUpdateManyMutationInput, BusinessUnitSalesPairUncheckedUpdateManyInput>
    /**
     * Filter which BusinessUnitSalesPairs to update
     */
    where?: BusinessUnitSalesPairWhereInput
    /**
     * Limit how many BusinessUnitSalesPairs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSalesPairIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessUnitSalesPair upsert
   */
  export type BusinessUnitSalesPairUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSalesPair
     */
    select?: BusinessUnitSalesPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitSalesPair
     */
    omit?: BusinessUnitSalesPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSalesPairInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessUnitSalesPair to update in case it exists.
     */
    where: BusinessUnitSalesPairWhereUniqueInput
    /**
     * In case the BusinessUnitSalesPair found by the `where` argument doesn't exist, create a new BusinessUnitSalesPair with this data.
     */
    create: XOR<BusinessUnitSalesPairCreateInput, BusinessUnitSalesPairUncheckedCreateInput>
    /**
     * In case the BusinessUnitSalesPair was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessUnitSalesPairUpdateInput, BusinessUnitSalesPairUncheckedUpdateInput>
  }

  /**
   * BusinessUnitSalesPair delete
   */
  export type BusinessUnitSalesPairDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSalesPair
     */
    select?: BusinessUnitSalesPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitSalesPair
     */
    omit?: BusinessUnitSalesPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSalesPairInclude<ExtArgs> | null
    /**
     * Filter which BusinessUnitSalesPair to delete.
     */
    where: BusinessUnitSalesPairWhereUniqueInput
  }

  /**
   * BusinessUnitSalesPair deleteMany
   */
  export type BusinessUnitSalesPairDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessUnitSalesPairs to delete
     */
    where?: BusinessUnitSalesPairWhereInput
    /**
     * Limit how many BusinessUnitSalesPairs to delete.
     */
    limit?: number
  }

  /**
   * BusinessUnitSalesPair without action
   */
  export type BusinessUnitSalesPairDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitSalesPair
     */
    select?: BusinessUnitSalesPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitSalesPair
     */
    omit?: BusinessUnitSalesPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitSalesPairInclude<ExtArgs> | null
  }


  /**
   * Model BusinessUnitMarketingPair
   */

  export type AggregateBusinessUnitMarketingPair = {
    _count: BusinessUnitMarketingPairCountAggregateOutputType | null
    _min: BusinessUnitMarketingPairMinAggregateOutputType | null
    _max: BusinessUnitMarketingPairMaxAggregateOutputType | null
  }

  export type BusinessUnitMarketingPairMinAggregateOutputType = {
    id: string | null
    businessUnitCode: string | null
    marketingChannelCode: string | null
    marketingOfficeId: string | null
    marketingTeamCode: string | null
  }

  export type BusinessUnitMarketingPairMaxAggregateOutputType = {
    id: string | null
    businessUnitCode: string | null
    marketingChannelCode: string | null
    marketingOfficeId: string | null
    marketingTeamCode: string | null
  }

  export type BusinessUnitMarketingPairCountAggregateOutputType = {
    id: number
    businessUnitCode: number
    marketingChannelCode: number
    marketingOfficeId: number
    marketingTeamCode: number
    _all: number
  }


  export type BusinessUnitMarketingPairMinAggregateInputType = {
    id?: true
    businessUnitCode?: true
    marketingChannelCode?: true
    marketingOfficeId?: true
    marketingTeamCode?: true
  }

  export type BusinessUnitMarketingPairMaxAggregateInputType = {
    id?: true
    businessUnitCode?: true
    marketingChannelCode?: true
    marketingOfficeId?: true
    marketingTeamCode?: true
  }

  export type BusinessUnitMarketingPairCountAggregateInputType = {
    id?: true
    businessUnitCode?: true
    marketingChannelCode?: true
    marketingOfficeId?: true
    marketingTeamCode?: true
    _all?: true
  }

  export type BusinessUnitMarketingPairAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessUnitMarketingPair to aggregate.
     */
    where?: BusinessUnitMarketingPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnitMarketingPairs to fetch.
     */
    orderBy?: BusinessUnitMarketingPairOrderByWithRelationInput | BusinessUnitMarketingPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessUnitMarketingPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnitMarketingPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnitMarketingPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessUnitMarketingPairs
    **/
    _count?: true | BusinessUnitMarketingPairCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessUnitMarketingPairMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessUnitMarketingPairMaxAggregateInputType
  }

  export type GetBusinessUnitMarketingPairAggregateType<T extends BusinessUnitMarketingPairAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessUnitMarketingPair]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessUnitMarketingPair[P]>
      : GetScalarType<T[P], AggregateBusinessUnitMarketingPair[P]>
  }




  export type BusinessUnitMarketingPairGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitMarketingPairWhereInput
    orderBy?: BusinessUnitMarketingPairOrderByWithAggregationInput | BusinessUnitMarketingPairOrderByWithAggregationInput[]
    by: BusinessUnitMarketingPairScalarFieldEnum[] | BusinessUnitMarketingPairScalarFieldEnum
    having?: BusinessUnitMarketingPairScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessUnitMarketingPairCountAggregateInputType | true
    _min?: BusinessUnitMarketingPairMinAggregateInputType
    _max?: BusinessUnitMarketingPairMaxAggregateInputType
  }

  export type BusinessUnitMarketingPairGroupByOutputType = {
    id: string
    businessUnitCode: string
    marketingChannelCode: string
    marketingOfficeId: string
    marketingTeamCode: string
    _count: BusinessUnitMarketingPairCountAggregateOutputType | null
    _min: BusinessUnitMarketingPairMinAggregateOutputType | null
    _max: BusinessUnitMarketingPairMaxAggregateOutputType | null
  }

  type GetBusinessUnitMarketingPairGroupByPayload<T extends BusinessUnitMarketingPairGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessUnitMarketingPairGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessUnitMarketingPairGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessUnitMarketingPairGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessUnitMarketingPairGroupByOutputType[P]>
        }
      >
    >


  export type BusinessUnitMarketingPairSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessUnitCode?: boolean
    marketingChannelCode?: boolean
    marketingOfficeId?: boolean
    marketingTeamCode?: boolean
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
    marketingChannel?: boolean | MarketingChannelDefaultArgs<ExtArgs>
    marketingOffice?: boolean | MarketingOfficeDefaultArgs<ExtArgs>
    marketingTeam?: boolean | MarketingTeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessUnitMarketingPair"]>

  export type BusinessUnitMarketingPairSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessUnitCode?: boolean
    marketingChannelCode?: boolean
    marketingOfficeId?: boolean
    marketingTeamCode?: boolean
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
    marketingChannel?: boolean | MarketingChannelDefaultArgs<ExtArgs>
    marketingOffice?: boolean | MarketingOfficeDefaultArgs<ExtArgs>
    marketingTeam?: boolean | MarketingTeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessUnitMarketingPair"]>

  export type BusinessUnitMarketingPairSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessUnitCode?: boolean
    marketingChannelCode?: boolean
    marketingOfficeId?: boolean
    marketingTeamCode?: boolean
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
    marketingChannel?: boolean | MarketingChannelDefaultArgs<ExtArgs>
    marketingOffice?: boolean | MarketingOfficeDefaultArgs<ExtArgs>
    marketingTeam?: boolean | MarketingTeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessUnitMarketingPair"]>

  export type BusinessUnitMarketingPairSelectScalar = {
    id?: boolean
    businessUnitCode?: boolean
    marketingChannelCode?: boolean
    marketingOfficeId?: boolean
    marketingTeamCode?: boolean
  }

  export type BusinessUnitMarketingPairOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "businessUnitCode" | "marketingChannelCode" | "marketingOfficeId" | "marketingTeamCode", ExtArgs["result"]["businessUnitMarketingPair"]>
  export type BusinessUnitMarketingPairInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
    marketingChannel?: boolean | MarketingChannelDefaultArgs<ExtArgs>
    marketingOffice?: boolean | MarketingOfficeDefaultArgs<ExtArgs>
    marketingTeam?: boolean | MarketingTeamDefaultArgs<ExtArgs>
  }
  export type BusinessUnitMarketingPairIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
    marketingChannel?: boolean | MarketingChannelDefaultArgs<ExtArgs>
    marketingOffice?: boolean | MarketingOfficeDefaultArgs<ExtArgs>
    marketingTeam?: boolean | MarketingTeamDefaultArgs<ExtArgs>
  }
  export type BusinessUnitMarketingPairIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
    marketingChannel?: boolean | MarketingChannelDefaultArgs<ExtArgs>
    marketingOffice?: boolean | MarketingOfficeDefaultArgs<ExtArgs>
    marketingTeam?: boolean | MarketingTeamDefaultArgs<ExtArgs>
  }

  export type $BusinessUnitMarketingPairPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessUnitMarketingPair"
    objects: {
      businessUnit: Prisma.$BusinessUnitPayload<ExtArgs>
      marketingChannel: Prisma.$MarketingChannelPayload<ExtArgs>
      marketingOffice: Prisma.$MarketingOfficePayload<ExtArgs>
      marketingTeam: Prisma.$MarketingTeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessUnitCode: string
      marketingChannelCode: string
      marketingOfficeId: string
      marketingTeamCode: string
    }, ExtArgs["result"]["businessUnitMarketingPair"]>
    composites: {}
  }

  type BusinessUnitMarketingPairGetPayload<S extends boolean | null | undefined | BusinessUnitMarketingPairDefaultArgs> = $Result.GetResult<Prisma.$BusinessUnitMarketingPairPayload, S>

  type BusinessUnitMarketingPairCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BusinessUnitMarketingPairFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BusinessUnitMarketingPairCountAggregateInputType | true
    }

  export interface BusinessUnitMarketingPairDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessUnitMarketingPair'], meta: { name: 'BusinessUnitMarketingPair' } }
    /**
     * Find zero or one BusinessUnitMarketingPair that matches the filter.
     * @param {BusinessUnitMarketingPairFindUniqueArgs} args - Arguments to find a BusinessUnitMarketingPair
     * @example
     * // Get one BusinessUnitMarketingPair
     * const businessUnitMarketingPair = await prisma.businessUnitMarketingPair.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessUnitMarketingPairFindUniqueArgs>(args: SelectSubset<T, BusinessUnitMarketingPairFindUniqueArgs<ExtArgs>>): Prisma__BusinessUnitMarketingPairClient<$Result.GetResult<Prisma.$BusinessUnitMarketingPairPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BusinessUnitMarketingPair that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BusinessUnitMarketingPairFindUniqueOrThrowArgs} args - Arguments to find a BusinessUnitMarketingPair
     * @example
     * // Get one BusinessUnitMarketingPair
     * const businessUnitMarketingPair = await prisma.businessUnitMarketingPair.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessUnitMarketingPairFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessUnitMarketingPairFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessUnitMarketingPairClient<$Result.GetResult<Prisma.$BusinessUnitMarketingPairPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessUnitMarketingPair that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitMarketingPairFindFirstArgs} args - Arguments to find a BusinessUnitMarketingPair
     * @example
     * // Get one BusinessUnitMarketingPair
     * const businessUnitMarketingPair = await prisma.businessUnitMarketingPair.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessUnitMarketingPairFindFirstArgs>(args?: SelectSubset<T, BusinessUnitMarketingPairFindFirstArgs<ExtArgs>>): Prisma__BusinessUnitMarketingPairClient<$Result.GetResult<Prisma.$BusinessUnitMarketingPairPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessUnitMarketingPair that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitMarketingPairFindFirstOrThrowArgs} args - Arguments to find a BusinessUnitMarketingPair
     * @example
     * // Get one BusinessUnitMarketingPair
     * const businessUnitMarketingPair = await prisma.businessUnitMarketingPair.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessUnitMarketingPairFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessUnitMarketingPairFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessUnitMarketingPairClient<$Result.GetResult<Prisma.$BusinessUnitMarketingPairPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BusinessUnitMarketingPairs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitMarketingPairFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessUnitMarketingPairs
     * const businessUnitMarketingPairs = await prisma.businessUnitMarketingPair.findMany()
     * 
     * // Get first 10 BusinessUnitMarketingPairs
     * const businessUnitMarketingPairs = await prisma.businessUnitMarketingPair.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessUnitMarketingPairWithIdOnly = await prisma.businessUnitMarketingPair.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessUnitMarketingPairFindManyArgs>(args?: SelectSubset<T, BusinessUnitMarketingPairFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitMarketingPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BusinessUnitMarketingPair.
     * @param {BusinessUnitMarketingPairCreateArgs} args - Arguments to create a BusinessUnitMarketingPair.
     * @example
     * // Create one BusinessUnitMarketingPair
     * const BusinessUnitMarketingPair = await prisma.businessUnitMarketingPair.create({
     *   data: {
     *     // ... data to create a BusinessUnitMarketingPair
     *   }
     * })
     * 
     */
    create<T extends BusinessUnitMarketingPairCreateArgs>(args: SelectSubset<T, BusinessUnitMarketingPairCreateArgs<ExtArgs>>): Prisma__BusinessUnitMarketingPairClient<$Result.GetResult<Prisma.$BusinessUnitMarketingPairPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BusinessUnitMarketingPairs.
     * @param {BusinessUnitMarketingPairCreateManyArgs} args - Arguments to create many BusinessUnitMarketingPairs.
     * @example
     * // Create many BusinessUnitMarketingPairs
     * const businessUnitMarketingPair = await prisma.businessUnitMarketingPair.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessUnitMarketingPairCreateManyArgs>(args?: SelectSubset<T, BusinessUnitMarketingPairCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessUnitMarketingPairs and returns the data saved in the database.
     * @param {BusinessUnitMarketingPairCreateManyAndReturnArgs} args - Arguments to create many BusinessUnitMarketingPairs.
     * @example
     * // Create many BusinessUnitMarketingPairs
     * const businessUnitMarketingPair = await prisma.businessUnitMarketingPair.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessUnitMarketingPairs and only return the `id`
     * const businessUnitMarketingPairWithIdOnly = await prisma.businessUnitMarketingPair.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessUnitMarketingPairCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessUnitMarketingPairCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitMarketingPairPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BusinessUnitMarketingPair.
     * @param {BusinessUnitMarketingPairDeleteArgs} args - Arguments to delete one BusinessUnitMarketingPair.
     * @example
     * // Delete one BusinessUnitMarketingPair
     * const BusinessUnitMarketingPair = await prisma.businessUnitMarketingPair.delete({
     *   where: {
     *     // ... filter to delete one BusinessUnitMarketingPair
     *   }
     * })
     * 
     */
    delete<T extends BusinessUnitMarketingPairDeleteArgs>(args: SelectSubset<T, BusinessUnitMarketingPairDeleteArgs<ExtArgs>>): Prisma__BusinessUnitMarketingPairClient<$Result.GetResult<Prisma.$BusinessUnitMarketingPairPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BusinessUnitMarketingPair.
     * @param {BusinessUnitMarketingPairUpdateArgs} args - Arguments to update one BusinessUnitMarketingPair.
     * @example
     * // Update one BusinessUnitMarketingPair
     * const businessUnitMarketingPair = await prisma.businessUnitMarketingPair.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessUnitMarketingPairUpdateArgs>(args: SelectSubset<T, BusinessUnitMarketingPairUpdateArgs<ExtArgs>>): Prisma__BusinessUnitMarketingPairClient<$Result.GetResult<Prisma.$BusinessUnitMarketingPairPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BusinessUnitMarketingPairs.
     * @param {BusinessUnitMarketingPairDeleteManyArgs} args - Arguments to filter BusinessUnitMarketingPairs to delete.
     * @example
     * // Delete a few BusinessUnitMarketingPairs
     * const { count } = await prisma.businessUnitMarketingPair.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessUnitMarketingPairDeleteManyArgs>(args?: SelectSubset<T, BusinessUnitMarketingPairDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessUnitMarketingPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitMarketingPairUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessUnitMarketingPairs
     * const businessUnitMarketingPair = await prisma.businessUnitMarketingPair.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessUnitMarketingPairUpdateManyArgs>(args: SelectSubset<T, BusinessUnitMarketingPairUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessUnitMarketingPairs and returns the data updated in the database.
     * @param {BusinessUnitMarketingPairUpdateManyAndReturnArgs} args - Arguments to update many BusinessUnitMarketingPairs.
     * @example
     * // Update many BusinessUnitMarketingPairs
     * const businessUnitMarketingPair = await prisma.businessUnitMarketingPair.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BusinessUnitMarketingPairs and only return the `id`
     * const businessUnitMarketingPairWithIdOnly = await prisma.businessUnitMarketingPair.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BusinessUnitMarketingPairUpdateManyAndReturnArgs>(args: SelectSubset<T, BusinessUnitMarketingPairUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitMarketingPairPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BusinessUnitMarketingPair.
     * @param {BusinessUnitMarketingPairUpsertArgs} args - Arguments to update or create a BusinessUnitMarketingPair.
     * @example
     * // Update or create a BusinessUnitMarketingPair
     * const businessUnitMarketingPair = await prisma.businessUnitMarketingPair.upsert({
     *   create: {
     *     // ... data to create a BusinessUnitMarketingPair
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessUnitMarketingPair we want to update
     *   }
     * })
     */
    upsert<T extends BusinessUnitMarketingPairUpsertArgs>(args: SelectSubset<T, BusinessUnitMarketingPairUpsertArgs<ExtArgs>>): Prisma__BusinessUnitMarketingPairClient<$Result.GetResult<Prisma.$BusinessUnitMarketingPairPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BusinessUnitMarketingPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitMarketingPairCountArgs} args - Arguments to filter BusinessUnitMarketingPairs to count.
     * @example
     * // Count the number of BusinessUnitMarketingPairs
     * const count = await prisma.businessUnitMarketingPair.count({
     *   where: {
     *     // ... the filter for the BusinessUnitMarketingPairs we want to count
     *   }
     * })
    **/
    count<T extends BusinessUnitMarketingPairCountArgs>(
      args?: Subset<T, BusinessUnitMarketingPairCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessUnitMarketingPairCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessUnitMarketingPair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitMarketingPairAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessUnitMarketingPairAggregateArgs>(args: Subset<T, BusinessUnitMarketingPairAggregateArgs>): Prisma.PrismaPromise<GetBusinessUnitMarketingPairAggregateType<T>>

    /**
     * Group by BusinessUnitMarketingPair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitMarketingPairGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessUnitMarketingPairGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessUnitMarketingPairGroupByArgs['orderBy'] }
        : { orderBy?: BusinessUnitMarketingPairGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessUnitMarketingPairGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessUnitMarketingPairGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessUnitMarketingPair model
   */
  readonly fields: BusinessUnitMarketingPairFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessUnitMarketingPair.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessUnitMarketingPairClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessUnit<T extends BusinessUnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessUnitDefaultArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    marketingChannel<T extends MarketingChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MarketingChannelDefaultArgs<ExtArgs>>): Prisma__MarketingChannelClient<$Result.GetResult<Prisma.$MarketingChannelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    marketingOffice<T extends MarketingOfficeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MarketingOfficeDefaultArgs<ExtArgs>>): Prisma__MarketingOfficeClient<$Result.GetResult<Prisma.$MarketingOfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    marketingTeam<T extends MarketingTeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MarketingTeamDefaultArgs<ExtArgs>>): Prisma__MarketingTeamClient<$Result.GetResult<Prisma.$MarketingTeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessUnitMarketingPair model
   */
  interface BusinessUnitMarketingPairFieldRefs {
    readonly id: FieldRef<"BusinessUnitMarketingPair", 'String'>
    readonly businessUnitCode: FieldRef<"BusinessUnitMarketingPair", 'String'>
    readonly marketingChannelCode: FieldRef<"BusinessUnitMarketingPair", 'String'>
    readonly marketingOfficeId: FieldRef<"BusinessUnitMarketingPair", 'String'>
    readonly marketingTeamCode: FieldRef<"BusinessUnitMarketingPair", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BusinessUnitMarketingPair findUnique
   */
  export type BusinessUnitMarketingPairFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitMarketingPair
     */
    select?: BusinessUnitMarketingPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitMarketingPair
     */
    omit?: BusinessUnitMarketingPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitMarketingPairInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnitMarketingPair to fetch.
     */
    where: BusinessUnitMarketingPairWhereUniqueInput
  }

  /**
   * BusinessUnitMarketingPair findUniqueOrThrow
   */
  export type BusinessUnitMarketingPairFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitMarketingPair
     */
    select?: BusinessUnitMarketingPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitMarketingPair
     */
    omit?: BusinessUnitMarketingPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitMarketingPairInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnitMarketingPair to fetch.
     */
    where: BusinessUnitMarketingPairWhereUniqueInput
  }

  /**
   * BusinessUnitMarketingPair findFirst
   */
  export type BusinessUnitMarketingPairFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitMarketingPair
     */
    select?: BusinessUnitMarketingPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitMarketingPair
     */
    omit?: BusinessUnitMarketingPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitMarketingPairInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnitMarketingPair to fetch.
     */
    where?: BusinessUnitMarketingPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnitMarketingPairs to fetch.
     */
    orderBy?: BusinessUnitMarketingPairOrderByWithRelationInput | BusinessUnitMarketingPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessUnitMarketingPairs.
     */
    cursor?: BusinessUnitMarketingPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnitMarketingPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnitMarketingPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessUnitMarketingPairs.
     */
    distinct?: BusinessUnitMarketingPairScalarFieldEnum | BusinessUnitMarketingPairScalarFieldEnum[]
  }

  /**
   * BusinessUnitMarketingPair findFirstOrThrow
   */
  export type BusinessUnitMarketingPairFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitMarketingPair
     */
    select?: BusinessUnitMarketingPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitMarketingPair
     */
    omit?: BusinessUnitMarketingPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitMarketingPairInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnitMarketingPair to fetch.
     */
    where?: BusinessUnitMarketingPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnitMarketingPairs to fetch.
     */
    orderBy?: BusinessUnitMarketingPairOrderByWithRelationInput | BusinessUnitMarketingPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessUnitMarketingPairs.
     */
    cursor?: BusinessUnitMarketingPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnitMarketingPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnitMarketingPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessUnitMarketingPairs.
     */
    distinct?: BusinessUnitMarketingPairScalarFieldEnum | BusinessUnitMarketingPairScalarFieldEnum[]
  }

  /**
   * BusinessUnitMarketingPair findMany
   */
  export type BusinessUnitMarketingPairFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitMarketingPair
     */
    select?: BusinessUnitMarketingPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitMarketingPair
     */
    omit?: BusinessUnitMarketingPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitMarketingPairInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnitMarketingPairs to fetch.
     */
    where?: BusinessUnitMarketingPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnitMarketingPairs to fetch.
     */
    orderBy?: BusinessUnitMarketingPairOrderByWithRelationInput | BusinessUnitMarketingPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessUnitMarketingPairs.
     */
    cursor?: BusinessUnitMarketingPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnitMarketingPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnitMarketingPairs.
     */
    skip?: number
    distinct?: BusinessUnitMarketingPairScalarFieldEnum | BusinessUnitMarketingPairScalarFieldEnum[]
  }

  /**
   * BusinessUnitMarketingPair create
   */
  export type BusinessUnitMarketingPairCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitMarketingPair
     */
    select?: BusinessUnitMarketingPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitMarketingPair
     */
    omit?: BusinessUnitMarketingPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitMarketingPairInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessUnitMarketingPair.
     */
    data: XOR<BusinessUnitMarketingPairCreateInput, BusinessUnitMarketingPairUncheckedCreateInput>
  }

  /**
   * BusinessUnitMarketingPair createMany
   */
  export type BusinessUnitMarketingPairCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessUnitMarketingPairs.
     */
    data: BusinessUnitMarketingPairCreateManyInput | BusinessUnitMarketingPairCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessUnitMarketingPair createManyAndReturn
   */
  export type BusinessUnitMarketingPairCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitMarketingPair
     */
    select?: BusinessUnitMarketingPairSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitMarketingPair
     */
    omit?: BusinessUnitMarketingPairOmit<ExtArgs> | null
    /**
     * The data used to create many BusinessUnitMarketingPairs.
     */
    data: BusinessUnitMarketingPairCreateManyInput | BusinessUnitMarketingPairCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitMarketingPairIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessUnitMarketingPair update
   */
  export type BusinessUnitMarketingPairUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitMarketingPair
     */
    select?: BusinessUnitMarketingPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitMarketingPair
     */
    omit?: BusinessUnitMarketingPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitMarketingPairInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessUnitMarketingPair.
     */
    data: XOR<BusinessUnitMarketingPairUpdateInput, BusinessUnitMarketingPairUncheckedUpdateInput>
    /**
     * Choose, which BusinessUnitMarketingPair to update.
     */
    where: BusinessUnitMarketingPairWhereUniqueInput
  }

  /**
   * BusinessUnitMarketingPair updateMany
   */
  export type BusinessUnitMarketingPairUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessUnitMarketingPairs.
     */
    data: XOR<BusinessUnitMarketingPairUpdateManyMutationInput, BusinessUnitMarketingPairUncheckedUpdateManyInput>
    /**
     * Filter which BusinessUnitMarketingPairs to update
     */
    where?: BusinessUnitMarketingPairWhereInput
    /**
     * Limit how many BusinessUnitMarketingPairs to update.
     */
    limit?: number
  }

  /**
   * BusinessUnitMarketingPair updateManyAndReturn
   */
  export type BusinessUnitMarketingPairUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitMarketingPair
     */
    select?: BusinessUnitMarketingPairSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitMarketingPair
     */
    omit?: BusinessUnitMarketingPairOmit<ExtArgs> | null
    /**
     * The data used to update BusinessUnitMarketingPairs.
     */
    data: XOR<BusinessUnitMarketingPairUpdateManyMutationInput, BusinessUnitMarketingPairUncheckedUpdateManyInput>
    /**
     * Filter which BusinessUnitMarketingPairs to update
     */
    where?: BusinessUnitMarketingPairWhereInput
    /**
     * Limit how many BusinessUnitMarketingPairs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitMarketingPairIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessUnitMarketingPair upsert
   */
  export type BusinessUnitMarketingPairUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitMarketingPair
     */
    select?: BusinessUnitMarketingPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitMarketingPair
     */
    omit?: BusinessUnitMarketingPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitMarketingPairInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessUnitMarketingPair to update in case it exists.
     */
    where: BusinessUnitMarketingPairWhereUniqueInput
    /**
     * In case the BusinessUnitMarketingPair found by the `where` argument doesn't exist, create a new BusinessUnitMarketingPair with this data.
     */
    create: XOR<BusinessUnitMarketingPairCreateInput, BusinessUnitMarketingPairUncheckedCreateInput>
    /**
     * In case the BusinessUnitMarketingPair was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessUnitMarketingPairUpdateInput, BusinessUnitMarketingPairUncheckedUpdateInput>
  }

  /**
   * BusinessUnitMarketingPair delete
   */
  export type BusinessUnitMarketingPairDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitMarketingPair
     */
    select?: BusinessUnitMarketingPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitMarketingPair
     */
    omit?: BusinessUnitMarketingPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitMarketingPairInclude<ExtArgs> | null
    /**
     * Filter which BusinessUnitMarketingPair to delete.
     */
    where: BusinessUnitMarketingPairWhereUniqueInput
  }

  /**
   * BusinessUnitMarketingPair deleteMany
   */
  export type BusinessUnitMarketingPairDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessUnitMarketingPairs to delete
     */
    where?: BusinessUnitMarketingPairWhereInput
    /**
     * Limit how many BusinessUnitMarketingPairs to delete.
     */
    limit?: number
  }

  /**
   * BusinessUnitMarketingPair without action
   */
  export type BusinessUnitMarketingPairDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitMarketingPair
     */
    select?: BusinessUnitMarketingPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitMarketingPair
     */
    omit?: BusinessUnitMarketingPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitMarketingPairInclude<ExtArgs> | null
  }


  /**
   * Model BusinessUnitServicePair
   */

  export type AggregateBusinessUnitServicePair = {
    _count: BusinessUnitServicePairCountAggregateOutputType | null
    _min: BusinessUnitServicePairMinAggregateOutputType | null
    _max: BusinessUnitServicePairMaxAggregateOutputType | null
  }

  export type BusinessUnitServicePairMinAggregateOutputType = {
    id: string | null
    businessUnitCode: string | null
    serviceChannelCode: string | null
    serviceOfficeId: string | null
    serviceTeamCode: string | null
  }

  export type BusinessUnitServicePairMaxAggregateOutputType = {
    id: string | null
    businessUnitCode: string | null
    serviceChannelCode: string | null
    serviceOfficeId: string | null
    serviceTeamCode: string | null
  }

  export type BusinessUnitServicePairCountAggregateOutputType = {
    id: number
    businessUnitCode: number
    serviceChannelCode: number
    serviceOfficeId: number
    serviceTeamCode: number
    _all: number
  }


  export type BusinessUnitServicePairMinAggregateInputType = {
    id?: true
    businessUnitCode?: true
    serviceChannelCode?: true
    serviceOfficeId?: true
    serviceTeamCode?: true
  }

  export type BusinessUnitServicePairMaxAggregateInputType = {
    id?: true
    businessUnitCode?: true
    serviceChannelCode?: true
    serviceOfficeId?: true
    serviceTeamCode?: true
  }

  export type BusinessUnitServicePairCountAggregateInputType = {
    id?: true
    businessUnitCode?: true
    serviceChannelCode?: true
    serviceOfficeId?: true
    serviceTeamCode?: true
    _all?: true
  }

  export type BusinessUnitServicePairAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessUnitServicePair to aggregate.
     */
    where?: BusinessUnitServicePairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnitServicePairs to fetch.
     */
    orderBy?: BusinessUnitServicePairOrderByWithRelationInput | BusinessUnitServicePairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessUnitServicePairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnitServicePairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnitServicePairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessUnitServicePairs
    **/
    _count?: true | BusinessUnitServicePairCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessUnitServicePairMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessUnitServicePairMaxAggregateInputType
  }

  export type GetBusinessUnitServicePairAggregateType<T extends BusinessUnitServicePairAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessUnitServicePair]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessUnitServicePair[P]>
      : GetScalarType<T[P], AggregateBusinessUnitServicePair[P]>
  }




  export type BusinessUnitServicePairGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessUnitServicePairWhereInput
    orderBy?: BusinessUnitServicePairOrderByWithAggregationInput | BusinessUnitServicePairOrderByWithAggregationInput[]
    by: BusinessUnitServicePairScalarFieldEnum[] | BusinessUnitServicePairScalarFieldEnum
    having?: BusinessUnitServicePairScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessUnitServicePairCountAggregateInputType | true
    _min?: BusinessUnitServicePairMinAggregateInputType
    _max?: BusinessUnitServicePairMaxAggregateInputType
  }

  export type BusinessUnitServicePairGroupByOutputType = {
    id: string
    businessUnitCode: string
    serviceChannelCode: string
    serviceOfficeId: string
    serviceTeamCode: string
    _count: BusinessUnitServicePairCountAggregateOutputType | null
    _min: BusinessUnitServicePairMinAggregateOutputType | null
    _max: BusinessUnitServicePairMaxAggregateOutputType | null
  }

  type GetBusinessUnitServicePairGroupByPayload<T extends BusinessUnitServicePairGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessUnitServicePairGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessUnitServicePairGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessUnitServicePairGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessUnitServicePairGroupByOutputType[P]>
        }
      >
    >


  export type BusinessUnitServicePairSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessUnitCode?: boolean
    serviceChannelCode?: boolean
    serviceOfficeId?: boolean
    serviceTeamCode?: boolean
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
    serviceChannel?: boolean | ServiceChannelDefaultArgs<ExtArgs>
    serviceOffice?: boolean | ServiceOfficeDefaultArgs<ExtArgs>
    serviceTeam?: boolean | ServiceTeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessUnitServicePair"]>

  export type BusinessUnitServicePairSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessUnitCode?: boolean
    serviceChannelCode?: boolean
    serviceOfficeId?: boolean
    serviceTeamCode?: boolean
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
    serviceChannel?: boolean | ServiceChannelDefaultArgs<ExtArgs>
    serviceOffice?: boolean | ServiceOfficeDefaultArgs<ExtArgs>
    serviceTeam?: boolean | ServiceTeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessUnitServicePair"]>

  export type BusinessUnitServicePairSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    businessUnitCode?: boolean
    serviceChannelCode?: boolean
    serviceOfficeId?: boolean
    serviceTeamCode?: boolean
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
    serviceChannel?: boolean | ServiceChannelDefaultArgs<ExtArgs>
    serviceOffice?: boolean | ServiceOfficeDefaultArgs<ExtArgs>
    serviceTeam?: boolean | ServiceTeamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessUnitServicePair"]>

  export type BusinessUnitServicePairSelectScalar = {
    id?: boolean
    businessUnitCode?: boolean
    serviceChannelCode?: boolean
    serviceOfficeId?: boolean
    serviceTeamCode?: boolean
  }

  export type BusinessUnitServicePairOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "businessUnitCode" | "serviceChannelCode" | "serviceOfficeId" | "serviceTeamCode", ExtArgs["result"]["businessUnitServicePair"]>
  export type BusinessUnitServicePairInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
    serviceChannel?: boolean | ServiceChannelDefaultArgs<ExtArgs>
    serviceOffice?: boolean | ServiceOfficeDefaultArgs<ExtArgs>
    serviceTeam?: boolean | ServiceTeamDefaultArgs<ExtArgs>
  }
  export type BusinessUnitServicePairIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
    serviceChannel?: boolean | ServiceChannelDefaultArgs<ExtArgs>
    serviceOffice?: boolean | ServiceOfficeDefaultArgs<ExtArgs>
    serviceTeam?: boolean | ServiceTeamDefaultArgs<ExtArgs>
  }
  export type BusinessUnitServicePairIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    businessUnit?: boolean | BusinessUnitDefaultArgs<ExtArgs>
    serviceChannel?: boolean | ServiceChannelDefaultArgs<ExtArgs>
    serviceOffice?: boolean | ServiceOfficeDefaultArgs<ExtArgs>
    serviceTeam?: boolean | ServiceTeamDefaultArgs<ExtArgs>
  }

  export type $BusinessUnitServicePairPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessUnitServicePair"
    objects: {
      businessUnit: Prisma.$BusinessUnitPayload<ExtArgs>
      serviceChannel: Prisma.$ServiceChannelPayload<ExtArgs>
      serviceOffice: Prisma.$ServiceOfficePayload<ExtArgs>
      serviceTeam: Prisma.$ServiceTeamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      businessUnitCode: string
      serviceChannelCode: string
      serviceOfficeId: string
      serviceTeamCode: string
    }, ExtArgs["result"]["businessUnitServicePair"]>
    composites: {}
  }

  type BusinessUnitServicePairGetPayload<S extends boolean | null | undefined | BusinessUnitServicePairDefaultArgs> = $Result.GetResult<Prisma.$BusinessUnitServicePairPayload, S>

  type BusinessUnitServicePairCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BusinessUnitServicePairFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BusinessUnitServicePairCountAggregateInputType | true
    }

  export interface BusinessUnitServicePairDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessUnitServicePair'], meta: { name: 'BusinessUnitServicePair' } }
    /**
     * Find zero or one BusinessUnitServicePair that matches the filter.
     * @param {BusinessUnitServicePairFindUniqueArgs} args - Arguments to find a BusinessUnitServicePair
     * @example
     * // Get one BusinessUnitServicePair
     * const businessUnitServicePair = await prisma.businessUnitServicePair.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessUnitServicePairFindUniqueArgs>(args: SelectSubset<T, BusinessUnitServicePairFindUniqueArgs<ExtArgs>>): Prisma__BusinessUnitServicePairClient<$Result.GetResult<Prisma.$BusinessUnitServicePairPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BusinessUnitServicePair that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BusinessUnitServicePairFindUniqueOrThrowArgs} args - Arguments to find a BusinessUnitServicePair
     * @example
     * // Get one BusinessUnitServicePair
     * const businessUnitServicePair = await prisma.businessUnitServicePair.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessUnitServicePairFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessUnitServicePairFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessUnitServicePairClient<$Result.GetResult<Prisma.$BusinessUnitServicePairPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessUnitServicePair that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitServicePairFindFirstArgs} args - Arguments to find a BusinessUnitServicePair
     * @example
     * // Get one BusinessUnitServicePair
     * const businessUnitServicePair = await prisma.businessUnitServicePair.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessUnitServicePairFindFirstArgs>(args?: SelectSubset<T, BusinessUnitServicePairFindFirstArgs<ExtArgs>>): Prisma__BusinessUnitServicePairClient<$Result.GetResult<Prisma.$BusinessUnitServicePairPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessUnitServicePair that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitServicePairFindFirstOrThrowArgs} args - Arguments to find a BusinessUnitServicePair
     * @example
     * // Get one BusinessUnitServicePair
     * const businessUnitServicePair = await prisma.businessUnitServicePair.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessUnitServicePairFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessUnitServicePairFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessUnitServicePairClient<$Result.GetResult<Prisma.$BusinessUnitServicePairPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BusinessUnitServicePairs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitServicePairFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessUnitServicePairs
     * const businessUnitServicePairs = await prisma.businessUnitServicePair.findMany()
     * 
     * // Get first 10 BusinessUnitServicePairs
     * const businessUnitServicePairs = await prisma.businessUnitServicePair.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessUnitServicePairWithIdOnly = await prisma.businessUnitServicePair.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessUnitServicePairFindManyArgs>(args?: SelectSubset<T, BusinessUnitServicePairFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitServicePairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BusinessUnitServicePair.
     * @param {BusinessUnitServicePairCreateArgs} args - Arguments to create a BusinessUnitServicePair.
     * @example
     * // Create one BusinessUnitServicePair
     * const BusinessUnitServicePair = await prisma.businessUnitServicePair.create({
     *   data: {
     *     // ... data to create a BusinessUnitServicePair
     *   }
     * })
     * 
     */
    create<T extends BusinessUnitServicePairCreateArgs>(args: SelectSubset<T, BusinessUnitServicePairCreateArgs<ExtArgs>>): Prisma__BusinessUnitServicePairClient<$Result.GetResult<Prisma.$BusinessUnitServicePairPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BusinessUnitServicePairs.
     * @param {BusinessUnitServicePairCreateManyArgs} args - Arguments to create many BusinessUnitServicePairs.
     * @example
     * // Create many BusinessUnitServicePairs
     * const businessUnitServicePair = await prisma.businessUnitServicePair.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessUnitServicePairCreateManyArgs>(args?: SelectSubset<T, BusinessUnitServicePairCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessUnitServicePairs and returns the data saved in the database.
     * @param {BusinessUnitServicePairCreateManyAndReturnArgs} args - Arguments to create many BusinessUnitServicePairs.
     * @example
     * // Create many BusinessUnitServicePairs
     * const businessUnitServicePair = await prisma.businessUnitServicePair.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessUnitServicePairs and only return the `id`
     * const businessUnitServicePairWithIdOnly = await prisma.businessUnitServicePair.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessUnitServicePairCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessUnitServicePairCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitServicePairPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BusinessUnitServicePair.
     * @param {BusinessUnitServicePairDeleteArgs} args - Arguments to delete one BusinessUnitServicePair.
     * @example
     * // Delete one BusinessUnitServicePair
     * const BusinessUnitServicePair = await prisma.businessUnitServicePair.delete({
     *   where: {
     *     // ... filter to delete one BusinessUnitServicePair
     *   }
     * })
     * 
     */
    delete<T extends BusinessUnitServicePairDeleteArgs>(args: SelectSubset<T, BusinessUnitServicePairDeleteArgs<ExtArgs>>): Prisma__BusinessUnitServicePairClient<$Result.GetResult<Prisma.$BusinessUnitServicePairPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BusinessUnitServicePair.
     * @param {BusinessUnitServicePairUpdateArgs} args - Arguments to update one BusinessUnitServicePair.
     * @example
     * // Update one BusinessUnitServicePair
     * const businessUnitServicePair = await prisma.businessUnitServicePair.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessUnitServicePairUpdateArgs>(args: SelectSubset<T, BusinessUnitServicePairUpdateArgs<ExtArgs>>): Prisma__BusinessUnitServicePairClient<$Result.GetResult<Prisma.$BusinessUnitServicePairPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BusinessUnitServicePairs.
     * @param {BusinessUnitServicePairDeleteManyArgs} args - Arguments to filter BusinessUnitServicePairs to delete.
     * @example
     * // Delete a few BusinessUnitServicePairs
     * const { count } = await prisma.businessUnitServicePair.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessUnitServicePairDeleteManyArgs>(args?: SelectSubset<T, BusinessUnitServicePairDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessUnitServicePairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitServicePairUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessUnitServicePairs
     * const businessUnitServicePair = await prisma.businessUnitServicePair.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessUnitServicePairUpdateManyArgs>(args: SelectSubset<T, BusinessUnitServicePairUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessUnitServicePairs and returns the data updated in the database.
     * @param {BusinessUnitServicePairUpdateManyAndReturnArgs} args - Arguments to update many BusinessUnitServicePairs.
     * @example
     * // Update many BusinessUnitServicePairs
     * const businessUnitServicePair = await prisma.businessUnitServicePair.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BusinessUnitServicePairs and only return the `id`
     * const businessUnitServicePairWithIdOnly = await prisma.businessUnitServicePair.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BusinessUnitServicePairUpdateManyAndReturnArgs>(args: SelectSubset<T, BusinessUnitServicePairUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessUnitServicePairPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BusinessUnitServicePair.
     * @param {BusinessUnitServicePairUpsertArgs} args - Arguments to update or create a BusinessUnitServicePair.
     * @example
     * // Update or create a BusinessUnitServicePair
     * const businessUnitServicePair = await prisma.businessUnitServicePair.upsert({
     *   create: {
     *     // ... data to create a BusinessUnitServicePair
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessUnitServicePair we want to update
     *   }
     * })
     */
    upsert<T extends BusinessUnitServicePairUpsertArgs>(args: SelectSubset<T, BusinessUnitServicePairUpsertArgs<ExtArgs>>): Prisma__BusinessUnitServicePairClient<$Result.GetResult<Prisma.$BusinessUnitServicePairPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BusinessUnitServicePairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitServicePairCountArgs} args - Arguments to filter BusinessUnitServicePairs to count.
     * @example
     * // Count the number of BusinessUnitServicePairs
     * const count = await prisma.businessUnitServicePair.count({
     *   where: {
     *     // ... the filter for the BusinessUnitServicePairs we want to count
     *   }
     * })
    **/
    count<T extends BusinessUnitServicePairCountArgs>(
      args?: Subset<T, BusinessUnitServicePairCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessUnitServicePairCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessUnitServicePair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitServicePairAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessUnitServicePairAggregateArgs>(args: Subset<T, BusinessUnitServicePairAggregateArgs>): Prisma.PrismaPromise<GetBusinessUnitServicePairAggregateType<T>>

    /**
     * Group by BusinessUnitServicePair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessUnitServicePairGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessUnitServicePairGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessUnitServicePairGroupByArgs['orderBy'] }
        : { orderBy?: BusinessUnitServicePairGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessUnitServicePairGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessUnitServicePairGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessUnitServicePair model
   */
  readonly fields: BusinessUnitServicePairFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessUnitServicePair.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessUnitServicePairClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    businessUnit<T extends BusinessUnitDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BusinessUnitDefaultArgs<ExtArgs>>): Prisma__BusinessUnitClient<$Result.GetResult<Prisma.$BusinessUnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceChannel<T extends ServiceChannelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceChannelDefaultArgs<ExtArgs>>): Prisma__ServiceChannelClient<$Result.GetResult<Prisma.$ServiceChannelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceOffice<T extends ServiceOfficeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceOfficeDefaultArgs<ExtArgs>>): Prisma__ServiceOfficeClient<$Result.GetResult<Prisma.$ServiceOfficePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    serviceTeam<T extends ServiceTeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceTeamDefaultArgs<ExtArgs>>): Prisma__ServiceTeamClient<$Result.GetResult<Prisma.$ServiceTeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessUnitServicePair model
   */
  interface BusinessUnitServicePairFieldRefs {
    readonly id: FieldRef<"BusinessUnitServicePair", 'String'>
    readonly businessUnitCode: FieldRef<"BusinessUnitServicePair", 'String'>
    readonly serviceChannelCode: FieldRef<"BusinessUnitServicePair", 'String'>
    readonly serviceOfficeId: FieldRef<"BusinessUnitServicePair", 'String'>
    readonly serviceTeamCode: FieldRef<"BusinessUnitServicePair", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BusinessUnitServicePair findUnique
   */
  export type BusinessUnitServicePairFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitServicePair
     */
    select?: BusinessUnitServicePairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitServicePair
     */
    omit?: BusinessUnitServicePairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitServicePairInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnitServicePair to fetch.
     */
    where: BusinessUnitServicePairWhereUniqueInput
  }

  /**
   * BusinessUnitServicePair findUniqueOrThrow
   */
  export type BusinessUnitServicePairFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitServicePair
     */
    select?: BusinessUnitServicePairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitServicePair
     */
    omit?: BusinessUnitServicePairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitServicePairInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnitServicePair to fetch.
     */
    where: BusinessUnitServicePairWhereUniqueInput
  }

  /**
   * BusinessUnitServicePair findFirst
   */
  export type BusinessUnitServicePairFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitServicePair
     */
    select?: BusinessUnitServicePairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitServicePair
     */
    omit?: BusinessUnitServicePairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitServicePairInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnitServicePair to fetch.
     */
    where?: BusinessUnitServicePairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnitServicePairs to fetch.
     */
    orderBy?: BusinessUnitServicePairOrderByWithRelationInput | BusinessUnitServicePairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessUnitServicePairs.
     */
    cursor?: BusinessUnitServicePairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnitServicePairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnitServicePairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessUnitServicePairs.
     */
    distinct?: BusinessUnitServicePairScalarFieldEnum | BusinessUnitServicePairScalarFieldEnum[]
  }

  /**
   * BusinessUnitServicePair findFirstOrThrow
   */
  export type BusinessUnitServicePairFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitServicePair
     */
    select?: BusinessUnitServicePairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitServicePair
     */
    omit?: BusinessUnitServicePairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitServicePairInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnitServicePair to fetch.
     */
    where?: BusinessUnitServicePairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnitServicePairs to fetch.
     */
    orderBy?: BusinessUnitServicePairOrderByWithRelationInput | BusinessUnitServicePairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessUnitServicePairs.
     */
    cursor?: BusinessUnitServicePairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnitServicePairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnitServicePairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessUnitServicePairs.
     */
    distinct?: BusinessUnitServicePairScalarFieldEnum | BusinessUnitServicePairScalarFieldEnum[]
  }

  /**
   * BusinessUnitServicePair findMany
   */
  export type BusinessUnitServicePairFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitServicePair
     */
    select?: BusinessUnitServicePairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitServicePair
     */
    omit?: BusinessUnitServicePairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitServicePairInclude<ExtArgs> | null
    /**
     * Filter, which BusinessUnitServicePairs to fetch.
     */
    where?: BusinessUnitServicePairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessUnitServicePairs to fetch.
     */
    orderBy?: BusinessUnitServicePairOrderByWithRelationInput | BusinessUnitServicePairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessUnitServicePairs.
     */
    cursor?: BusinessUnitServicePairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessUnitServicePairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessUnitServicePairs.
     */
    skip?: number
    distinct?: BusinessUnitServicePairScalarFieldEnum | BusinessUnitServicePairScalarFieldEnum[]
  }

  /**
   * BusinessUnitServicePair create
   */
  export type BusinessUnitServicePairCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitServicePair
     */
    select?: BusinessUnitServicePairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitServicePair
     */
    omit?: BusinessUnitServicePairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitServicePairInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessUnitServicePair.
     */
    data: XOR<BusinessUnitServicePairCreateInput, BusinessUnitServicePairUncheckedCreateInput>
  }

  /**
   * BusinessUnitServicePair createMany
   */
  export type BusinessUnitServicePairCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessUnitServicePairs.
     */
    data: BusinessUnitServicePairCreateManyInput | BusinessUnitServicePairCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessUnitServicePair createManyAndReturn
   */
  export type BusinessUnitServicePairCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitServicePair
     */
    select?: BusinessUnitServicePairSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitServicePair
     */
    omit?: BusinessUnitServicePairOmit<ExtArgs> | null
    /**
     * The data used to create many BusinessUnitServicePairs.
     */
    data: BusinessUnitServicePairCreateManyInput | BusinessUnitServicePairCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitServicePairIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessUnitServicePair update
   */
  export type BusinessUnitServicePairUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitServicePair
     */
    select?: BusinessUnitServicePairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitServicePair
     */
    omit?: BusinessUnitServicePairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitServicePairInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessUnitServicePair.
     */
    data: XOR<BusinessUnitServicePairUpdateInput, BusinessUnitServicePairUncheckedUpdateInput>
    /**
     * Choose, which BusinessUnitServicePair to update.
     */
    where: BusinessUnitServicePairWhereUniqueInput
  }

  /**
   * BusinessUnitServicePair updateMany
   */
  export type BusinessUnitServicePairUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessUnitServicePairs.
     */
    data: XOR<BusinessUnitServicePairUpdateManyMutationInput, BusinessUnitServicePairUncheckedUpdateManyInput>
    /**
     * Filter which BusinessUnitServicePairs to update
     */
    where?: BusinessUnitServicePairWhereInput
    /**
     * Limit how many BusinessUnitServicePairs to update.
     */
    limit?: number
  }

  /**
   * BusinessUnitServicePair updateManyAndReturn
   */
  export type BusinessUnitServicePairUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitServicePair
     */
    select?: BusinessUnitServicePairSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitServicePair
     */
    omit?: BusinessUnitServicePairOmit<ExtArgs> | null
    /**
     * The data used to update BusinessUnitServicePairs.
     */
    data: XOR<BusinessUnitServicePairUpdateManyMutationInput, BusinessUnitServicePairUncheckedUpdateManyInput>
    /**
     * Filter which BusinessUnitServicePairs to update
     */
    where?: BusinessUnitServicePairWhereInput
    /**
     * Limit how many BusinessUnitServicePairs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitServicePairIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessUnitServicePair upsert
   */
  export type BusinessUnitServicePairUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitServicePair
     */
    select?: BusinessUnitServicePairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitServicePair
     */
    omit?: BusinessUnitServicePairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitServicePairInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessUnitServicePair to update in case it exists.
     */
    where: BusinessUnitServicePairWhereUniqueInput
    /**
     * In case the BusinessUnitServicePair found by the `where` argument doesn't exist, create a new BusinessUnitServicePair with this data.
     */
    create: XOR<BusinessUnitServicePairCreateInput, BusinessUnitServicePairUncheckedCreateInput>
    /**
     * In case the BusinessUnitServicePair was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessUnitServicePairUpdateInput, BusinessUnitServicePairUncheckedUpdateInput>
  }

  /**
   * BusinessUnitServicePair delete
   */
  export type BusinessUnitServicePairDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitServicePair
     */
    select?: BusinessUnitServicePairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitServicePair
     */
    omit?: BusinessUnitServicePairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitServicePairInclude<ExtArgs> | null
    /**
     * Filter which BusinessUnitServicePair to delete.
     */
    where: BusinessUnitServicePairWhereUniqueInput
  }

  /**
   * BusinessUnitServicePair deleteMany
   */
  export type BusinessUnitServicePairDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessUnitServicePairs to delete
     */
    where?: BusinessUnitServicePairWhereInput
    /**
     * Limit how many BusinessUnitServicePairs to delete.
     */
    limit?: number
  }

  /**
   * BusinessUnitServicePair without action
   */
  export type BusinessUnitServicePairDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessUnitServicePair
     */
    select?: BusinessUnitServicePairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessUnitServicePair
     */
    omit?: BusinessUnitServicePairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessUnitServicePairInclude<ExtArgs> | null
  }


  /**
   * Model SalesTeamManager
   */

  export type AggregateSalesTeamManager = {
    _count: SalesTeamManagerCountAggregateOutputType | null
    _min: SalesTeamManagerMinAggregateOutputType | null
    _max: SalesTeamManagerMaxAggregateOutputType | null
  }

  export type SalesTeamManagerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    validFrom: Date | null
    validTo: Date | null
    primary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesTeamManagerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    validFrom: Date | null
    validTo: Date | null
    primary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesTeamManagerCountAggregateOutputType = {
    id: number
    userId: number
    validFrom: number
    validTo: number
    primary: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesTeamManagerMinAggregateInputType = {
    id?: true
    userId?: true
    validFrom?: true
    validTo?: true
    primary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesTeamManagerMaxAggregateInputType = {
    id?: true
    userId?: true
    validFrom?: true
    validTo?: true
    primary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesTeamManagerCountAggregateInputType = {
    id?: true
    userId?: true
    validFrom?: true
    validTo?: true
    primary?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesTeamManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesTeamManager to aggregate.
     */
    where?: SalesTeamManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeamManagers to fetch.
     */
    orderBy?: SalesTeamManagerOrderByWithRelationInput | SalesTeamManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesTeamManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeamManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeamManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesTeamManagers
    **/
    _count?: true | SalesTeamManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesTeamManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesTeamManagerMaxAggregateInputType
  }

  export type GetSalesTeamManagerAggregateType<T extends SalesTeamManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesTeamManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesTeamManager[P]>
      : GetScalarType<T[P], AggregateSalesTeamManager[P]>
  }




  export type SalesTeamManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesTeamManagerWhereInput
    orderBy?: SalesTeamManagerOrderByWithAggregationInput | SalesTeamManagerOrderByWithAggregationInput[]
    by: SalesTeamManagerScalarFieldEnum[] | SalesTeamManagerScalarFieldEnum
    having?: SalesTeamManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesTeamManagerCountAggregateInputType | true
    _min?: SalesTeamManagerMinAggregateInputType
    _max?: SalesTeamManagerMaxAggregateInputType
  }

  export type SalesTeamManagerGroupByOutputType = {
    id: string
    userId: string
    validFrom: Date
    validTo: Date | null
    primary: boolean
    createdAt: Date
    updatedAt: Date
    _count: SalesTeamManagerCountAggregateOutputType | null
    _min: SalesTeamManagerMinAggregateOutputType | null
    _max: SalesTeamManagerMaxAggregateOutputType | null
  }

  type GetSalesTeamManagerGroupByPayload<T extends SalesTeamManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesTeamManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesTeamManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesTeamManagerGroupByOutputType[P]>
            : GetScalarType<T[P], SalesTeamManagerGroupByOutputType[P]>
        }
      >
    >


  export type SalesTeamManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["salesTeamManager"]>

  export type SalesTeamManagerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["salesTeamManager"]>

  export type SalesTeamManagerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["salesTeamManager"]>

  export type SalesTeamManagerSelectScalar = {
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalesTeamManagerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "validFrom" | "validTo" | "primary" | "createdAt" | "updatedAt", ExtArgs["result"]["salesTeamManager"]>

  export type $SalesTeamManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesTeamManager"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      validFrom: Date
      validTo: Date | null
      primary: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salesTeamManager"]>
    composites: {}
  }

  type SalesTeamManagerGetPayload<S extends boolean | null | undefined | SalesTeamManagerDefaultArgs> = $Result.GetResult<Prisma.$SalesTeamManagerPayload, S>

  type SalesTeamManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesTeamManagerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesTeamManagerCountAggregateInputType | true
    }

  export interface SalesTeamManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesTeamManager'], meta: { name: 'SalesTeamManager' } }
    /**
     * Find zero or one SalesTeamManager that matches the filter.
     * @param {SalesTeamManagerFindUniqueArgs} args - Arguments to find a SalesTeamManager
     * @example
     * // Get one SalesTeamManager
     * const salesTeamManager = await prisma.salesTeamManager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesTeamManagerFindUniqueArgs>(args: SelectSubset<T, SalesTeamManagerFindUniqueArgs<ExtArgs>>): Prisma__SalesTeamManagerClient<$Result.GetResult<Prisma.$SalesTeamManagerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesTeamManager that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesTeamManagerFindUniqueOrThrowArgs} args - Arguments to find a SalesTeamManager
     * @example
     * // Get one SalesTeamManager
     * const salesTeamManager = await prisma.salesTeamManager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesTeamManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesTeamManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesTeamManagerClient<$Result.GetResult<Prisma.$SalesTeamManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesTeamManager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamManagerFindFirstArgs} args - Arguments to find a SalesTeamManager
     * @example
     * // Get one SalesTeamManager
     * const salesTeamManager = await prisma.salesTeamManager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesTeamManagerFindFirstArgs>(args?: SelectSubset<T, SalesTeamManagerFindFirstArgs<ExtArgs>>): Prisma__SalesTeamManagerClient<$Result.GetResult<Prisma.$SalesTeamManagerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesTeamManager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamManagerFindFirstOrThrowArgs} args - Arguments to find a SalesTeamManager
     * @example
     * // Get one SalesTeamManager
     * const salesTeamManager = await prisma.salesTeamManager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesTeamManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesTeamManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesTeamManagerClient<$Result.GetResult<Prisma.$SalesTeamManagerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesTeamManagers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesTeamManagers
     * const salesTeamManagers = await prisma.salesTeamManager.findMany()
     * 
     * // Get first 10 SalesTeamManagers
     * const salesTeamManagers = await prisma.salesTeamManager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesTeamManagerWithIdOnly = await prisma.salesTeamManager.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesTeamManagerFindManyArgs>(args?: SelectSubset<T, SalesTeamManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesTeamManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesTeamManager.
     * @param {SalesTeamManagerCreateArgs} args - Arguments to create a SalesTeamManager.
     * @example
     * // Create one SalesTeamManager
     * const SalesTeamManager = await prisma.salesTeamManager.create({
     *   data: {
     *     // ... data to create a SalesTeamManager
     *   }
     * })
     * 
     */
    create<T extends SalesTeamManagerCreateArgs>(args: SelectSubset<T, SalesTeamManagerCreateArgs<ExtArgs>>): Prisma__SalesTeamManagerClient<$Result.GetResult<Prisma.$SalesTeamManagerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesTeamManagers.
     * @param {SalesTeamManagerCreateManyArgs} args - Arguments to create many SalesTeamManagers.
     * @example
     * // Create many SalesTeamManagers
     * const salesTeamManager = await prisma.salesTeamManager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesTeamManagerCreateManyArgs>(args?: SelectSubset<T, SalesTeamManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesTeamManagers and returns the data saved in the database.
     * @param {SalesTeamManagerCreateManyAndReturnArgs} args - Arguments to create many SalesTeamManagers.
     * @example
     * // Create many SalesTeamManagers
     * const salesTeamManager = await prisma.salesTeamManager.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesTeamManagers and only return the `id`
     * const salesTeamManagerWithIdOnly = await prisma.salesTeamManager.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesTeamManagerCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesTeamManagerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesTeamManagerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesTeamManager.
     * @param {SalesTeamManagerDeleteArgs} args - Arguments to delete one SalesTeamManager.
     * @example
     * // Delete one SalesTeamManager
     * const SalesTeamManager = await prisma.salesTeamManager.delete({
     *   where: {
     *     // ... filter to delete one SalesTeamManager
     *   }
     * })
     * 
     */
    delete<T extends SalesTeamManagerDeleteArgs>(args: SelectSubset<T, SalesTeamManagerDeleteArgs<ExtArgs>>): Prisma__SalesTeamManagerClient<$Result.GetResult<Prisma.$SalesTeamManagerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesTeamManager.
     * @param {SalesTeamManagerUpdateArgs} args - Arguments to update one SalesTeamManager.
     * @example
     * // Update one SalesTeamManager
     * const salesTeamManager = await prisma.salesTeamManager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesTeamManagerUpdateArgs>(args: SelectSubset<T, SalesTeamManagerUpdateArgs<ExtArgs>>): Prisma__SalesTeamManagerClient<$Result.GetResult<Prisma.$SalesTeamManagerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesTeamManagers.
     * @param {SalesTeamManagerDeleteManyArgs} args - Arguments to filter SalesTeamManagers to delete.
     * @example
     * // Delete a few SalesTeamManagers
     * const { count } = await prisma.salesTeamManager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesTeamManagerDeleteManyArgs>(args?: SelectSubset<T, SalesTeamManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesTeamManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesTeamManagers
     * const salesTeamManager = await prisma.salesTeamManager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesTeamManagerUpdateManyArgs>(args: SelectSubset<T, SalesTeamManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesTeamManagers and returns the data updated in the database.
     * @param {SalesTeamManagerUpdateManyAndReturnArgs} args - Arguments to update many SalesTeamManagers.
     * @example
     * // Update many SalesTeamManagers
     * const salesTeamManager = await prisma.salesTeamManager.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesTeamManagers and only return the `id`
     * const salesTeamManagerWithIdOnly = await prisma.salesTeamManager.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesTeamManagerUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesTeamManagerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesTeamManagerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesTeamManager.
     * @param {SalesTeamManagerUpsertArgs} args - Arguments to update or create a SalesTeamManager.
     * @example
     * // Update or create a SalesTeamManager
     * const salesTeamManager = await prisma.salesTeamManager.upsert({
     *   create: {
     *     // ... data to create a SalesTeamManager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesTeamManager we want to update
     *   }
     * })
     */
    upsert<T extends SalesTeamManagerUpsertArgs>(args: SelectSubset<T, SalesTeamManagerUpsertArgs<ExtArgs>>): Prisma__SalesTeamManagerClient<$Result.GetResult<Prisma.$SalesTeamManagerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesTeamManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamManagerCountArgs} args - Arguments to filter SalesTeamManagers to count.
     * @example
     * // Count the number of SalesTeamManagers
     * const count = await prisma.salesTeamManager.count({
     *   where: {
     *     // ... the filter for the SalesTeamManagers we want to count
     *   }
     * })
    **/
    count<T extends SalesTeamManagerCountArgs>(
      args?: Subset<T, SalesTeamManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesTeamManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesTeamManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesTeamManagerAggregateArgs>(args: Subset<T, SalesTeamManagerAggregateArgs>): Prisma.PrismaPromise<GetSalesTeamManagerAggregateType<T>>

    /**
     * Group by SalesTeamManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesTeamManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesTeamManagerGroupByArgs['orderBy'] }
        : { orderBy?: SalesTeamManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesTeamManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesTeamManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesTeamManager model
   */
  readonly fields: SalesTeamManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesTeamManager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesTeamManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesTeamManager model
   */
  interface SalesTeamManagerFieldRefs {
    readonly id: FieldRef<"SalesTeamManager", 'String'>
    readonly userId: FieldRef<"SalesTeamManager", 'String'>
    readonly validFrom: FieldRef<"SalesTeamManager", 'DateTime'>
    readonly validTo: FieldRef<"SalesTeamManager", 'DateTime'>
    readonly primary: FieldRef<"SalesTeamManager", 'Boolean'>
    readonly createdAt: FieldRef<"SalesTeamManager", 'DateTime'>
    readonly updatedAt: FieldRef<"SalesTeamManager", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesTeamManager findUnique
   */
  export type SalesTeamManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamManager
     */
    select?: SalesTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamManager
     */
    omit?: SalesTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which SalesTeamManager to fetch.
     */
    where: SalesTeamManagerWhereUniqueInput
  }

  /**
   * SalesTeamManager findUniqueOrThrow
   */
  export type SalesTeamManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamManager
     */
    select?: SalesTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamManager
     */
    omit?: SalesTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which SalesTeamManager to fetch.
     */
    where: SalesTeamManagerWhereUniqueInput
  }

  /**
   * SalesTeamManager findFirst
   */
  export type SalesTeamManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamManager
     */
    select?: SalesTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamManager
     */
    omit?: SalesTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which SalesTeamManager to fetch.
     */
    where?: SalesTeamManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeamManagers to fetch.
     */
    orderBy?: SalesTeamManagerOrderByWithRelationInput | SalesTeamManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesTeamManagers.
     */
    cursor?: SalesTeamManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeamManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeamManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesTeamManagers.
     */
    distinct?: SalesTeamManagerScalarFieldEnum | SalesTeamManagerScalarFieldEnum[]
  }

  /**
   * SalesTeamManager findFirstOrThrow
   */
  export type SalesTeamManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamManager
     */
    select?: SalesTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamManager
     */
    omit?: SalesTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which SalesTeamManager to fetch.
     */
    where?: SalesTeamManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeamManagers to fetch.
     */
    orderBy?: SalesTeamManagerOrderByWithRelationInput | SalesTeamManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesTeamManagers.
     */
    cursor?: SalesTeamManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeamManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeamManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesTeamManagers.
     */
    distinct?: SalesTeamManagerScalarFieldEnum | SalesTeamManagerScalarFieldEnum[]
  }

  /**
   * SalesTeamManager findMany
   */
  export type SalesTeamManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamManager
     */
    select?: SalesTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamManager
     */
    omit?: SalesTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which SalesTeamManagers to fetch.
     */
    where?: SalesTeamManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeamManagers to fetch.
     */
    orderBy?: SalesTeamManagerOrderByWithRelationInput | SalesTeamManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesTeamManagers.
     */
    cursor?: SalesTeamManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeamManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeamManagers.
     */
    skip?: number
    distinct?: SalesTeamManagerScalarFieldEnum | SalesTeamManagerScalarFieldEnum[]
  }

  /**
   * SalesTeamManager create
   */
  export type SalesTeamManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamManager
     */
    select?: SalesTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamManager
     */
    omit?: SalesTeamManagerOmit<ExtArgs> | null
    /**
     * The data needed to create a SalesTeamManager.
     */
    data: XOR<SalesTeamManagerCreateInput, SalesTeamManagerUncheckedCreateInput>
  }

  /**
   * SalesTeamManager createMany
   */
  export type SalesTeamManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesTeamManagers.
     */
    data: SalesTeamManagerCreateManyInput | SalesTeamManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesTeamManager createManyAndReturn
   */
  export type SalesTeamManagerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamManager
     */
    select?: SalesTeamManagerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamManager
     */
    omit?: SalesTeamManagerOmit<ExtArgs> | null
    /**
     * The data used to create many SalesTeamManagers.
     */
    data: SalesTeamManagerCreateManyInput | SalesTeamManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesTeamManager update
   */
  export type SalesTeamManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamManager
     */
    select?: SalesTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamManager
     */
    omit?: SalesTeamManagerOmit<ExtArgs> | null
    /**
     * The data needed to update a SalesTeamManager.
     */
    data: XOR<SalesTeamManagerUpdateInput, SalesTeamManagerUncheckedUpdateInput>
    /**
     * Choose, which SalesTeamManager to update.
     */
    where: SalesTeamManagerWhereUniqueInput
  }

  /**
   * SalesTeamManager updateMany
   */
  export type SalesTeamManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesTeamManagers.
     */
    data: XOR<SalesTeamManagerUpdateManyMutationInput, SalesTeamManagerUncheckedUpdateManyInput>
    /**
     * Filter which SalesTeamManagers to update
     */
    where?: SalesTeamManagerWhereInput
    /**
     * Limit how many SalesTeamManagers to update.
     */
    limit?: number
  }

  /**
   * SalesTeamManager updateManyAndReturn
   */
  export type SalesTeamManagerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamManager
     */
    select?: SalesTeamManagerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamManager
     */
    omit?: SalesTeamManagerOmit<ExtArgs> | null
    /**
     * The data used to update SalesTeamManagers.
     */
    data: XOR<SalesTeamManagerUpdateManyMutationInput, SalesTeamManagerUncheckedUpdateManyInput>
    /**
     * Filter which SalesTeamManagers to update
     */
    where?: SalesTeamManagerWhereInput
    /**
     * Limit how many SalesTeamManagers to update.
     */
    limit?: number
  }

  /**
   * SalesTeamManager upsert
   */
  export type SalesTeamManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamManager
     */
    select?: SalesTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamManager
     */
    omit?: SalesTeamManagerOmit<ExtArgs> | null
    /**
     * The filter to search for the SalesTeamManager to update in case it exists.
     */
    where: SalesTeamManagerWhereUniqueInput
    /**
     * In case the SalesTeamManager found by the `where` argument doesn't exist, create a new SalesTeamManager with this data.
     */
    create: XOR<SalesTeamManagerCreateInput, SalesTeamManagerUncheckedCreateInput>
    /**
     * In case the SalesTeamManager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesTeamManagerUpdateInput, SalesTeamManagerUncheckedUpdateInput>
  }

  /**
   * SalesTeamManager delete
   */
  export type SalesTeamManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamManager
     */
    select?: SalesTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamManager
     */
    omit?: SalesTeamManagerOmit<ExtArgs> | null
    /**
     * Filter which SalesTeamManager to delete.
     */
    where: SalesTeamManagerWhereUniqueInput
  }

  /**
   * SalesTeamManager deleteMany
   */
  export type SalesTeamManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesTeamManagers to delete
     */
    where?: SalesTeamManagerWhereInput
    /**
     * Limit how many SalesTeamManagers to delete.
     */
    limit?: number
  }

  /**
   * SalesTeamManager without action
   */
  export type SalesTeamManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamManager
     */
    select?: SalesTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamManager
     */
    omit?: SalesTeamManagerOmit<ExtArgs> | null
  }


  /**
   * Model MarketingTeamManager
   */

  export type AggregateMarketingTeamManager = {
    _count: MarketingTeamManagerCountAggregateOutputType | null
    _min: MarketingTeamManagerMinAggregateOutputType | null
    _max: MarketingTeamManagerMaxAggregateOutputType | null
  }

  export type MarketingTeamManagerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    validFrom: Date | null
    validTo: Date | null
    primary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketingTeamManagerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    validFrom: Date | null
    validTo: Date | null
    primary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketingTeamManagerCountAggregateOutputType = {
    id: number
    userId: number
    validFrom: number
    validTo: number
    primary: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarketingTeamManagerMinAggregateInputType = {
    id?: true
    userId?: true
    validFrom?: true
    validTo?: true
    primary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketingTeamManagerMaxAggregateInputType = {
    id?: true
    userId?: true
    validFrom?: true
    validTo?: true
    primary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketingTeamManagerCountAggregateInputType = {
    id?: true
    userId?: true
    validFrom?: true
    validTo?: true
    primary?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarketingTeamManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingTeamManager to aggregate.
     */
    where?: MarketingTeamManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingTeamManagers to fetch.
     */
    orderBy?: MarketingTeamManagerOrderByWithRelationInput | MarketingTeamManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketingTeamManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingTeamManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingTeamManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketingTeamManagers
    **/
    _count?: true | MarketingTeamManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketingTeamManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketingTeamManagerMaxAggregateInputType
  }

  export type GetMarketingTeamManagerAggregateType<T extends MarketingTeamManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketingTeamManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketingTeamManager[P]>
      : GetScalarType<T[P], AggregateMarketingTeamManager[P]>
  }




  export type MarketingTeamManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketingTeamManagerWhereInput
    orderBy?: MarketingTeamManagerOrderByWithAggregationInput | MarketingTeamManagerOrderByWithAggregationInput[]
    by: MarketingTeamManagerScalarFieldEnum[] | MarketingTeamManagerScalarFieldEnum
    having?: MarketingTeamManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketingTeamManagerCountAggregateInputType | true
    _min?: MarketingTeamManagerMinAggregateInputType
    _max?: MarketingTeamManagerMaxAggregateInputType
  }

  export type MarketingTeamManagerGroupByOutputType = {
    id: string
    userId: string
    validFrom: Date
    validTo: Date | null
    primary: boolean
    createdAt: Date
    updatedAt: Date
    _count: MarketingTeamManagerCountAggregateOutputType | null
    _min: MarketingTeamManagerMinAggregateOutputType | null
    _max: MarketingTeamManagerMaxAggregateOutputType | null
  }

  type GetMarketingTeamManagerGroupByPayload<T extends MarketingTeamManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketingTeamManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketingTeamManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketingTeamManagerGroupByOutputType[P]>
            : GetScalarType<T[P], MarketingTeamManagerGroupByOutputType[P]>
        }
      >
    >


  export type MarketingTeamManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketingTeamManager"]>

  export type MarketingTeamManagerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketingTeamManager"]>

  export type MarketingTeamManagerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketingTeamManager"]>

  export type MarketingTeamManagerSelectScalar = {
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MarketingTeamManagerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "validFrom" | "validTo" | "primary" | "createdAt" | "updatedAt", ExtArgs["result"]["marketingTeamManager"]>

  export type $MarketingTeamManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketingTeamManager"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      validFrom: Date
      validTo: Date | null
      primary: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["marketingTeamManager"]>
    composites: {}
  }

  type MarketingTeamManagerGetPayload<S extends boolean | null | undefined | MarketingTeamManagerDefaultArgs> = $Result.GetResult<Prisma.$MarketingTeamManagerPayload, S>

  type MarketingTeamManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketingTeamManagerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketingTeamManagerCountAggregateInputType | true
    }

  export interface MarketingTeamManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketingTeamManager'], meta: { name: 'MarketingTeamManager' } }
    /**
     * Find zero or one MarketingTeamManager that matches the filter.
     * @param {MarketingTeamManagerFindUniqueArgs} args - Arguments to find a MarketingTeamManager
     * @example
     * // Get one MarketingTeamManager
     * const marketingTeamManager = await prisma.marketingTeamManager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketingTeamManagerFindUniqueArgs>(args: SelectSubset<T, MarketingTeamManagerFindUniqueArgs<ExtArgs>>): Prisma__MarketingTeamManagerClient<$Result.GetResult<Prisma.$MarketingTeamManagerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketingTeamManager that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketingTeamManagerFindUniqueOrThrowArgs} args - Arguments to find a MarketingTeamManager
     * @example
     * // Get one MarketingTeamManager
     * const marketingTeamManager = await prisma.marketingTeamManager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketingTeamManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketingTeamManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketingTeamManagerClient<$Result.GetResult<Prisma.$MarketingTeamManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketingTeamManager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamManagerFindFirstArgs} args - Arguments to find a MarketingTeamManager
     * @example
     * // Get one MarketingTeamManager
     * const marketingTeamManager = await prisma.marketingTeamManager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketingTeamManagerFindFirstArgs>(args?: SelectSubset<T, MarketingTeamManagerFindFirstArgs<ExtArgs>>): Prisma__MarketingTeamManagerClient<$Result.GetResult<Prisma.$MarketingTeamManagerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketingTeamManager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamManagerFindFirstOrThrowArgs} args - Arguments to find a MarketingTeamManager
     * @example
     * // Get one MarketingTeamManager
     * const marketingTeamManager = await prisma.marketingTeamManager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketingTeamManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketingTeamManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketingTeamManagerClient<$Result.GetResult<Prisma.$MarketingTeamManagerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketingTeamManagers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketingTeamManagers
     * const marketingTeamManagers = await prisma.marketingTeamManager.findMany()
     * 
     * // Get first 10 MarketingTeamManagers
     * const marketingTeamManagers = await prisma.marketingTeamManager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketingTeamManagerWithIdOnly = await prisma.marketingTeamManager.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketingTeamManagerFindManyArgs>(args?: SelectSubset<T, MarketingTeamManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingTeamManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketingTeamManager.
     * @param {MarketingTeamManagerCreateArgs} args - Arguments to create a MarketingTeamManager.
     * @example
     * // Create one MarketingTeamManager
     * const MarketingTeamManager = await prisma.marketingTeamManager.create({
     *   data: {
     *     // ... data to create a MarketingTeamManager
     *   }
     * })
     * 
     */
    create<T extends MarketingTeamManagerCreateArgs>(args: SelectSubset<T, MarketingTeamManagerCreateArgs<ExtArgs>>): Prisma__MarketingTeamManagerClient<$Result.GetResult<Prisma.$MarketingTeamManagerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketingTeamManagers.
     * @param {MarketingTeamManagerCreateManyArgs} args - Arguments to create many MarketingTeamManagers.
     * @example
     * // Create many MarketingTeamManagers
     * const marketingTeamManager = await prisma.marketingTeamManager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketingTeamManagerCreateManyArgs>(args?: SelectSubset<T, MarketingTeamManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketingTeamManagers and returns the data saved in the database.
     * @param {MarketingTeamManagerCreateManyAndReturnArgs} args - Arguments to create many MarketingTeamManagers.
     * @example
     * // Create many MarketingTeamManagers
     * const marketingTeamManager = await prisma.marketingTeamManager.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketingTeamManagers and only return the `id`
     * const marketingTeamManagerWithIdOnly = await prisma.marketingTeamManager.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketingTeamManagerCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketingTeamManagerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingTeamManagerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MarketingTeamManager.
     * @param {MarketingTeamManagerDeleteArgs} args - Arguments to delete one MarketingTeamManager.
     * @example
     * // Delete one MarketingTeamManager
     * const MarketingTeamManager = await prisma.marketingTeamManager.delete({
     *   where: {
     *     // ... filter to delete one MarketingTeamManager
     *   }
     * })
     * 
     */
    delete<T extends MarketingTeamManagerDeleteArgs>(args: SelectSubset<T, MarketingTeamManagerDeleteArgs<ExtArgs>>): Prisma__MarketingTeamManagerClient<$Result.GetResult<Prisma.$MarketingTeamManagerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketingTeamManager.
     * @param {MarketingTeamManagerUpdateArgs} args - Arguments to update one MarketingTeamManager.
     * @example
     * // Update one MarketingTeamManager
     * const marketingTeamManager = await prisma.marketingTeamManager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketingTeamManagerUpdateArgs>(args: SelectSubset<T, MarketingTeamManagerUpdateArgs<ExtArgs>>): Prisma__MarketingTeamManagerClient<$Result.GetResult<Prisma.$MarketingTeamManagerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketingTeamManagers.
     * @param {MarketingTeamManagerDeleteManyArgs} args - Arguments to filter MarketingTeamManagers to delete.
     * @example
     * // Delete a few MarketingTeamManagers
     * const { count } = await prisma.marketingTeamManager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketingTeamManagerDeleteManyArgs>(args?: SelectSubset<T, MarketingTeamManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketingTeamManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketingTeamManagers
     * const marketingTeamManager = await prisma.marketingTeamManager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketingTeamManagerUpdateManyArgs>(args: SelectSubset<T, MarketingTeamManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketingTeamManagers and returns the data updated in the database.
     * @param {MarketingTeamManagerUpdateManyAndReturnArgs} args - Arguments to update many MarketingTeamManagers.
     * @example
     * // Update many MarketingTeamManagers
     * const marketingTeamManager = await prisma.marketingTeamManager.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MarketingTeamManagers and only return the `id`
     * const marketingTeamManagerWithIdOnly = await prisma.marketingTeamManager.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MarketingTeamManagerUpdateManyAndReturnArgs>(args: SelectSubset<T, MarketingTeamManagerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingTeamManagerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MarketingTeamManager.
     * @param {MarketingTeamManagerUpsertArgs} args - Arguments to update or create a MarketingTeamManager.
     * @example
     * // Update or create a MarketingTeamManager
     * const marketingTeamManager = await prisma.marketingTeamManager.upsert({
     *   create: {
     *     // ... data to create a MarketingTeamManager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketingTeamManager we want to update
     *   }
     * })
     */
    upsert<T extends MarketingTeamManagerUpsertArgs>(args: SelectSubset<T, MarketingTeamManagerUpsertArgs<ExtArgs>>): Prisma__MarketingTeamManagerClient<$Result.GetResult<Prisma.$MarketingTeamManagerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MarketingTeamManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamManagerCountArgs} args - Arguments to filter MarketingTeamManagers to count.
     * @example
     * // Count the number of MarketingTeamManagers
     * const count = await prisma.marketingTeamManager.count({
     *   where: {
     *     // ... the filter for the MarketingTeamManagers we want to count
     *   }
     * })
    **/
    count<T extends MarketingTeamManagerCountArgs>(
      args?: Subset<T, MarketingTeamManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketingTeamManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketingTeamManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketingTeamManagerAggregateArgs>(args: Subset<T, MarketingTeamManagerAggregateArgs>): Prisma.PrismaPromise<GetMarketingTeamManagerAggregateType<T>>

    /**
     * Group by MarketingTeamManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketingTeamManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketingTeamManagerGroupByArgs['orderBy'] }
        : { orderBy?: MarketingTeamManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketingTeamManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketingTeamManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketingTeamManager model
   */
  readonly fields: MarketingTeamManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketingTeamManager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketingTeamManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketingTeamManager model
   */
  interface MarketingTeamManagerFieldRefs {
    readonly id: FieldRef<"MarketingTeamManager", 'String'>
    readonly userId: FieldRef<"MarketingTeamManager", 'String'>
    readonly validFrom: FieldRef<"MarketingTeamManager", 'DateTime'>
    readonly validTo: FieldRef<"MarketingTeamManager", 'DateTime'>
    readonly primary: FieldRef<"MarketingTeamManager", 'Boolean'>
    readonly createdAt: FieldRef<"MarketingTeamManager", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketingTeamManager", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketingTeamManager findUnique
   */
  export type MarketingTeamManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamManager
     */
    select?: MarketingTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamManager
     */
    omit?: MarketingTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which MarketingTeamManager to fetch.
     */
    where: MarketingTeamManagerWhereUniqueInput
  }

  /**
   * MarketingTeamManager findUniqueOrThrow
   */
  export type MarketingTeamManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamManager
     */
    select?: MarketingTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamManager
     */
    omit?: MarketingTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which MarketingTeamManager to fetch.
     */
    where: MarketingTeamManagerWhereUniqueInput
  }

  /**
   * MarketingTeamManager findFirst
   */
  export type MarketingTeamManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamManager
     */
    select?: MarketingTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamManager
     */
    omit?: MarketingTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which MarketingTeamManager to fetch.
     */
    where?: MarketingTeamManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingTeamManagers to fetch.
     */
    orderBy?: MarketingTeamManagerOrderByWithRelationInput | MarketingTeamManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingTeamManagers.
     */
    cursor?: MarketingTeamManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingTeamManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingTeamManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingTeamManagers.
     */
    distinct?: MarketingTeamManagerScalarFieldEnum | MarketingTeamManagerScalarFieldEnum[]
  }

  /**
   * MarketingTeamManager findFirstOrThrow
   */
  export type MarketingTeamManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamManager
     */
    select?: MarketingTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamManager
     */
    omit?: MarketingTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which MarketingTeamManager to fetch.
     */
    where?: MarketingTeamManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingTeamManagers to fetch.
     */
    orderBy?: MarketingTeamManagerOrderByWithRelationInput | MarketingTeamManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingTeamManagers.
     */
    cursor?: MarketingTeamManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingTeamManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingTeamManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingTeamManagers.
     */
    distinct?: MarketingTeamManagerScalarFieldEnum | MarketingTeamManagerScalarFieldEnum[]
  }

  /**
   * MarketingTeamManager findMany
   */
  export type MarketingTeamManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamManager
     */
    select?: MarketingTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamManager
     */
    omit?: MarketingTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which MarketingTeamManagers to fetch.
     */
    where?: MarketingTeamManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingTeamManagers to fetch.
     */
    orderBy?: MarketingTeamManagerOrderByWithRelationInput | MarketingTeamManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketingTeamManagers.
     */
    cursor?: MarketingTeamManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingTeamManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingTeamManagers.
     */
    skip?: number
    distinct?: MarketingTeamManagerScalarFieldEnum | MarketingTeamManagerScalarFieldEnum[]
  }

  /**
   * MarketingTeamManager create
   */
  export type MarketingTeamManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamManager
     */
    select?: MarketingTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamManager
     */
    omit?: MarketingTeamManagerOmit<ExtArgs> | null
    /**
     * The data needed to create a MarketingTeamManager.
     */
    data: XOR<MarketingTeamManagerCreateInput, MarketingTeamManagerUncheckedCreateInput>
  }

  /**
   * MarketingTeamManager createMany
   */
  export type MarketingTeamManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketingTeamManagers.
     */
    data: MarketingTeamManagerCreateManyInput | MarketingTeamManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketingTeamManager createManyAndReturn
   */
  export type MarketingTeamManagerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamManager
     */
    select?: MarketingTeamManagerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamManager
     */
    omit?: MarketingTeamManagerOmit<ExtArgs> | null
    /**
     * The data used to create many MarketingTeamManagers.
     */
    data: MarketingTeamManagerCreateManyInput | MarketingTeamManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketingTeamManager update
   */
  export type MarketingTeamManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamManager
     */
    select?: MarketingTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamManager
     */
    omit?: MarketingTeamManagerOmit<ExtArgs> | null
    /**
     * The data needed to update a MarketingTeamManager.
     */
    data: XOR<MarketingTeamManagerUpdateInput, MarketingTeamManagerUncheckedUpdateInput>
    /**
     * Choose, which MarketingTeamManager to update.
     */
    where: MarketingTeamManagerWhereUniqueInput
  }

  /**
   * MarketingTeamManager updateMany
   */
  export type MarketingTeamManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketingTeamManagers.
     */
    data: XOR<MarketingTeamManagerUpdateManyMutationInput, MarketingTeamManagerUncheckedUpdateManyInput>
    /**
     * Filter which MarketingTeamManagers to update
     */
    where?: MarketingTeamManagerWhereInput
    /**
     * Limit how many MarketingTeamManagers to update.
     */
    limit?: number
  }

  /**
   * MarketingTeamManager updateManyAndReturn
   */
  export type MarketingTeamManagerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamManager
     */
    select?: MarketingTeamManagerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamManager
     */
    omit?: MarketingTeamManagerOmit<ExtArgs> | null
    /**
     * The data used to update MarketingTeamManagers.
     */
    data: XOR<MarketingTeamManagerUpdateManyMutationInput, MarketingTeamManagerUncheckedUpdateManyInput>
    /**
     * Filter which MarketingTeamManagers to update
     */
    where?: MarketingTeamManagerWhereInput
    /**
     * Limit how many MarketingTeamManagers to update.
     */
    limit?: number
  }

  /**
   * MarketingTeamManager upsert
   */
  export type MarketingTeamManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamManager
     */
    select?: MarketingTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamManager
     */
    omit?: MarketingTeamManagerOmit<ExtArgs> | null
    /**
     * The filter to search for the MarketingTeamManager to update in case it exists.
     */
    where: MarketingTeamManagerWhereUniqueInput
    /**
     * In case the MarketingTeamManager found by the `where` argument doesn't exist, create a new MarketingTeamManager with this data.
     */
    create: XOR<MarketingTeamManagerCreateInput, MarketingTeamManagerUncheckedCreateInput>
    /**
     * In case the MarketingTeamManager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketingTeamManagerUpdateInput, MarketingTeamManagerUncheckedUpdateInput>
  }

  /**
   * MarketingTeamManager delete
   */
  export type MarketingTeamManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamManager
     */
    select?: MarketingTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamManager
     */
    omit?: MarketingTeamManagerOmit<ExtArgs> | null
    /**
     * Filter which MarketingTeamManager to delete.
     */
    where: MarketingTeamManagerWhereUniqueInput
  }

  /**
   * MarketingTeamManager deleteMany
   */
  export type MarketingTeamManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingTeamManagers to delete
     */
    where?: MarketingTeamManagerWhereInput
    /**
     * Limit how many MarketingTeamManagers to delete.
     */
    limit?: number
  }

  /**
   * MarketingTeamManager without action
   */
  export type MarketingTeamManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamManager
     */
    select?: MarketingTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamManager
     */
    omit?: MarketingTeamManagerOmit<ExtArgs> | null
  }


  /**
   * Model ServiceTeamManager
   */

  export type AggregateServiceTeamManager = {
    _count: ServiceTeamManagerCountAggregateOutputType | null
    _min: ServiceTeamManagerMinAggregateOutputType | null
    _max: ServiceTeamManagerMaxAggregateOutputType | null
  }

  export type ServiceTeamManagerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    validFrom: Date | null
    validTo: Date | null
    primary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceTeamManagerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    validFrom: Date | null
    validTo: Date | null
    primary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceTeamManagerCountAggregateOutputType = {
    id: number
    userId: number
    validFrom: number
    validTo: number
    primary: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceTeamManagerMinAggregateInputType = {
    id?: true
    userId?: true
    validFrom?: true
    validTo?: true
    primary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceTeamManagerMaxAggregateInputType = {
    id?: true
    userId?: true
    validFrom?: true
    validTo?: true
    primary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceTeamManagerCountAggregateInputType = {
    id?: true
    userId?: true
    validFrom?: true
    validTo?: true
    primary?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceTeamManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceTeamManager to aggregate.
     */
    where?: ServiceTeamManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTeamManagers to fetch.
     */
    orderBy?: ServiceTeamManagerOrderByWithRelationInput | ServiceTeamManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceTeamManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTeamManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTeamManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceTeamManagers
    **/
    _count?: true | ServiceTeamManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceTeamManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceTeamManagerMaxAggregateInputType
  }

  export type GetServiceTeamManagerAggregateType<T extends ServiceTeamManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceTeamManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceTeamManager[P]>
      : GetScalarType<T[P], AggregateServiceTeamManager[P]>
  }




  export type ServiceTeamManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceTeamManagerWhereInput
    orderBy?: ServiceTeamManagerOrderByWithAggregationInput | ServiceTeamManagerOrderByWithAggregationInput[]
    by: ServiceTeamManagerScalarFieldEnum[] | ServiceTeamManagerScalarFieldEnum
    having?: ServiceTeamManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceTeamManagerCountAggregateInputType | true
    _min?: ServiceTeamManagerMinAggregateInputType
    _max?: ServiceTeamManagerMaxAggregateInputType
  }

  export type ServiceTeamManagerGroupByOutputType = {
    id: string
    userId: string
    validFrom: Date
    validTo: Date | null
    primary: boolean
    createdAt: Date
    updatedAt: Date
    _count: ServiceTeamManagerCountAggregateOutputType | null
    _min: ServiceTeamManagerMinAggregateOutputType | null
    _max: ServiceTeamManagerMaxAggregateOutputType | null
  }

  type GetServiceTeamManagerGroupByPayload<T extends ServiceTeamManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceTeamManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceTeamManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceTeamManagerGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceTeamManagerGroupByOutputType[P]>
        }
      >
    >


  export type ServiceTeamManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceTeamManager"]>

  export type ServiceTeamManagerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceTeamManager"]>

  export type ServiceTeamManagerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceTeamManager"]>

  export type ServiceTeamManagerSelectScalar = {
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceTeamManagerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "validFrom" | "validTo" | "primary" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceTeamManager"]>

  export type $ServiceTeamManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceTeamManager"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      validFrom: Date
      validTo: Date | null
      primary: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceTeamManager"]>
    composites: {}
  }

  type ServiceTeamManagerGetPayload<S extends boolean | null | undefined | ServiceTeamManagerDefaultArgs> = $Result.GetResult<Prisma.$ServiceTeamManagerPayload, S>

  type ServiceTeamManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceTeamManagerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceTeamManagerCountAggregateInputType | true
    }

  export interface ServiceTeamManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceTeamManager'], meta: { name: 'ServiceTeamManager' } }
    /**
     * Find zero or one ServiceTeamManager that matches the filter.
     * @param {ServiceTeamManagerFindUniqueArgs} args - Arguments to find a ServiceTeamManager
     * @example
     * // Get one ServiceTeamManager
     * const serviceTeamManager = await prisma.serviceTeamManager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceTeamManagerFindUniqueArgs>(args: SelectSubset<T, ServiceTeamManagerFindUniqueArgs<ExtArgs>>): Prisma__ServiceTeamManagerClient<$Result.GetResult<Prisma.$ServiceTeamManagerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceTeamManager that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceTeamManagerFindUniqueOrThrowArgs} args - Arguments to find a ServiceTeamManager
     * @example
     * // Get one ServiceTeamManager
     * const serviceTeamManager = await prisma.serviceTeamManager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceTeamManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceTeamManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceTeamManagerClient<$Result.GetResult<Prisma.$ServiceTeamManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceTeamManager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamManagerFindFirstArgs} args - Arguments to find a ServiceTeamManager
     * @example
     * // Get one ServiceTeamManager
     * const serviceTeamManager = await prisma.serviceTeamManager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceTeamManagerFindFirstArgs>(args?: SelectSubset<T, ServiceTeamManagerFindFirstArgs<ExtArgs>>): Prisma__ServiceTeamManagerClient<$Result.GetResult<Prisma.$ServiceTeamManagerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceTeamManager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamManagerFindFirstOrThrowArgs} args - Arguments to find a ServiceTeamManager
     * @example
     * // Get one ServiceTeamManager
     * const serviceTeamManager = await prisma.serviceTeamManager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceTeamManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceTeamManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceTeamManagerClient<$Result.GetResult<Prisma.$ServiceTeamManagerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceTeamManagers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceTeamManagers
     * const serviceTeamManagers = await prisma.serviceTeamManager.findMany()
     * 
     * // Get first 10 ServiceTeamManagers
     * const serviceTeamManagers = await prisma.serviceTeamManager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceTeamManagerWithIdOnly = await prisma.serviceTeamManager.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceTeamManagerFindManyArgs>(args?: SelectSubset<T, ServiceTeamManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTeamManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceTeamManager.
     * @param {ServiceTeamManagerCreateArgs} args - Arguments to create a ServiceTeamManager.
     * @example
     * // Create one ServiceTeamManager
     * const ServiceTeamManager = await prisma.serviceTeamManager.create({
     *   data: {
     *     // ... data to create a ServiceTeamManager
     *   }
     * })
     * 
     */
    create<T extends ServiceTeamManagerCreateArgs>(args: SelectSubset<T, ServiceTeamManagerCreateArgs<ExtArgs>>): Prisma__ServiceTeamManagerClient<$Result.GetResult<Prisma.$ServiceTeamManagerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceTeamManagers.
     * @param {ServiceTeamManagerCreateManyArgs} args - Arguments to create many ServiceTeamManagers.
     * @example
     * // Create many ServiceTeamManagers
     * const serviceTeamManager = await prisma.serviceTeamManager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceTeamManagerCreateManyArgs>(args?: SelectSubset<T, ServiceTeamManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceTeamManagers and returns the data saved in the database.
     * @param {ServiceTeamManagerCreateManyAndReturnArgs} args - Arguments to create many ServiceTeamManagers.
     * @example
     * // Create many ServiceTeamManagers
     * const serviceTeamManager = await prisma.serviceTeamManager.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceTeamManagers and only return the `id`
     * const serviceTeamManagerWithIdOnly = await prisma.serviceTeamManager.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceTeamManagerCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceTeamManagerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTeamManagerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceTeamManager.
     * @param {ServiceTeamManagerDeleteArgs} args - Arguments to delete one ServiceTeamManager.
     * @example
     * // Delete one ServiceTeamManager
     * const ServiceTeamManager = await prisma.serviceTeamManager.delete({
     *   where: {
     *     // ... filter to delete one ServiceTeamManager
     *   }
     * })
     * 
     */
    delete<T extends ServiceTeamManagerDeleteArgs>(args: SelectSubset<T, ServiceTeamManagerDeleteArgs<ExtArgs>>): Prisma__ServiceTeamManagerClient<$Result.GetResult<Prisma.$ServiceTeamManagerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceTeamManager.
     * @param {ServiceTeamManagerUpdateArgs} args - Arguments to update one ServiceTeamManager.
     * @example
     * // Update one ServiceTeamManager
     * const serviceTeamManager = await prisma.serviceTeamManager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceTeamManagerUpdateArgs>(args: SelectSubset<T, ServiceTeamManagerUpdateArgs<ExtArgs>>): Prisma__ServiceTeamManagerClient<$Result.GetResult<Prisma.$ServiceTeamManagerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceTeamManagers.
     * @param {ServiceTeamManagerDeleteManyArgs} args - Arguments to filter ServiceTeamManagers to delete.
     * @example
     * // Delete a few ServiceTeamManagers
     * const { count } = await prisma.serviceTeamManager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceTeamManagerDeleteManyArgs>(args?: SelectSubset<T, ServiceTeamManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceTeamManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceTeamManagers
     * const serviceTeamManager = await prisma.serviceTeamManager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceTeamManagerUpdateManyArgs>(args: SelectSubset<T, ServiceTeamManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceTeamManagers and returns the data updated in the database.
     * @param {ServiceTeamManagerUpdateManyAndReturnArgs} args - Arguments to update many ServiceTeamManagers.
     * @example
     * // Update many ServiceTeamManagers
     * const serviceTeamManager = await prisma.serviceTeamManager.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceTeamManagers and only return the `id`
     * const serviceTeamManagerWithIdOnly = await prisma.serviceTeamManager.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceTeamManagerUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceTeamManagerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTeamManagerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceTeamManager.
     * @param {ServiceTeamManagerUpsertArgs} args - Arguments to update or create a ServiceTeamManager.
     * @example
     * // Update or create a ServiceTeamManager
     * const serviceTeamManager = await prisma.serviceTeamManager.upsert({
     *   create: {
     *     // ... data to create a ServiceTeamManager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceTeamManager we want to update
     *   }
     * })
     */
    upsert<T extends ServiceTeamManagerUpsertArgs>(args: SelectSubset<T, ServiceTeamManagerUpsertArgs<ExtArgs>>): Prisma__ServiceTeamManagerClient<$Result.GetResult<Prisma.$ServiceTeamManagerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceTeamManagers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamManagerCountArgs} args - Arguments to filter ServiceTeamManagers to count.
     * @example
     * // Count the number of ServiceTeamManagers
     * const count = await prisma.serviceTeamManager.count({
     *   where: {
     *     // ... the filter for the ServiceTeamManagers we want to count
     *   }
     * })
    **/
    count<T extends ServiceTeamManagerCountArgs>(
      args?: Subset<T, ServiceTeamManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceTeamManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceTeamManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceTeamManagerAggregateArgs>(args: Subset<T, ServiceTeamManagerAggregateArgs>): Prisma.PrismaPromise<GetServiceTeamManagerAggregateType<T>>

    /**
     * Group by ServiceTeamManager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceTeamManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceTeamManagerGroupByArgs['orderBy'] }
        : { orderBy?: ServiceTeamManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceTeamManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceTeamManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceTeamManager model
   */
  readonly fields: ServiceTeamManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceTeamManager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceTeamManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceTeamManager model
   */
  interface ServiceTeamManagerFieldRefs {
    readonly id: FieldRef<"ServiceTeamManager", 'String'>
    readonly userId: FieldRef<"ServiceTeamManager", 'String'>
    readonly validFrom: FieldRef<"ServiceTeamManager", 'DateTime'>
    readonly validTo: FieldRef<"ServiceTeamManager", 'DateTime'>
    readonly primary: FieldRef<"ServiceTeamManager", 'Boolean'>
    readonly createdAt: FieldRef<"ServiceTeamManager", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceTeamManager", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceTeamManager findUnique
   */
  export type ServiceTeamManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamManager
     */
    select?: ServiceTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamManager
     */
    omit?: ServiceTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which ServiceTeamManager to fetch.
     */
    where: ServiceTeamManagerWhereUniqueInput
  }

  /**
   * ServiceTeamManager findUniqueOrThrow
   */
  export type ServiceTeamManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamManager
     */
    select?: ServiceTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamManager
     */
    omit?: ServiceTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which ServiceTeamManager to fetch.
     */
    where: ServiceTeamManagerWhereUniqueInput
  }

  /**
   * ServiceTeamManager findFirst
   */
  export type ServiceTeamManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamManager
     */
    select?: ServiceTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamManager
     */
    omit?: ServiceTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which ServiceTeamManager to fetch.
     */
    where?: ServiceTeamManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTeamManagers to fetch.
     */
    orderBy?: ServiceTeamManagerOrderByWithRelationInput | ServiceTeamManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceTeamManagers.
     */
    cursor?: ServiceTeamManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTeamManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTeamManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceTeamManagers.
     */
    distinct?: ServiceTeamManagerScalarFieldEnum | ServiceTeamManagerScalarFieldEnum[]
  }

  /**
   * ServiceTeamManager findFirstOrThrow
   */
  export type ServiceTeamManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamManager
     */
    select?: ServiceTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamManager
     */
    omit?: ServiceTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which ServiceTeamManager to fetch.
     */
    where?: ServiceTeamManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTeamManagers to fetch.
     */
    orderBy?: ServiceTeamManagerOrderByWithRelationInput | ServiceTeamManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceTeamManagers.
     */
    cursor?: ServiceTeamManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTeamManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTeamManagers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceTeamManagers.
     */
    distinct?: ServiceTeamManagerScalarFieldEnum | ServiceTeamManagerScalarFieldEnum[]
  }

  /**
   * ServiceTeamManager findMany
   */
  export type ServiceTeamManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamManager
     */
    select?: ServiceTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamManager
     */
    omit?: ServiceTeamManagerOmit<ExtArgs> | null
    /**
     * Filter, which ServiceTeamManagers to fetch.
     */
    where?: ServiceTeamManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTeamManagers to fetch.
     */
    orderBy?: ServiceTeamManagerOrderByWithRelationInput | ServiceTeamManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceTeamManagers.
     */
    cursor?: ServiceTeamManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTeamManagers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTeamManagers.
     */
    skip?: number
    distinct?: ServiceTeamManagerScalarFieldEnum | ServiceTeamManagerScalarFieldEnum[]
  }

  /**
   * ServiceTeamManager create
   */
  export type ServiceTeamManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamManager
     */
    select?: ServiceTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamManager
     */
    omit?: ServiceTeamManagerOmit<ExtArgs> | null
    /**
     * The data needed to create a ServiceTeamManager.
     */
    data: XOR<ServiceTeamManagerCreateInput, ServiceTeamManagerUncheckedCreateInput>
  }

  /**
   * ServiceTeamManager createMany
   */
  export type ServiceTeamManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceTeamManagers.
     */
    data: ServiceTeamManagerCreateManyInput | ServiceTeamManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceTeamManager createManyAndReturn
   */
  export type ServiceTeamManagerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamManager
     */
    select?: ServiceTeamManagerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamManager
     */
    omit?: ServiceTeamManagerOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceTeamManagers.
     */
    data: ServiceTeamManagerCreateManyInput | ServiceTeamManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceTeamManager update
   */
  export type ServiceTeamManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamManager
     */
    select?: ServiceTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamManager
     */
    omit?: ServiceTeamManagerOmit<ExtArgs> | null
    /**
     * The data needed to update a ServiceTeamManager.
     */
    data: XOR<ServiceTeamManagerUpdateInput, ServiceTeamManagerUncheckedUpdateInput>
    /**
     * Choose, which ServiceTeamManager to update.
     */
    where: ServiceTeamManagerWhereUniqueInput
  }

  /**
   * ServiceTeamManager updateMany
   */
  export type ServiceTeamManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceTeamManagers.
     */
    data: XOR<ServiceTeamManagerUpdateManyMutationInput, ServiceTeamManagerUncheckedUpdateManyInput>
    /**
     * Filter which ServiceTeamManagers to update
     */
    where?: ServiceTeamManagerWhereInput
    /**
     * Limit how many ServiceTeamManagers to update.
     */
    limit?: number
  }

  /**
   * ServiceTeamManager updateManyAndReturn
   */
  export type ServiceTeamManagerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamManager
     */
    select?: ServiceTeamManagerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamManager
     */
    omit?: ServiceTeamManagerOmit<ExtArgs> | null
    /**
     * The data used to update ServiceTeamManagers.
     */
    data: XOR<ServiceTeamManagerUpdateManyMutationInput, ServiceTeamManagerUncheckedUpdateManyInput>
    /**
     * Filter which ServiceTeamManagers to update
     */
    where?: ServiceTeamManagerWhereInput
    /**
     * Limit how many ServiceTeamManagers to update.
     */
    limit?: number
  }

  /**
   * ServiceTeamManager upsert
   */
  export type ServiceTeamManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamManager
     */
    select?: ServiceTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamManager
     */
    omit?: ServiceTeamManagerOmit<ExtArgs> | null
    /**
     * The filter to search for the ServiceTeamManager to update in case it exists.
     */
    where: ServiceTeamManagerWhereUniqueInput
    /**
     * In case the ServiceTeamManager found by the `where` argument doesn't exist, create a new ServiceTeamManager with this data.
     */
    create: XOR<ServiceTeamManagerCreateInput, ServiceTeamManagerUncheckedCreateInput>
    /**
     * In case the ServiceTeamManager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceTeamManagerUpdateInput, ServiceTeamManagerUncheckedUpdateInput>
  }

  /**
   * ServiceTeamManager delete
   */
  export type ServiceTeamManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamManager
     */
    select?: ServiceTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamManager
     */
    omit?: ServiceTeamManagerOmit<ExtArgs> | null
    /**
     * Filter which ServiceTeamManager to delete.
     */
    where: ServiceTeamManagerWhereUniqueInput
  }

  /**
   * ServiceTeamManager deleteMany
   */
  export type ServiceTeamManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceTeamManagers to delete
     */
    where?: ServiceTeamManagerWhereInput
    /**
     * Limit how many ServiceTeamManagers to delete.
     */
    limit?: number
  }

  /**
   * ServiceTeamManager without action
   */
  export type ServiceTeamManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamManager
     */
    select?: ServiceTeamManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamManager
     */
    omit?: ServiceTeamManagerOmit<ExtArgs> | null
  }


  /**
   * Model SalesTeamEmployee
   */

  export type AggregateSalesTeamEmployee = {
    _count: SalesTeamEmployeeCountAggregateOutputType | null
    _min: SalesTeamEmployeeMinAggregateOutputType | null
    _max: SalesTeamEmployeeMaxAggregateOutputType | null
  }

  export type SalesTeamEmployeeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    validFrom: Date | null
    validTo: Date | null
    primary: boolean | null
    job: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesTeamEmployeeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    validFrom: Date | null
    validTo: Date | null
    primary: boolean | null
    job: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalesTeamEmployeeCountAggregateOutputType = {
    id: number
    userId: number
    validFrom: number
    validTo: number
    primary: number
    job: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalesTeamEmployeeMinAggregateInputType = {
    id?: true
    userId?: true
    validFrom?: true
    validTo?: true
    primary?: true
    job?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesTeamEmployeeMaxAggregateInputType = {
    id?: true
    userId?: true
    validFrom?: true
    validTo?: true
    primary?: true
    job?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalesTeamEmployeeCountAggregateInputType = {
    id?: true
    userId?: true
    validFrom?: true
    validTo?: true
    primary?: true
    job?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalesTeamEmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesTeamEmployee to aggregate.
     */
    where?: SalesTeamEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeamEmployees to fetch.
     */
    orderBy?: SalesTeamEmployeeOrderByWithRelationInput | SalesTeamEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesTeamEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeamEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeamEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesTeamEmployees
    **/
    _count?: true | SalesTeamEmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesTeamEmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesTeamEmployeeMaxAggregateInputType
  }

  export type GetSalesTeamEmployeeAggregateType<T extends SalesTeamEmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesTeamEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesTeamEmployee[P]>
      : GetScalarType<T[P], AggregateSalesTeamEmployee[P]>
  }




  export type SalesTeamEmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesTeamEmployeeWhereInput
    orderBy?: SalesTeamEmployeeOrderByWithAggregationInput | SalesTeamEmployeeOrderByWithAggregationInput[]
    by: SalesTeamEmployeeScalarFieldEnum[] | SalesTeamEmployeeScalarFieldEnum
    having?: SalesTeamEmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesTeamEmployeeCountAggregateInputType | true
    _min?: SalesTeamEmployeeMinAggregateInputType
    _max?: SalesTeamEmployeeMaxAggregateInputType
  }

  export type SalesTeamEmployeeGroupByOutputType = {
    id: string
    userId: string
    validFrom: Date
    validTo: Date | null
    primary: boolean
    job: string | null
    createdAt: Date
    updatedAt: Date
    _count: SalesTeamEmployeeCountAggregateOutputType | null
    _min: SalesTeamEmployeeMinAggregateOutputType | null
    _max: SalesTeamEmployeeMaxAggregateOutputType | null
  }

  type GetSalesTeamEmployeeGroupByPayload<T extends SalesTeamEmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesTeamEmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesTeamEmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesTeamEmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], SalesTeamEmployeeGroupByOutputType[P]>
        }
      >
    >


  export type SalesTeamEmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    job?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["salesTeamEmployee"]>

  export type SalesTeamEmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    job?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["salesTeamEmployee"]>

  export type SalesTeamEmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    job?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["salesTeamEmployee"]>

  export type SalesTeamEmployeeSelectScalar = {
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    job?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalesTeamEmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "validFrom" | "validTo" | "primary" | "job" | "createdAt" | "updatedAt", ExtArgs["result"]["salesTeamEmployee"]>

  export type $SalesTeamEmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesTeamEmployee"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      validFrom: Date
      validTo: Date | null
      primary: boolean
      job: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salesTeamEmployee"]>
    composites: {}
  }

  type SalesTeamEmployeeGetPayload<S extends boolean | null | undefined | SalesTeamEmployeeDefaultArgs> = $Result.GetResult<Prisma.$SalesTeamEmployeePayload, S>

  type SalesTeamEmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalesTeamEmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalesTeamEmployeeCountAggregateInputType | true
    }

  export interface SalesTeamEmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesTeamEmployee'], meta: { name: 'SalesTeamEmployee' } }
    /**
     * Find zero or one SalesTeamEmployee that matches the filter.
     * @param {SalesTeamEmployeeFindUniqueArgs} args - Arguments to find a SalesTeamEmployee
     * @example
     * // Get one SalesTeamEmployee
     * const salesTeamEmployee = await prisma.salesTeamEmployee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesTeamEmployeeFindUniqueArgs>(args: SelectSubset<T, SalesTeamEmployeeFindUniqueArgs<ExtArgs>>): Prisma__SalesTeamEmployeeClient<$Result.GetResult<Prisma.$SalesTeamEmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalesTeamEmployee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalesTeamEmployeeFindUniqueOrThrowArgs} args - Arguments to find a SalesTeamEmployee
     * @example
     * // Get one SalesTeamEmployee
     * const salesTeamEmployee = await prisma.salesTeamEmployee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesTeamEmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesTeamEmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesTeamEmployeeClient<$Result.GetResult<Prisma.$SalesTeamEmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesTeamEmployee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamEmployeeFindFirstArgs} args - Arguments to find a SalesTeamEmployee
     * @example
     * // Get one SalesTeamEmployee
     * const salesTeamEmployee = await prisma.salesTeamEmployee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesTeamEmployeeFindFirstArgs>(args?: SelectSubset<T, SalesTeamEmployeeFindFirstArgs<ExtArgs>>): Prisma__SalesTeamEmployeeClient<$Result.GetResult<Prisma.$SalesTeamEmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalesTeamEmployee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamEmployeeFindFirstOrThrowArgs} args - Arguments to find a SalesTeamEmployee
     * @example
     * // Get one SalesTeamEmployee
     * const salesTeamEmployee = await prisma.salesTeamEmployee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesTeamEmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesTeamEmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesTeamEmployeeClient<$Result.GetResult<Prisma.$SalesTeamEmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalesTeamEmployees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamEmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesTeamEmployees
     * const salesTeamEmployees = await prisma.salesTeamEmployee.findMany()
     * 
     * // Get first 10 SalesTeamEmployees
     * const salesTeamEmployees = await prisma.salesTeamEmployee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesTeamEmployeeWithIdOnly = await prisma.salesTeamEmployee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesTeamEmployeeFindManyArgs>(args?: SelectSubset<T, SalesTeamEmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesTeamEmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalesTeamEmployee.
     * @param {SalesTeamEmployeeCreateArgs} args - Arguments to create a SalesTeamEmployee.
     * @example
     * // Create one SalesTeamEmployee
     * const SalesTeamEmployee = await prisma.salesTeamEmployee.create({
     *   data: {
     *     // ... data to create a SalesTeamEmployee
     *   }
     * })
     * 
     */
    create<T extends SalesTeamEmployeeCreateArgs>(args: SelectSubset<T, SalesTeamEmployeeCreateArgs<ExtArgs>>): Prisma__SalesTeamEmployeeClient<$Result.GetResult<Prisma.$SalesTeamEmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalesTeamEmployees.
     * @param {SalesTeamEmployeeCreateManyArgs} args - Arguments to create many SalesTeamEmployees.
     * @example
     * // Create many SalesTeamEmployees
     * const salesTeamEmployee = await prisma.salesTeamEmployee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesTeamEmployeeCreateManyArgs>(args?: SelectSubset<T, SalesTeamEmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalesTeamEmployees and returns the data saved in the database.
     * @param {SalesTeamEmployeeCreateManyAndReturnArgs} args - Arguments to create many SalesTeamEmployees.
     * @example
     * // Create many SalesTeamEmployees
     * const salesTeamEmployee = await prisma.salesTeamEmployee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalesTeamEmployees and only return the `id`
     * const salesTeamEmployeeWithIdOnly = await prisma.salesTeamEmployee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalesTeamEmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, SalesTeamEmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesTeamEmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalesTeamEmployee.
     * @param {SalesTeamEmployeeDeleteArgs} args - Arguments to delete one SalesTeamEmployee.
     * @example
     * // Delete one SalesTeamEmployee
     * const SalesTeamEmployee = await prisma.salesTeamEmployee.delete({
     *   where: {
     *     // ... filter to delete one SalesTeamEmployee
     *   }
     * })
     * 
     */
    delete<T extends SalesTeamEmployeeDeleteArgs>(args: SelectSubset<T, SalesTeamEmployeeDeleteArgs<ExtArgs>>): Prisma__SalesTeamEmployeeClient<$Result.GetResult<Prisma.$SalesTeamEmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalesTeamEmployee.
     * @param {SalesTeamEmployeeUpdateArgs} args - Arguments to update one SalesTeamEmployee.
     * @example
     * // Update one SalesTeamEmployee
     * const salesTeamEmployee = await prisma.salesTeamEmployee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesTeamEmployeeUpdateArgs>(args: SelectSubset<T, SalesTeamEmployeeUpdateArgs<ExtArgs>>): Prisma__SalesTeamEmployeeClient<$Result.GetResult<Prisma.$SalesTeamEmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalesTeamEmployees.
     * @param {SalesTeamEmployeeDeleteManyArgs} args - Arguments to filter SalesTeamEmployees to delete.
     * @example
     * // Delete a few SalesTeamEmployees
     * const { count } = await prisma.salesTeamEmployee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesTeamEmployeeDeleteManyArgs>(args?: SelectSubset<T, SalesTeamEmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesTeamEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamEmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesTeamEmployees
     * const salesTeamEmployee = await prisma.salesTeamEmployee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesTeamEmployeeUpdateManyArgs>(args: SelectSubset<T, SalesTeamEmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesTeamEmployees and returns the data updated in the database.
     * @param {SalesTeamEmployeeUpdateManyAndReturnArgs} args - Arguments to update many SalesTeamEmployees.
     * @example
     * // Update many SalesTeamEmployees
     * const salesTeamEmployee = await prisma.salesTeamEmployee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalesTeamEmployees and only return the `id`
     * const salesTeamEmployeeWithIdOnly = await prisma.salesTeamEmployee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalesTeamEmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, SalesTeamEmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesTeamEmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalesTeamEmployee.
     * @param {SalesTeamEmployeeUpsertArgs} args - Arguments to update or create a SalesTeamEmployee.
     * @example
     * // Update or create a SalesTeamEmployee
     * const salesTeamEmployee = await prisma.salesTeamEmployee.upsert({
     *   create: {
     *     // ... data to create a SalesTeamEmployee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesTeamEmployee we want to update
     *   }
     * })
     */
    upsert<T extends SalesTeamEmployeeUpsertArgs>(args: SelectSubset<T, SalesTeamEmployeeUpsertArgs<ExtArgs>>): Prisma__SalesTeamEmployeeClient<$Result.GetResult<Prisma.$SalesTeamEmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalesTeamEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamEmployeeCountArgs} args - Arguments to filter SalesTeamEmployees to count.
     * @example
     * // Count the number of SalesTeamEmployees
     * const count = await prisma.salesTeamEmployee.count({
     *   where: {
     *     // ... the filter for the SalesTeamEmployees we want to count
     *   }
     * })
    **/
    count<T extends SalesTeamEmployeeCountArgs>(
      args?: Subset<T, SalesTeamEmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesTeamEmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesTeamEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamEmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesTeamEmployeeAggregateArgs>(args: Subset<T, SalesTeamEmployeeAggregateArgs>): Prisma.PrismaPromise<GetSalesTeamEmployeeAggregateType<T>>

    /**
     * Group by SalesTeamEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesTeamEmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesTeamEmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesTeamEmployeeGroupByArgs['orderBy'] }
        : { orderBy?: SalesTeamEmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesTeamEmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesTeamEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesTeamEmployee model
   */
  readonly fields: SalesTeamEmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesTeamEmployee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesTeamEmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesTeamEmployee model
   */
  interface SalesTeamEmployeeFieldRefs {
    readonly id: FieldRef<"SalesTeamEmployee", 'String'>
    readonly userId: FieldRef<"SalesTeamEmployee", 'String'>
    readonly validFrom: FieldRef<"SalesTeamEmployee", 'DateTime'>
    readonly validTo: FieldRef<"SalesTeamEmployee", 'DateTime'>
    readonly primary: FieldRef<"SalesTeamEmployee", 'Boolean'>
    readonly job: FieldRef<"SalesTeamEmployee", 'String'>
    readonly createdAt: FieldRef<"SalesTeamEmployee", 'DateTime'>
    readonly updatedAt: FieldRef<"SalesTeamEmployee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalesTeamEmployee findUnique
   */
  export type SalesTeamEmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamEmployee
     */
    select?: SalesTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamEmployee
     */
    omit?: SalesTeamEmployeeOmit<ExtArgs> | null
    /**
     * Filter, which SalesTeamEmployee to fetch.
     */
    where: SalesTeamEmployeeWhereUniqueInput
  }

  /**
   * SalesTeamEmployee findUniqueOrThrow
   */
  export type SalesTeamEmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamEmployee
     */
    select?: SalesTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamEmployee
     */
    omit?: SalesTeamEmployeeOmit<ExtArgs> | null
    /**
     * Filter, which SalesTeamEmployee to fetch.
     */
    where: SalesTeamEmployeeWhereUniqueInput
  }

  /**
   * SalesTeamEmployee findFirst
   */
  export type SalesTeamEmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamEmployee
     */
    select?: SalesTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamEmployee
     */
    omit?: SalesTeamEmployeeOmit<ExtArgs> | null
    /**
     * Filter, which SalesTeamEmployee to fetch.
     */
    where?: SalesTeamEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeamEmployees to fetch.
     */
    orderBy?: SalesTeamEmployeeOrderByWithRelationInput | SalesTeamEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesTeamEmployees.
     */
    cursor?: SalesTeamEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeamEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeamEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesTeamEmployees.
     */
    distinct?: SalesTeamEmployeeScalarFieldEnum | SalesTeamEmployeeScalarFieldEnum[]
  }

  /**
   * SalesTeamEmployee findFirstOrThrow
   */
  export type SalesTeamEmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamEmployee
     */
    select?: SalesTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamEmployee
     */
    omit?: SalesTeamEmployeeOmit<ExtArgs> | null
    /**
     * Filter, which SalesTeamEmployee to fetch.
     */
    where?: SalesTeamEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeamEmployees to fetch.
     */
    orderBy?: SalesTeamEmployeeOrderByWithRelationInput | SalesTeamEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesTeamEmployees.
     */
    cursor?: SalesTeamEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeamEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeamEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesTeamEmployees.
     */
    distinct?: SalesTeamEmployeeScalarFieldEnum | SalesTeamEmployeeScalarFieldEnum[]
  }

  /**
   * SalesTeamEmployee findMany
   */
  export type SalesTeamEmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamEmployee
     */
    select?: SalesTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamEmployee
     */
    omit?: SalesTeamEmployeeOmit<ExtArgs> | null
    /**
     * Filter, which SalesTeamEmployees to fetch.
     */
    where?: SalesTeamEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesTeamEmployees to fetch.
     */
    orderBy?: SalesTeamEmployeeOrderByWithRelationInput | SalesTeamEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesTeamEmployees.
     */
    cursor?: SalesTeamEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesTeamEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesTeamEmployees.
     */
    skip?: number
    distinct?: SalesTeamEmployeeScalarFieldEnum | SalesTeamEmployeeScalarFieldEnum[]
  }

  /**
   * SalesTeamEmployee create
   */
  export type SalesTeamEmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamEmployee
     */
    select?: SalesTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamEmployee
     */
    omit?: SalesTeamEmployeeOmit<ExtArgs> | null
    /**
     * The data needed to create a SalesTeamEmployee.
     */
    data: XOR<SalesTeamEmployeeCreateInput, SalesTeamEmployeeUncheckedCreateInput>
  }

  /**
   * SalesTeamEmployee createMany
   */
  export type SalesTeamEmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesTeamEmployees.
     */
    data: SalesTeamEmployeeCreateManyInput | SalesTeamEmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesTeamEmployee createManyAndReturn
   */
  export type SalesTeamEmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamEmployee
     */
    select?: SalesTeamEmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamEmployee
     */
    omit?: SalesTeamEmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many SalesTeamEmployees.
     */
    data: SalesTeamEmployeeCreateManyInput | SalesTeamEmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesTeamEmployee update
   */
  export type SalesTeamEmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamEmployee
     */
    select?: SalesTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamEmployee
     */
    omit?: SalesTeamEmployeeOmit<ExtArgs> | null
    /**
     * The data needed to update a SalesTeamEmployee.
     */
    data: XOR<SalesTeamEmployeeUpdateInput, SalesTeamEmployeeUncheckedUpdateInput>
    /**
     * Choose, which SalesTeamEmployee to update.
     */
    where: SalesTeamEmployeeWhereUniqueInput
  }

  /**
   * SalesTeamEmployee updateMany
   */
  export type SalesTeamEmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesTeamEmployees.
     */
    data: XOR<SalesTeamEmployeeUpdateManyMutationInput, SalesTeamEmployeeUncheckedUpdateManyInput>
    /**
     * Filter which SalesTeamEmployees to update
     */
    where?: SalesTeamEmployeeWhereInput
    /**
     * Limit how many SalesTeamEmployees to update.
     */
    limit?: number
  }

  /**
   * SalesTeamEmployee updateManyAndReturn
   */
  export type SalesTeamEmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamEmployee
     */
    select?: SalesTeamEmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamEmployee
     */
    omit?: SalesTeamEmployeeOmit<ExtArgs> | null
    /**
     * The data used to update SalesTeamEmployees.
     */
    data: XOR<SalesTeamEmployeeUpdateManyMutationInput, SalesTeamEmployeeUncheckedUpdateManyInput>
    /**
     * Filter which SalesTeamEmployees to update
     */
    where?: SalesTeamEmployeeWhereInput
    /**
     * Limit how many SalesTeamEmployees to update.
     */
    limit?: number
  }

  /**
   * SalesTeamEmployee upsert
   */
  export type SalesTeamEmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamEmployee
     */
    select?: SalesTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamEmployee
     */
    omit?: SalesTeamEmployeeOmit<ExtArgs> | null
    /**
     * The filter to search for the SalesTeamEmployee to update in case it exists.
     */
    where: SalesTeamEmployeeWhereUniqueInput
    /**
     * In case the SalesTeamEmployee found by the `where` argument doesn't exist, create a new SalesTeamEmployee with this data.
     */
    create: XOR<SalesTeamEmployeeCreateInput, SalesTeamEmployeeUncheckedCreateInput>
    /**
     * In case the SalesTeamEmployee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesTeamEmployeeUpdateInput, SalesTeamEmployeeUncheckedUpdateInput>
  }

  /**
   * SalesTeamEmployee delete
   */
  export type SalesTeamEmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamEmployee
     */
    select?: SalesTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamEmployee
     */
    omit?: SalesTeamEmployeeOmit<ExtArgs> | null
    /**
     * Filter which SalesTeamEmployee to delete.
     */
    where: SalesTeamEmployeeWhereUniqueInput
  }

  /**
   * SalesTeamEmployee deleteMany
   */
  export type SalesTeamEmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesTeamEmployees to delete
     */
    where?: SalesTeamEmployeeWhereInput
    /**
     * Limit how many SalesTeamEmployees to delete.
     */
    limit?: number
  }

  /**
   * SalesTeamEmployee without action
   */
  export type SalesTeamEmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesTeamEmployee
     */
    select?: SalesTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalesTeamEmployee
     */
    omit?: SalesTeamEmployeeOmit<ExtArgs> | null
  }


  /**
   * Model MarketingTeamEmployee
   */

  export type AggregateMarketingTeamEmployee = {
    _count: MarketingTeamEmployeeCountAggregateOutputType | null
    _min: MarketingTeamEmployeeMinAggregateOutputType | null
    _max: MarketingTeamEmployeeMaxAggregateOutputType | null
  }

  export type MarketingTeamEmployeeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    validFrom: Date | null
    validTo: Date | null
    primary: boolean | null
    job: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketingTeamEmployeeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    validFrom: Date | null
    validTo: Date | null
    primary: boolean | null
    job: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MarketingTeamEmployeeCountAggregateOutputType = {
    id: number
    userId: number
    validFrom: number
    validTo: number
    primary: number
    job: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MarketingTeamEmployeeMinAggregateInputType = {
    id?: true
    userId?: true
    validFrom?: true
    validTo?: true
    primary?: true
    job?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketingTeamEmployeeMaxAggregateInputType = {
    id?: true
    userId?: true
    validFrom?: true
    validTo?: true
    primary?: true
    job?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MarketingTeamEmployeeCountAggregateInputType = {
    id?: true
    userId?: true
    validFrom?: true
    validTo?: true
    primary?: true
    job?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MarketingTeamEmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingTeamEmployee to aggregate.
     */
    where?: MarketingTeamEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingTeamEmployees to fetch.
     */
    orderBy?: MarketingTeamEmployeeOrderByWithRelationInput | MarketingTeamEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MarketingTeamEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingTeamEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingTeamEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MarketingTeamEmployees
    **/
    _count?: true | MarketingTeamEmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MarketingTeamEmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MarketingTeamEmployeeMaxAggregateInputType
  }

  export type GetMarketingTeamEmployeeAggregateType<T extends MarketingTeamEmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateMarketingTeamEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarketingTeamEmployee[P]>
      : GetScalarType<T[P], AggregateMarketingTeamEmployee[P]>
  }




  export type MarketingTeamEmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MarketingTeamEmployeeWhereInput
    orderBy?: MarketingTeamEmployeeOrderByWithAggregationInput | MarketingTeamEmployeeOrderByWithAggregationInput[]
    by: MarketingTeamEmployeeScalarFieldEnum[] | MarketingTeamEmployeeScalarFieldEnum
    having?: MarketingTeamEmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MarketingTeamEmployeeCountAggregateInputType | true
    _min?: MarketingTeamEmployeeMinAggregateInputType
    _max?: MarketingTeamEmployeeMaxAggregateInputType
  }

  export type MarketingTeamEmployeeGroupByOutputType = {
    id: string
    userId: string
    validFrom: Date
    validTo: Date | null
    primary: boolean
    job: string | null
    createdAt: Date
    updatedAt: Date
    _count: MarketingTeamEmployeeCountAggregateOutputType | null
    _min: MarketingTeamEmployeeMinAggregateOutputType | null
    _max: MarketingTeamEmployeeMaxAggregateOutputType | null
  }

  type GetMarketingTeamEmployeeGroupByPayload<T extends MarketingTeamEmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MarketingTeamEmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MarketingTeamEmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MarketingTeamEmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], MarketingTeamEmployeeGroupByOutputType[P]>
        }
      >
    >


  export type MarketingTeamEmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    job?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketingTeamEmployee"]>

  export type MarketingTeamEmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    job?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketingTeamEmployee"]>

  export type MarketingTeamEmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    job?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marketingTeamEmployee"]>

  export type MarketingTeamEmployeeSelectScalar = {
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    job?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MarketingTeamEmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "validFrom" | "validTo" | "primary" | "job" | "createdAt" | "updatedAt", ExtArgs["result"]["marketingTeamEmployee"]>

  export type $MarketingTeamEmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MarketingTeamEmployee"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      validFrom: Date
      validTo: Date | null
      primary: boolean
      job: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["marketingTeamEmployee"]>
    composites: {}
  }

  type MarketingTeamEmployeeGetPayload<S extends boolean | null | undefined | MarketingTeamEmployeeDefaultArgs> = $Result.GetResult<Prisma.$MarketingTeamEmployeePayload, S>

  type MarketingTeamEmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MarketingTeamEmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MarketingTeamEmployeeCountAggregateInputType | true
    }

  export interface MarketingTeamEmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MarketingTeamEmployee'], meta: { name: 'MarketingTeamEmployee' } }
    /**
     * Find zero or one MarketingTeamEmployee that matches the filter.
     * @param {MarketingTeamEmployeeFindUniqueArgs} args - Arguments to find a MarketingTeamEmployee
     * @example
     * // Get one MarketingTeamEmployee
     * const marketingTeamEmployee = await prisma.marketingTeamEmployee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MarketingTeamEmployeeFindUniqueArgs>(args: SelectSubset<T, MarketingTeamEmployeeFindUniqueArgs<ExtArgs>>): Prisma__MarketingTeamEmployeeClient<$Result.GetResult<Prisma.$MarketingTeamEmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MarketingTeamEmployee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MarketingTeamEmployeeFindUniqueOrThrowArgs} args - Arguments to find a MarketingTeamEmployee
     * @example
     * // Get one MarketingTeamEmployee
     * const marketingTeamEmployee = await prisma.marketingTeamEmployee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MarketingTeamEmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, MarketingTeamEmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MarketingTeamEmployeeClient<$Result.GetResult<Prisma.$MarketingTeamEmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketingTeamEmployee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamEmployeeFindFirstArgs} args - Arguments to find a MarketingTeamEmployee
     * @example
     * // Get one MarketingTeamEmployee
     * const marketingTeamEmployee = await prisma.marketingTeamEmployee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MarketingTeamEmployeeFindFirstArgs>(args?: SelectSubset<T, MarketingTeamEmployeeFindFirstArgs<ExtArgs>>): Prisma__MarketingTeamEmployeeClient<$Result.GetResult<Prisma.$MarketingTeamEmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MarketingTeamEmployee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamEmployeeFindFirstOrThrowArgs} args - Arguments to find a MarketingTeamEmployee
     * @example
     * // Get one MarketingTeamEmployee
     * const marketingTeamEmployee = await prisma.marketingTeamEmployee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MarketingTeamEmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, MarketingTeamEmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__MarketingTeamEmployeeClient<$Result.GetResult<Prisma.$MarketingTeamEmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MarketingTeamEmployees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamEmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MarketingTeamEmployees
     * const marketingTeamEmployees = await prisma.marketingTeamEmployee.findMany()
     * 
     * // Get first 10 MarketingTeamEmployees
     * const marketingTeamEmployees = await prisma.marketingTeamEmployee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marketingTeamEmployeeWithIdOnly = await prisma.marketingTeamEmployee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MarketingTeamEmployeeFindManyArgs>(args?: SelectSubset<T, MarketingTeamEmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingTeamEmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MarketingTeamEmployee.
     * @param {MarketingTeamEmployeeCreateArgs} args - Arguments to create a MarketingTeamEmployee.
     * @example
     * // Create one MarketingTeamEmployee
     * const MarketingTeamEmployee = await prisma.marketingTeamEmployee.create({
     *   data: {
     *     // ... data to create a MarketingTeamEmployee
     *   }
     * })
     * 
     */
    create<T extends MarketingTeamEmployeeCreateArgs>(args: SelectSubset<T, MarketingTeamEmployeeCreateArgs<ExtArgs>>): Prisma__MarketingTeamEmployeeClient<$Result.GetResult<Prisma.$MarketingTeamEmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MarketingTeamEmployees.
     * @param {MarketingTeamEmployeeCreateManyArgs} args - Arguments to create many MarketingTeamEmployees.
     * @example
     * // Create many MarketingTeamEmployees
     * const marketingTeamEmployee = await prisma.marketingTeamEmployee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MarketingTeamEmployeeCreateManyArgs>(args?: SelectSubset<T, MarketingTeamEmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MarketingTeamEmployees and returns the data saved in the database.
     * @param {MarketingTeamEmployeeCreateManyAndReturnArgs} args - Arguments to create many MarketingTeamEmployees.
     * @example
     * // Create many MarketingTeamEmployees
     * const marketingTeamEmployee = await prisma.marketingTeamEmployee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MarketingTeamEmployees and only return the `id`
     * const marketingTeamEmployeeWithIdOnly = await prisma.marketingTeamEmployee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MarketingTeamEmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, MarketingTeamEmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingTeamEmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MarketingTeamEmployee.
     * @param {MarketingTeamEmployeeDeleteArgs} args - Arguments to delete one MarketingTeamEmployee.
     * @example
     * // Delete one MarketingTeamEmployee
     * const MarketingTeamEmployee = await prisma.marketingTeamEmployee.delete({
     *   where: {
     *     // ... filter to delete one MarketingTeamEmployee
     *   }
     * })
     * 
     */
    delete<T extends MarketingTeamEmployeeDeleteArgs>(args: SelectSubset<T, MarketingTeamEmployeeDeleteArgs<ExtArgs>>): Prisma__MarketingTeamEmployeeClient<$Result.GetResult<Prisma.$MarketingTeamEmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MarketingTeamEmployee.
     * @param {MarketingTeamEmployeeUpdateArgs} args - Arguments to update one MarketingTeamEmployee.
     * @example
     * // Update one MarketingTeamEmployee
     * const marketingTeamEmployee = await prisma.marketingTeamEmployee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MarketingTeamEmployeeUpdateArgs>(args: SelectSubset<T, MarketingTeamEmployeeUpdateArgs<ExtArgs>>): Prisma__MarketingTeamEmployeeClient<$Result.GetResult<Prisma.$MarketingTeamEmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MarketingTeamEmployees.
     * @param {MarketingTeamEmployeeDeleteManyArgs} args - Arguments to filter MarketingTeamEmployees to delete.
     * @example
     * // Delete a few MarketingTeamEmployees
     * const { count } = await prisma.marketingTeamEmployee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MarketingTeamEmployeeDeleteManyArgs>(args?: SelectSubset<T, MarketingTeamEmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketingTeamEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamEmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MarketingTeamEmployees
     * const marketingTeamEmployee = await prisma.marketingTeamEmployee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MarketingTeamEmployeeUpdateManyArgs>(args: SelectSubset<T, MarketingTeamEmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MarketingTeamEmployees and returns the data updated in the database.
     * @param {MarketingTeamEmployeeUpdateManyAndReturnArgs} args - Arguments to update many MarketingTeamEmployees.
     * @example
     * // Update many MarketingTeamEmployees
     * const marketingTeamEmployee = await prisma.marketingTeamEmployee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MarketingTeamEmployees and only return the `id`
     * const marketingTeamEmployeeWithIdOnly = await prisma.marketingTeamEmployee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MarketingTeamEmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, MarketingTeamEmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MarketingTeamEmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MarketingTeamEmployee.
     * @param {MarketingTeamEmployeeUpsertArgs} args - Arguments to update or create a MarketingTeamEmployee.
     * @example
     * // Update or create a MarketingTeamEmployee
     * const marketingTeamEmployee = await prisma.marketingTeamEmployee.upsert({
     *   create: {
     *     // ... data to create a MarketingTeamEmployee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MarketingTeamEmployee we want to update
     *   }
     * })
     */
    upsert<T extends MarketingTeamEmployeeUpsertArgs>(args: SelectSubset<T, MarketingTeamEmployeeUpsertArgs<ExtArgs>>): Prisma__MarketingTeamEmployeeClient<$Result.GetResult<Prisma.$MarketingTeamEmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MarketingTeamEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamEmployeeCountArgs} args - Arguments to filter MarketingTeamEmployees to count.
     * @example
     * // Count the number of MarketingTeamEmployees
     * const count = await prisma.marketingTeamEmployee.count({
     *   where: {
     *     // ... the filter for the MarketingTeamEmployees we want to count
     *   }
     * })
    **/
    count<T extends MarketingTeamEmployeeCountArgs>(
      args?: Subset<T, MarketingTeamEmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MarketingTeamEmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MarketingTeamEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamEmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MarketingTeamEmployeeAggregateArgs>(args: Subset<T, MarketingTeamEmployeeAggregateArgs>): Prisma.PrismaPromise<GetMarketingTeamEmployeeAggregateType<T>>

    /**
     * Group by MarketingTeamEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MarketingTeamEmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MarketingTeamEmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MarketingTeamEmployeeGroupByArgs['orderBy'] }
        : { orderBy?: MarketingTeamEmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MarketingTeamEmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarketingTeamEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MarketingTeamEmployee model
   */
  readonly fields: MarketingTeamEmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MarketingTeamEmployee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MarketingTeamEmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MarketingTeamEmployee model
   */
  interface MarketingTeamEmployeeFieldRefs {
    readonly id: FieldRef<"MarketingTeamEmployee", 'String'>
    readonly userId: FieldRef<"MarketingTeamEmployee", 'String'>
    readonly validFrom: FieldRef<"MarketingTeamEmployee", 'DateTime'>
    readonly validTo: FieldRef<"MarketingTeamEmployee", 'DateTime'>
    readonly primary: FieldRef<"MarketingTeamEmployee", 'Boolean'>
    readonly job: FieldRef<"MarketingTeamEmployee", 'String'>
    readonly createdAt: FieldRef<"MarketingTeamEmployee", 'DateTime'>
    readonly updatedAt: FieldRef<"MarketingTeamEmployee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MarketingTeamEmployee findUnique
   */
  export type MarketingTeamEmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamEmployee
     */
    select?: MarketingTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamEmployee
     */
    omit?: MarketingTeamEmployeeOmit<ExtArgs> | null
    /**
     * Filter, which MarketingTeamEmployee to fetch.
     */
    where: MarketingTeamEmployeeWhereUniqueInput
  }

  /**
   * MarketingTeamEmployee findUniqueOrThrow
   */
  export type MarketingTeamEmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamEmployee
     */
    select?: MarketingTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamEmployee
     */
    omit?: MarketingTeamEmployeeOmit<ExtArgs> | null
    /**
     * Filter, which MarketingTeamEmployee to fetch.
     */
    where: MarketingTeamEmployeeWhereUniqueInput
  }

  /**
   * MarketingTeamEmployee findFirst
   */
  export type MarketingTeamEmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamEmployee
     */
    select?: MarketingTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamEmployee
     */
    omit?: MarketingTeamEmployeeOmit<ExtArgs> | null
    /**
     * Filter, which MarketingTeamEmployee to fetch.
     */
    where?: MarketingTeamEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingTeamEmployees to fetch.
     */
    orderBy?: MarketingTeamEmployeeOrderByWithRelationInput | MarketingTeamEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingTeamEmployees.
     */
    cursor?: MarketingTeamEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingTeamEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingTeamEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingTeamEmployees.
     */
    distinct?: MarketingTeamEmployeeScalarFieldEnum | MarketingTeamEmployeeScalarFieldEnum[]
  }

  /**
   * MarketingTeamEmployee findFirstOrThrow
   */
  export type MarketingTeamEmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamEmployee
     */
    select?: MarketingTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamEmployee
     */
    omit?: MarketingTeamEmployeeOmit<ExtArgs> | null
    /**
     * Filter, which MarketingTeamEmployee to fetch.
     */
    where?: MarketingTeamEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingTeamEmployees to fetch.
     */
    orderBy?: MarketingTeamEmployeeOrderByWithRelationInput | MarketingTeamEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MarketingTeamEmployees.
     */
    cursor?: MarketingTeamEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingTeamEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingTeamEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MarketingTeamEmployees.
     */
    distinct?: MarketingTeamEmployeeScalarFieldEnum | MarketingTeamEmployeeScalarFieldEnum[]
  }

  /**
   * MarketingTeamEmployee findMany
   */
  export type MarketingTeamEmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamEmployee
     */
    select?: MarketingTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamEmployee
     */
    omit?: MarketingTeamEmployeeOmit<ExtArgs> | null
    /**
     * Filter, which MarketingTeamEmployees to fetch.
     */
    where?: MarketingTeamEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MarketingTeamEmployees to fetch.
     */
    orderBy?: MarketingTeamEmployeeOrderByWithRelationInput | MarketingTeamEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MarketingTeamEmployees.
     */
    cursor?: MarketingTeamEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MarketingTeamEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MarketingTeamEmployees.
     */
    skip?: number
    distinct?: MarketingTeamEmployeeScalarFieldEnum | MarketingTeamEmployeeScalarFieldEnum[]
  }

  /**
   * MarketingTeamEmployee create
   */
  export type MarketingTeamEmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamEmployee
     */
    select?: MarketingTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamEmployee
     */
    omit?: MarketingTeamEmployeeOmit<ExtArgs> | null
    /**
     * The data needed to create a MarketingTeamEmployee.
     */
    data: XOR<MarketingTeamEmployeeCreateInput, MarketingTeamEmployeeUncheckedCreateInput>
  }

  /**
   * MarketingTeamEmployee createMany
   */
  export type MarketingTeamEmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MarketingTeamEmployees.
     */
    data: MarketingTeamEmployeeCreateManyInput | MarketingTeamEmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketingTeamEmployee createManyAndReturn
   */
  export type MarketingTeamEmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamEmployee
     */
    select?: MarketingTeamEmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamEmployee
     */
    omit?: MarketingTeamEmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many MarketingTeamEmployees.
     */
    data: MarketingTeamEmployeeCreateManyInput | MarketingTeamEmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MarketingTeamEmployee update
   */
  export type MarketingTeamEmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamEmployee
     */
    select?: MarketingTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamEmployee
     */
    omit?: MarketingTeamEmployeeOmit<ExtArgs> | null
    /**
     * The data needed to update a MarketingTeamEmployee.
     */
    data: XOR<MarketingTeamEmployeeUpdateInput, MarketingTeamEmployeeUncheckedUpdateInput>
    /**
     * Choose, which MarketingTeamEmployee to update.
     */
    where: MarketingTeamEmployeeWhereUniqueInput
  }

  /**
   * MarketingTeamEmployee updateMany
   */
  export type MarketingTeamEmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MarketingTeamEmployees.
     */
    data: XOR<MarketingTeamEmployeeUpdateManyMutationInput, MarketingTeamEmployeeUncheckedUpdateManyInput>
    /**
     * Filter which MarketingTeamEmployees to update
     */
    where?: MarketingTeamEmployeeWhereInput
    /**
     * Limit how many MarketingTeamEmployees to update.
     */
    limit?: number
  }

  /**
   * MarketingTeamEmployee updateManyAndReturn
   */
  export type MarketingTeamEmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamEmployee
     */
    select?: MarketingTeamEmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamEmployee
     */
    omit?: MarketingTeamEmployeeOmit<ExtArgs> | null
    /**
     * The data used to update MarketingTeamEmployees.
     */
    data: XOR<MarketingTeamEmployeeUpdateManyMutationInput, MarketingTeamEmployeeUncheckedUpdateManyInput>
    /**
     * Filter which MarketingTeamEmployees to update
     */
    where?: MarketingTeamEmployeeWhereInput
    /**
     * Limit how many MarketingTeamEmployees to update.
     */
    limit?: number
  }

  /**
   * MarketingTeamEmployee upsert
   */
  export type MarketingTeamEmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamEmployee
     */
    select?: MarketingTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamEmployee
     */
    omit?: MarketingTeamEmployeeOmit<ExtArgs> | null
    /**
     * The filter to search for the MarketingTeamEmployee to update in case it exists.
     */
    where: MarketingTeamEmployeeWhereUniqueInput
    /**
     * In case the MarketingTeamEmployee found by the `where` argument doesn't exist, create a new MarketingTeamEmployee with this data.
     */
    create: XOR<MarketingTeamEmployeeCreateInput, MarketingTeamEmployeeUncheckedCreateInput>
    /**
     * In case the MarketingTeamEmployee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MarketingTeamEmployeeUpdateInput, MarketingTeamEmployeeUncheckedUpdateInput>
  }

  /**
   * MarketingTeamEmployee delete
   */
  export type MarketingTeamEmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamEmployee
     */
    select?: MarketingTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamEmployee
     */
    omit?: MarketingTeamEmployeeOmit<ExtArgs> | null
    /**
     * Filter which MarketingTeamEmployee to delete.
     */
    where: MarketingTeamEmployeeWhereUniqueInput
  }

  /**
   * MarketingTeamEmployee deleteMany
   */
  export type MarketingTeamEmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MarketingTeamEmployees to delete
     */
    where?: MarketingTeamEmployeeWhereInput
    /**
     * Limit how many MarketingTeamEmployees to delete.
     */
    limit?: number
  }

  /**
   * MarketingTeamEmployee without action
   */
  export type MarketingTeamEmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MarketingTeamEmployee
     */
    select?: MarketingTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MarketingTeamEmployee
     */
    omit?: MarketingTeamEmployeeOmit<ExtArgs> | null
  }


  /**
   * Model ServiceTeamEmployee
   */

  export type AggregateServiceTeamEmployee = {
    _count: ServiceTeamEmployeeCountAggregateOutputType | null
    _min: ServiceTeamEmployeeMinAggregateOutputType | null
    _max: ServiceTeamEmployeeMaxAggregateOutputType | null
  }

  export type ServiceTeamEmployeeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    validFrom: Date | null
    validTo: Date | null
    primary: boolean | null
    job: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceTeamEmployeeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    validFrom: Date | null
    validTo: Date | null
    primary: boolean | null
    job: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceTeamEmployeeCountAggregateOutputType = {
    id: number
    userId: number
    validFrom: number
    validTo: number
    primary: number
    job: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceTeamEmployeeMinAggregateInputType = {
    id?: true
    userId?: true
    validFrom?: true
    validTo?: true
    primary?: true
    job?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceTeamEmployeeMaxAggregateInputType = {
    id?: true
    userId?: true
    validFrom?: true
    validTo?: true
    primary?: true
    job?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceTeamEmployeeCountAggregateInputType = {
    id?: true
    userId?: true
    validFrom?: true
    validTo?: true
    primary?: true
    job?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceTeamEmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceTeamEmployee to aggregate.
     */
    where?: ServiceTeamEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTeamEmployees to fetch.
     */
    orderBy?: ServiceTeamEmployeeOrderByWithRelationInput | ServiceTeamEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceTeamEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTeamEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTeamEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceTeamEmployees
    **/
    _count?: true | ServiceTeamEmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceTeamEmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceTeamEmployeeMaxAggregateInputType
  }

  export type GetServiceTeamEmployeeAggregateType<T extends ServiceTeamEmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceTeamEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceTeamEmployee[P]>
      : GetScalarType<T[P], AggregateServiceTeamEmployee[P]>
  }




  export type ServiceTeamEmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceTeamEmployeeWhereInput
    orderBy?: ServiceTeamEmployeeOrderByWithAggregationInput | ServiceTeamEmployeeOrderByWithAggregationInput[]
    by: ServiceTeamEmployeeScalarFieldEnum[] | ServiceTeamEmployeeScalarFieldEnum
    having?: ServiceTeamEmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceTeamEmployeeCountAggregateInputType | true
    _min?: ServiceTeamEmployeeMinAggregateInputType
    _max?: ServiceTeamEmployeeMaxAggregateInputType
  }

  export type ServiceTeamEmployeeGroupByOutputType = {
    id: string
    userId: string
    validFrom: Date
    validTo: Date | null
    primary: boolean
    job: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceTeamEmployeeCountAggregateOutputType | null
    _min: ServiceTeamEmployeeMinAggregateOutputType | null
    _max: ServiceTeamEmployeeMaxAggregateOutputType | null
  }

  type GetServiceTeamEmployeeGroupByPayload<T extends ServiceTeamEmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceTeamEmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceTeamEmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceTeamEmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceTeamEmployeeGroupByOutputType[P]>
        }
      >
    >


  export type ServiceTeamEmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    job?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceTeamEmployee"]>

  export type ServiceTeamEmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    job?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceTeamEmployee"]>

  export type ServiceTeamEmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    job?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["serviceTeamEmployee"]>

  export type ServiceTeamEmployeeSelectScalar = {
    id?: boolean
    userId?: boolean
    validFrom?: boolean
    validTo?: boolean
    primary?: boolean
    job?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceTeamEmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "validFrom" | "validTo" | "primary" | "job" | "createdAt" | "updatedAt", ExtArgs["result"]["serviceTeamEmployee"]>

  export type $ServiceTeamEmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceTeamEmployee"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      validFrom: Date
      validTo: Date | null
      primary: boolean
      job: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["serviceTeamEmployee"]>
    composites: {}
  }

  type ServiceTeamEmployeeGetPayload<S extends boolean | null | undefined | ServiceTeamEmployeeDefaultArgs> = $Result.GetResult<Prisma.$ServiceTeamEmployeePayload, S>

  type ServiceTeamEmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceTeamEmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceTeamEmployeeCountAggregateInputType | true
    }

  export interface ServiceTeamEmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceTeamEmployee'], meta: { name: 'ServiceTeamEmployee' } }
    /**
     * Find zero or one ServiceTeamEmployee that matches the filter.
     * @param {ServiceTeamEmployeeFindUniqueArgs} args - Arguments to find a ServiceTeamEmployee
     * @example
     * // Get one ServiceTeamEmployee
     * const serviceTeamEmployee = await prisma.serviceTeamEmployee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceTeamEmployeeFindUniqueArgs>(args: SelectSubset<T, ServiceTeamEmployeeFindUniqueArgs<ExtArgs>>): Prisma__ServiceTeamEmployeeClient<$Result.GetResult<Prisma.$ServiceTeamEmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceTeamEmployee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceTeamEmployeeFindUniqueOrThrowArgs} args - Arguments to find a ServiceTeamEmployee
     * @example
     * // Get one ServiceTeamEmployee
     * const serviceTeamEmployee = await prisma.serviceTeamEmployee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceTeamEmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceTeamEmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceTeamEmployeeClient<$Result.GetResult<Prisma.$ServiceTeamEmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceTeamEmployee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamEmployeeFindFirstArgs} args - Arguments to find a ServiceTeamEmployee
     * @example
     * // Get one ServiceTeamEmployee
     * const serviceTeamEmployee = await prisma.serviceTeamEmployee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceTeamEmployeeFindFirstArgs>(args?: SelectSubset<T, ServiceTeamEmployeeFindFirstArgs<ExtArgs>>): Prisma__ServiceTeamEmployeeClient<$Result.GetResult<Prisma.$ServiceTeamEmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceTeamEmployee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamEmployeeFindFirstOrThrowArgs} args - Arguments to find a ServiceTeamEmployee
     * @example
     * // Get one ServiceTeamEmployee
     * const serviceTeamEmployee = await prisma.serviceTeamEmployee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceTeamEmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceTeamEmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceTeamEmployeeClient<$Result.GetResult<Prisma.$ServiceTeamEmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceTeamEmployees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamEmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceTeamEmployees
     * const serviceTeamEmployees = await prisma.serviceTeamEmployee.findMany()
     * 
     * // Get first 10 ServiceTeamEmployees
     * const serviceTeamEmployees = await prisma.serviceTeamEmployee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceTeamEmployeeWithIdOnly = await prisma.serviceTeamEmployee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceTeamEmployeeFindManyArgs>(args?: SelectSubset<T, ServiceTeamEmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTeamEmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceTeamEmployee.
     * @param {ServiceTeamEmployeeCreateArgs} args - Arguments to create a ServiceTeamEmployee.
     * @example
     * // Create one ServiceTeamEmployee
     * const ServiceTeamEmployee = await prisma.serviceTeamEmployee.create({
     *   data: {
     *     // ... data to create a ServiceTeamEmployee
     *   }
     * })
     * 
     */
    create<T extends ServiceTeamEmployeeCreateArgs>(args: SelectSubset<T, ServiceTeamEmployeeCreateArgs<ExtArgs>>): Prisma__ServiceTeamEmployeeClient<$Result.GetResult<Prisma.$ServiceTeamEmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceTeamEmployees.
     * @param {ServiceTeamEmployeeCreateManyArgs} args - Arguments to create many ServiceTeamEmployees.
     * @example
     * // Create many ServiceTeamEmployees
     * const serviceTeamEmployee = await prisma.serviceTeamEmployee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceTeamEmployeeCreateManyArgs>(args?: SelectSubset<T, ServiceTeamEmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceTeamEmployees and returns the data saved in the database.
     * @param {ServiceTeamEmployeeCreateManyAndReturnArgs} args - Arguments to create many ServiceTeamEmployees.
     * @example
     * // Create many ServiceTeamEmployees
     * const serviceTeamEmployee = await prisma.serviceTeamEmployee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceTeamEmployees and only return the `id`
     * const serviceTeamEmployeeWithIdOnly = await prisma.serviceTeamEmployee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceTeamEmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceTeamEmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTeamEmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceTeamEmployee.
     * @param {ServiceTeamEmployeeDeleteArgs} args - Arguments to delete one ServiceTeamEmployee.
     * @example
     * // Delete one ServiceTeamEmployee
     * const ServiceTeamEmployee = await prisma.serviceTeamEmployee.delete({
     *   where: {
     *     // ... filter to delete one ServiceTeamEmployee
     *   }
     * })
     * 
     */
    delete<T extends ServiceTeamEmployeeDeleteArgs>(args: SelectSubset<T, ServiceTeamEmployeeDeleteArgs<ExtArgs>>): Prisma__ServiceTeamEmployeeClient<$Result.GetResult<Prisma.$ServiceTeamEmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceTeamEmployee.
     * @param {ServiceTeamEmployeeUpdateArgs} args - Arguments to update one ServiceTeamEmployee.
     * @example
     * // Update one ServiceTeamEmployee
     * const serviceTeamEmployee = await prisma.serviceTeamEmployee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceTeamEmployeeUpdateArgs>(args: SelectSubset<T, ServiceTeamEmployeeUpdateArgs<ExtArgs>>): Prisma__ServiceTeamEmployeeClient<$Result.GetResult<Prisma.$ServiceTeamEmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceTeamEmployees.
     * @param {ServiceTeamEmployeeDeleteManyArgs} args - Arguments to filter ServiceTeamEmployees to delete.
     * @example
     * // Delete a few ServiceTeamEmployees
     * const { count } = await prisma.serviceTeamEmployee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceTeamEmployeeDeleteManyArgs>(args?: SelectSubset<T, ServiceTeamEmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceTeamEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamEmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceTeamEmployees
     * const serviceTeamEmployee = await prisma.serviceTeamEmployee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceTeamEmployeeUpdateManyArgs>(args: SelectSubset<T, ServiceTeamEmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceTeamEmployees and returns the data updated in the database.
     * @param {ServiceTeamEmployeeUpdateManyAndReturnArgs} args - Arguments to update many ServiceTeamEmployees.
     * @example
     * // Update many ServiceTeamEmployees
     * const serviceTeamEmployee = await prisma.serviceTeamEmployee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceTeamEmployees and only return the `id`
     * const serviceTeamEmployeeWithIdOnly = await prisma.serviceTeamEmployee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceTeamEmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceTeamEmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceTeamEmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceTeamEmployee.
     * @param {ServiceTeamEmployeeUpsertArgs} args - Arguments to update or create a ServiceTeamEmployee.
     * @example
     * // Update or create a ServiceTeamEmployee
     * const serviceTeamEmployee = await prisma.serviceTeamEmployee.upsert({
     *   create: {
     *     // ... data to create a ServiceTeamEmployee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceTeamEmployee we want to update
     *   }
     * })
     */
    upsert<T extends ServiceTeamEmployeeUpsertArgs>(args: SelectSubset<T, ServiceTeamEmployeeUpsertArgs<ExtArgs>>): Prisma__ServiceTeamEmployeeClient<$Result.GetResult<Prisma.$ServiceTeamEmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceTeamEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamEmployeeCountArgs} args - Arguments to filter ServiceTeamEmployees to count.
     * @example
     * // Count the number of ServiceTeamEmployees
     * const count = await prisma.serviceTeamEmployee.count({
     *   where: {
     *     // ... the filter for the ServiceTeamEmployees we want to count
     *   }
     * })
    **/
    count<T extends ServiceTeamEmployeeCountArgs>(
      args?: Subset<T, ServiceTeamEmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceTeamEmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceTeamEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamEmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceTeamEmployeeAggregateArgs>(args: Subset<T, ServiceTeamEmployeeAggregateArgs>): Prisma.PrismaPromise<GetServiceTeamEmployeeAggregateType<T>>

    /**
     * Group by ServiceTeamEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceTeamEmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceTeamEmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceTeamEmployeeGroupByArgs['orderBy'] }
        : { orderBy?: ServiceTeamEmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceTeamEmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceTeamEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceTeamEmployee model
   */
  readonly fields: ServiceTeamEmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceTeamEmployee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceTeamEmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceTeamEmployee model
   */
  interface ServiceTeamEmployeeFieldRefs {
    readonly id: FieldRef<"ServiceTeamEmployee", 'String'>
    readonly userId: FieldRef<"ServiceTeamEmployee", 'String'>
    readonly validFrom: FieldRef<"ServiceTeamEmployee", 'DateTime'>
    readonly validTo: FieldRef<"ServiceTeamEmployee", 'DateTime'>
    readonly primary: FieldRef<"ServiceTeamEmployee", 'Boolean'>
    readonly job: FieldRef<"ServiceTeamEmployee", 'String'>
    readonly createdAt: FieldRef<"ServiceTeamEmployee", 'DateTime'>
    readonly updatedAt: FieldRef<"ServiceTeamEmployee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceTeamEmployee findUnique
   */
  export type ServiceTeamEmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamEmployee
     */
    select?: ServiceTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamEmployee
     */
    omit?: ServiceTeamEmployeeOmit<ExtArgs> | null
    /**
     * Filter, which ServiceTeamEmployee to fetch.
     */
    where: ServiceTeamEmployeeWhereUniqueInput
  }

  /**
   * ServiceTeamEmployee findUniqueOrThrow
   */
  export type ServiceTeamEmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamEmployee
     */
    select?: ServiceTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamEmployee
     */
    omit?: ServiceTeamEmployeeOmit<ExtArgs> | null
    /**
     * Filter, which ServiceTeamEmployee to fetch.
     */
    where: ServiceTeamEmployeeWhereUniqueInput
  }

  /**
   * ServiceTeamEmployee findFirst
   */
  export type ServiceTeamEmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamEmployee
     */
    select?: ServiceTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamEmployee
     */
    omit?: ServiceTeamEmployeeOmit<ExtArgs> | null
    /**
     * Filter, which ServiceTeamEmployee to fetch.
     */
    where?: ServiceTeamEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTeamEmployees to fetch.
     */
    orderBy?: ServiceTeamEmployeeOrderByWithRelationInput | ServiceTeamEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceTeamEmployees.
     */
    cursor?: ServiceTeamEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTeamEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTeamEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceTeamEmployees.
     */
    distinct?: ServiceTeamEmployeeScalarFieldEnum | ServiceTeamEmployeeScalarFieldEnum[]
  }

  /**
   * ServiceTeamEmployee findFirstOrThrow
   */
  export type ServiceTeamEmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamEmployee
     */
    select?: ServiceTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamEmployee
     */
    omit?: ServiceTeamEmployeeOmit<ExtArgs> | null
    /**
     * Filter, which ServiceTeamEmployee to fetch.
     */
    where?: ServiceTeamEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTeamEmployees to fetch.
     */
    orderBy?: ServiceTeamEmployeeOrderByWithRelationInput | ServiceTeamEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceTeamEmployees.
     */
    cursor?: ServiceTeamEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTeamEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTeamEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceTeamEmployees.
     */
    distinct?: ServiceTeamEmployeeScalarFieldEnum | ServiceTeamEmployeeScalarFieldEnum[]
  }

  /**
   * ServiceTeamEmployee findMany
   */
  export type ServiceTeamEmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamEmployee
     */
    select?: ServiceTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamEmployee
     */
    omit?: ServiceTeamEmployeeOmit<ExtArgs> | null
    /**
     * Filter, which ServiceTeamEmployees to fetch.
     */
    where?: ServiceTeamEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceTeamEmployees to fetch.
     */
    orderBy?: ServiceTeamEmployeeOrderByWithRelationInput | ServiceTeamEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceTeamEmployees.
     */
    cursor?: ServiceTeamEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceTeamEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceTeamEmployees.
     */
    skip?: number
    distinct?: ServiceTeamEmployeeScalarFieldEnum | ServiceTeamEmployeeScalarFieldEnum[]
  }

  /**
   * ServiceTeamEmployee create
   */
  export type ServiceTeamEmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamEmployee
     */
    select?: ServiceTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamEmployee
     */
    omit?: ServiceTeamEmployeeOmit<ExtArgs> | null
    /**
     * The data needed to create a ServiceTeamEmployee.
     */
    data: XOR<ServiceTeamEmployeeCreateInput, ServiceTeamEmployeeUncheckedCreateInput>
  }

  /**
   * ServiceTeamEmployee createMany
   */
  export type ServiceTeamEmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceTeamEmployees.
     */
    data: ServiceTeamEmployeeCreateManyInput | ServiceTeamEmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceTeamEmployee createManyAndReturn
   */
  export type ServiceTeamEmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamEmployee
     */
    select?: ServiceTeamEmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamEmployee
     */
    omit?: ServiceTeamEmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceTeamEmployees.
     */
    data: ServiceTeamEmployeeCreateManyInput | ServiceTeamEmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceTeamEmployee update
   */
  export type ServiceTeamEmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamEmployee
     */
    select?: ServiceTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamEmployee
     */
    omit?: ServiceTeamEmployeeOmit<ExtArgs> | null
    /**
     * The data needed to update a ServiceTeamEmployee.
     */
    data: XOR<ServiceTeamEmployeeUpdateInput, ServiceTeamEmployeeUncheckedUpdateInput>
    /**
     * Choose, which ServiceTeamEmployee to update.
     */
    where: ServiceTeamEmployeeWhereUniqueInput
  }

  /**
   * ServiceTeamEmployee updateMany
   */
  export type ServiceTeamEmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceTeamEmployees.
     */
    data: XOR<ServiceTeamEmployeeUpdateManyMutationInput, ServiceTeamEmployeeUncheckedUpdateManyInput>
    /**
     * Filter which ServiceTeamEmployees to update
     */
    where?: ServiceTeamEmployeeWhereInput
    /**
     * Limit how many ServiceTeamEmployees to update.
     */
    limit?: number
  }

  /**
   * ServiceTeamEmployee updateManyAndReturn
   */
  export type ServiceTeamEmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamEmployee
     */
    select?: ServiceTeamEmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamEmployee
     */
    omit?: ServiceTeamEmployeeOmit<ExtArgs> | null
    /**
     * The data used to update ServiceTeamEmployees.
     */
    data: XOR<ServiceTeamEmployeeUpdateManyMutationInput, ServiceTeamEmployeeUncheckedUpdateManyInput>
    /**
     * Filter which ServiceTeamEmployees to update
     */
    where?: ServiceTeamEmployeeWhereInput
    /**
     * Limit how many ServiceTeamEmployees to update.
     */
    limit?: number
  }

  /**
   * ServiceTeamEmployee upsert
   */
  export type ServiceTeamEmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamEmployee
     */
    select?: ServiceTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamEmployee
     */
    omit?: ServiceTeamEmployeeOmit<ExtArgs> | null
    /**
     * The filter to search for the ServiceTeamEmployee to update in case it exists.
     */
    where: ServiceTeamEmployeeWhereUniqueInput
    /**
     * In case the ServiceTeamEmployee found by the `where` argument doesn't exist, create a new ServiceTeamEmployee with this data.
     */
    create: XOR<ServiceTeamEmployeeCreateInput, ServiceTeamEmployeeUncheckedCreateInput>
    /**
     * In case the ServiceTeamEmployee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceTeamEmployeeUpdateInput, ServiceTeamEmployeeUncheckedUpdateInput>
  }

  /**
   * ServiceTeamEmployee delete
   */
  export type ServiceTeamEmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamEmployee
     */
    select?: ServiceTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamEmployee
     */
    omit?: ServiceTeamEmployeeOmit<ExtArgs> | null
    /**
     * Filter which ServiceTeamEmployee to delete.
     */
    where: ServiceTeamEmployeeWhereUniqueInput
  }

  /**
   * ServiceTeamEmployee deleteMany
   */
  export type ServiceTeamEmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceTeamEmployees to delete
     */
    where?: ServiceTeamEmployeeWhereInput
    /**
     * Limit how many ServiceTeamEmployees to delete.
     */
    limit?: number
  }

  /**
   * ServiceTeamEmployee without action
   */
  export type ServiceTeamEmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceTeamEmployee
     */
    select?: ServiceTeamEmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceTeamEmployee
     */
    omit?: ServiceTeamEmployeeOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BusinessEntityScalarFieldEnum: {
    id: 'id',
    businessEntityCode: 'businessEntityCode',
    businessEntityName: 'businessEntityName',
    street1: 'street1',
    street2: 'street2',
    city: 'city',
    state: 'state',
    region: 'region',
    country: 'country',
    pinCode: 'pinCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusinessEntityScalarFieldEnum = (typeof BusinessEntityScalarFieldEnum)[keyof typeof BusinessEntityScalarFieldEnum]


  export const BusinessUnitScalarFieldEnum: {
    id: 'id',
    businessUnitCode: 'businessUnitCode',
    businessUnitDesc: 'businessUnitDesc',
    street1: 'street1',
    street2: 'street2',
    city: 'city',
    state: 'state',
    region: 'region',
    country: 'country',
    pinCode: 'pinCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusinessUnitScalarFieldEnum = (typeof BusinessUnitScalarFieldEnum)[keyof typeof BusinessUnitScalarFieldEnum]


  export const BusinessEntityUnitPairScalarFieldEnum: {
    id: 'id',
    businessEntityCode: 'businessEntityCode',
    businessUnitCode: 'businessUnitCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BusinessEntityUnitPairScalarFieldEnum = (typeof BusinessEntityUnitPairScalarFieldEnum)[keyof typeof BusinessEntityUnitPairScalarFieldEnum]


  export const SalesChannelScalarFieldEnum: {
    id: 'id',
    salesChannelCode: 'salesChannelCode',
    salesChannelName: 'salesChannelName',
    salesChannelDesc: 'salesChannelDesc',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesChannelScalarFieldEnum = (typeof SalesChannelScalarFieldEnum)[keyof typeof SalesChannelScalarFieldEnum]


  export const SalesOfficeScalarFieldEnum: {
    id: 'id',
    salesOfficeId: 'salesOfficeId',
    organizationName: 'organizationName',
    salesOfficeDesc: 'salesOfficeDesc',
    street1: 'street1',
    street2: 'street2',
    city: 'city',
    state: 'state',
    region: 'region',
    country: 'country',
    pinCode: 'pinCode',
    validFrom: 'validFrom',
    validTo: 'validTo',
    company: 'company',
    parentUnit: 'parentUnit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesOfficeScalarFieldEnum = (typeof SalesOfficeScalarFieldEnum)[keyof typeof SalesOfficeScalarFieldEnum]


  export const SalesTeamScalarFieldEnum: {
    id: 'id',
    salesTeamCode: 'salesTeamCode',
    salesTeamName: 'salesTeamName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesTeamScalarFieldEnum = (typeof SalesTeamScalarFieldEnum)[keyof typeof SalesTeamScalarFieldEnum]


  export const SalesChannelOfficeTeamPairScalarFieldEnum: {
    id: 'id',
    salesChannelCode: 'salesChannelCode',
    salesOfficeId: 'salesOfficeId',
    salesTeamCode: 'salesTeamCode'
  };

  export type SalesChannelOfficeTeamPairScalarFieldEnum = (typeof SalesChannelOfficeTeamPairScalarFieldEnum)[keyof typeof SalesChannelOfficeTeamPairScalarFieldEnum]


  export const MarketingChannelScalarFieldEnum: {
    id: 'id',
    marketingChannelCode: 'marketingChannelCode',
    marketingChannelName: 'marketingChannelName',
    marketingChannelDesc: 'marketingChannelDesc',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarketingChannelScalarFieldEnum = (typeof MarketingChannelScalarFieldEnum)[keyof typeof MarketingChannelScalarFieldEnum]


  export const MarketingOfficeScalarFieldEnum: {
    id: 'id',
    marketingOfficeId: 'marketingOfficeId',
    organizationName: 'organizationName',
    marketingOfficeDesc: 'marketingOfficeDesc',
    street1: 'street1',
    street2: 'street2',
    city: 'city',
    state: 'state',
    region: 'region',
    country: 'country',
    pinCode: 'pinCode',
    validFrom: 'validFrom',
    validTo: 'validTo',
    company: 'company',
    parentUnit: 'parentUnit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarketingOfficeScalarFieldEnum = (typeof MarketingOfficeScalarFieldEnum)[keyof typeof MarketingOfficeScalarFieldEnum]


  export const MarketingTeamScalarFieldEnum: {
    id: 'id',
    marketingTeamCode: 'marketingTeamCode',
    marketingTeamName: 'marketingTeamName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarketingTeamScalarFieldEnum = (typeof MarketingTeamScalarFieldEnum)[keyof typeof MarketingTeamScalarFieldEnum]


  export const MarketingChannelOfficeTeamPairScalarFieldEnum: {
    id: 'id',
    marketingChannelCode: 'marketingChannelCode',
    marketingOfficeId: 'marketingOfficeId',
    marketingTeamCode: 'marketingTeamCode'
  };

  export type MarketingChannelOfficeTeamPairScalarFieldEnum = (typeof MarketingChannelOfficeTeamPairScalarFieldEnum)[keyof typeof MarketingChannelOfficeTeamPairScalarFieldEnum]


  export const ServiceChannelScalarFieldEnum: {
    id: 'id',
    serviceChannelCode: 'serviceChannelCode',
    serviceChannelName: 'serviceChannelName',
    serviceChannelDesc: 'serviceChannelDesc',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceChannelScalarFieldEnum = (typeof ServiceChannelScalarFieldEnum)[keyof typeof ServiceChannelScalarFieldEnum]


  export const ServiceOfficeScalarFieldEnum: {
    id: 'id',
    serviceOfficeId: 'serviceOfficeId',
    organizationName: 'organizationName',
    serviceOfficeDesc: 'serviceOfficeDesc',
    street1: 'street1',
    street2: 'street2',
    city: 'city',
    state: 'state',
    region: 'region',
    country: 'country',
    pinCode: 'pinCode',
    validFrom: 'validFrom',
    validTo: 'validTo',
    company: 'company',
    parentUnit: 'parentUnit',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceOfficeScalarFieldEnum = (typeof ServiceOfficeScalarFieldEnum)[keyof typeof ServiceOfficeScalarFieldEnum]


  export const ServiceTeamScalarFieldEnum: {
    id: 'id',
    serviceTeamCode: 'serviceTeamCode',
    serviceTeamName: 'serviceTeamName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceTeamScalarFieldEnum = (typeof ServiceTeamScalarFieldEnum)[keyof typeof ServiceTeamScalarFieldEnum]


  export const ServiceChannelOfficeTeamPairScalarFieldEnum: {
    id: 'id',
    serviceChannelCode: 'serviceChannelCode',
    serviceOfficeId: 'serviceOfficeId',
    serviceTeamCode: 'serviceTeamCode'
  };

  export type ServiceChannelOfficeTeamPairScalarFieldEnum = (typeof ServiceChannelOfficeTeamPairScalarFieldEnum)[keyof typeof ServiceChannelOfficeTeamPairScalarFieldEnum]


  export const BusinessUnitSalesPairScalarFieldEnum: {
    id: 'id',
    businessUnitCode: 'businessUnitCode',
    salesChannelCode: 'salesChannelCode',
    salesOfficeId: 'salesOfficeId',
    salesTeamCode: 'salesTeamCode'
  };

  export type BusinessUnitSalesPairScalarFieldEnum = (typeof BusinessUnitSalesPairScalarFieldEnum)[keyof typeof BusinessUnitSalesPairScalarFieldEnum]


  export const BusinessUnitMarketingPairScalarFieldEnum: {
    id: 'id',
    businessUnitCode: 'businessUnitCode',
    marketingChannelCode: 'marketingChannelCode',
    marketingOfficeId: 'marketingOfficeId',
    marketingTeamCode: 'marketingTeamCode'
  };

  export type BusinessUnitMarketingPairScalarFieldEnum = (typeof BusinessUnitMarketingPairScalarFieldEnum)[keyof typeof BusinessUnitMarketingPairScalarFieldEnum]


  export const BusinessUnitServicePairScalarFieldEnum: {
    id: 'id',
    businessUnitCode: 'businessUnitCode',
    serviceChannelCode: 'serviceChannelCode',
    serviceOfficeId: 'serviceOfficeId',
    serviceTeamCode: 'serviceTeamCode'
  };

  export type BusinessUnitServicePairScalarFieldEnum = (typeof BusinessUnitServicePairScalarFieldEnum)[keyof typeof BusinessUnitServicePairScalarFieldEnum]


  export const SalesTeamManagerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    validFrom: 'validFrom',
    validTo: 'validTo',
    primary: 'primary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesTeamManagerScalarFieldEnum = (typeof SalesTeamManagerScalarFieldEnum)[keyof typeof SalesTeamManagerScalarFieldEnum]


  export const MarketingTeamManagerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    validFrom: 'validFrom',
    validTo: 'validTo',
    primary: 'primary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarketingTeamManagerScalarFieldEnum = (typeof MarketingTeamManagerScalarFieldEnum)[keyof typeof MarketingTeamManagerScalarFieldEnum]


  export const ServiceTeamManagerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    validFrom: 'validFrom',
    validTo: 'validTo',
    primary: 'primary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceTeamManagerScalarFieldEnum = (typeof ServiceTeamManagerScalarFieldEnum)[keyof typeof ServiceTeamManagerScalarFieldEnum]


  export const SalesTeamEmployeeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    validFrom: 'validFrom',
    validTo: 'validTo',
    primary: 'primary',
    job: 'job',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalesTeamEmployeeScalarFieldEnum = (typeof SalesTeamEmployeeScalarFieldEnum)[keyof typeof SalesTeamEmployeeScalarFieldEnum]


  export const MarketingTeamEmployeeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    validFrom: 'validFrom',
    validTo: 'validTo',
    primary: 'primary',
    job: 'job',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MarketingTeamEmployeeScalarFieldEnum = (typeof MarketingTeamEmployeeScalarFieldEnum)[keyof typeof MarketingTeamEmployeeScalarFieldEnum]


  export const ServiceTeamEmployeeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    validFrom: 'validFrom',
    validTo: 'validTo',
    primary: 'primary',
    job: 'job',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceTeamEmployeeScalarFieldEnum = (typeof ServiceTeamEmployeeScalarFieldEnum)[keyof typeof ServiceTeamEmployeeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type BusinessEntityWhereInput = {
    AND?: BusinessEntityWhereInput | BusinessEntityWhereInput[]
    OR?: BusinessEntityWhereInput[]
    NOT?: BusinessEntityWhereInput | BusinessEntityWhereInput[]
    id?: IntFilter<"BusinessEntity"> | number
    businessEntityCode?: StringFilter<"BusinessEntity"> | string
    businessEntityName?: StringFilter<"BusinessEntity"> | string
    street1?: StringFilter<"BusinessEntity"> | string
    street2?: StringNullableFilter<"BusinessEntity"> | string | null
    city?: StringFilter<"BusinessEntity"> | string
    state?: StringFilter<"BusinessEntity"> | string
    region?: StringNullableFilter<"BusinessEntity"> | string | null
    country?: StringFilter<"BusinessEntity"> | string
    pinCode?: StringFilter<"BusinessEntity"> | string
    createdAt?: DateTimeFilter<"BusinessEntity"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessEntity"> | Date | string
    entityUnitPairs?: BusinessEntityUnitPairListRelationFilter
  }

  export type BusinessEntityOrderByWithRelationInput = {
    id?: SortOrder
    businessEntityCode?: SortOrder
    businessEntityName?: SortOrder
    street1?: SortOrder
    street2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrderInput | SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    entityUnitPairs?: BusinessEntityUnitPairOrderByRelationAggregateInput
  }

  export type BusinessEntityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    businessEntityCode?: string
    AND?: BusinessEntityWhereInput | BusinessEntityWhereInput[]
    OR?: BusinessEntityWhereInput[]
    NOT?: BusinessEntityWhereInput | BusinessEntityWhereInput[]
    businessEntityName?: StringFilter<"BusinessEntity"> | string
    street1?: StringFilter<"BusinessEntity"> | string
    street2?: StringNullableFilter<"BusinessEntity"> | string | null
    city?: StringFilter<"BusinessEntity"> | string
    state?: StringFilter<"BusinessEntity"> | string
    region?: StringNullableFilter<"BusinessEntity"> | string | null
    country?: StringFilter<"BusinessEntity"> | string
    pinCode?: StringFilter<"BusinessEntity"> | string
    createdAt?: DateTimeFilter<"BusinessEntity"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessEntity"> | Date | string
    entityUnitPairs?: BusinessEntityUnitPairListRelationFilter
  }, "id" | "businessEntityCode">

  export type BusinessEntityOrderByWithAggregationInput = {
    id?: SortOrder
    businessEntityCode?: SortOrder
    businessEntityName?: SortOrder
    street1?: SortOrder
    street2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrderInput | SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusinessEntityCountOrderByAggregateInput
    _avg?: BusinessEntityAvgOrderByAggregateInput
    _max?: BusinessEntityMaxOrderByAggregateInput
    _min?: BusinessEntityMinOrderByAggregateInput
    _sum?: BusinessEntitySumOrderByAggregateInput
  }

  export type BusinessEntityScalarWhereWithAggregatesInput = {
    AND?: BusinessEntityScalarWhereWithAggregatesInput | BusinessEntityScalarWhereWithAggregatesInput[]
    OR?: BusinessEntityScalarWhereWithAggregatesInput[]
    NOT?: BusinessEntityScalarWhereWithAggregatesInput | BusinessEntityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BusinessEntity"> | number
    businessEntityCode?: StringWithAggregatesFilter<"BusinessEntity"> | string
    businessEntityName?: StringWithAggregatesFilter<"BusinessEntity"> | string
    street1?: StringWithAggregatesFilter<"BusinessEntity"> | string
    street2?: StringNullableWithAggregatesFilter<"BusinessEntity"> | string | null
    city?: StringWithAggregatesFilter<"BusinessEntity"> | string
    state?: StringWithAggregatesFilter<"BusinessEntity"> | string
    region?: StringNullableWithAggregatesFilter<"BusinessEntity"> | string | null
    country?: StringWithAggregatesFilter<"BusinessEntity"> | string
    pinCode?: StringWithAggregatesFilter<"BusinessEntity"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BusinessEntity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessEntity"> | Date | string
  }

  export type BusinessUnitWhereInput = {
    AND?: BusinessUnitWhereInput | BusinessUnitWhereInput[]
    OR?: BusinessUnitWhereInput[]
    NOT?: BusinessUnitWhereInput | BusinessUnitWhereInput[]
    id?: IntFilter<"BusinessUnit"> | number
    businessUnitCode?: StringFilter<"BusinessUnit"> | string
    businessUnitDesc?: StringFilter<"BusinessUnit"> | string
    street1?: StringFilter<"BusinessUnit"> | string
    street2?: StringNullableFilter<"BusinessUnit"> | string | null
    city?: StringFilter<"BusinessUnit"> | string
    state?: StringFilter<"BusinessUnit"> | string
    region?: StringNullableFilter<"BusinessUnit"> | string | null
    country?: StringFilter<"BusinessUnit"> | string
    pinCode?: StringFilter<"BusinessUnit"> | string
    createdAt?: DateTimeFilter<"BusinessUnit"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessUnit"> | Date | string
    entityUnitPairs?: BusinessEntityUnitPairListRelationFilter
    businessUnitSalesPairs?: BusinessUnitSalesPairListRelationFilter
    businessUnitMarketingPairs?: BusinessUnitMarketingPairListRelationFilter
    businessUnitServicePairs?: BusinessUnitServicePairListRelationFilter
  }

  export type BusinessUnitOrderByWithRelationInput = {
    id?: SortOrder
    businessUnitCode?: SortOrder
    businessUnitDesc?: SortOrder
    street1?: SortOrder
    street2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrderInput | SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    entityUnitPairs?: BusinessEntityUnitPairOrderByRelationAggregateInput
    businessUnitSalesPairs?: BusinessUnitSalesPairOrderByRelationAggregateInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairOrderByRelationAggregateInput
    businessUnitServicePairs?: BusinessUnitServicePairOrderByRelationAggregateInput
  }

  export type BusinessUnitWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    businessUnitCode?: string
    AND?: BusinessUnitWhereInput | BusinessUnitWhereInput[]
    OR?: BusinessUnitWhereInput[]
    NOT?: BusinessUnitWhereInput | BusinessUnitWhereInput[]
    businessUnitDesc?: StringFilter<"BusinessUnit"> | string
    street1?: StringFilter<"BusinessUnit"> | string
    street2?: StringNullableFilter<"BusinessUnit"> | string | null
    city?: StringFilter<"BusinessUnit"> | string
    state?: StringFilter<"BusinessUnit"> | string
    region?: StringNullableFilter<"BusinessUnit"> | string | null
    country?: StringFilter<"BusinessUnit"> | string
    pinCode?: StringFilter<"BusinessUnit"> | string
    createdAt?: DateTimeFilter<"BusinessUnit"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessUnit"> | Date | string
    entityUnitPairs?: BusinessEntityUnitPairListRelationFilter
    businessUnitSalesPairs?: BusinessUnitSalesPairListRelationFilter
    businessUnitMarketingPairs?: BusinessUnitMarketingPairListRelationFilter
    businessUnitServicePairs?: BusinessUnitServicePairListRelationFilter
  }, "id" | "businessUnitCode">

  export type BusinessUnitOrderByWithAggregationInput = {
    id?: SortOrder
    businessUnitCode?: SortOrder
    businessUnitDesc?: SortOrder
    street1?: SortOrder
    street2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrderInput | SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusinessUnitCountOrderByAggregateInput
    _avg?: BusinessUnitAvgOrderByAggregateInput
    _max?: BusinessUnitMaxOrderByAggregateInput
    _min?: BusinessUnitMinOrderByAggregateInput
    _sum?: BusinessUnitSumOrderByAggregateInput
  }

  export type BusinessUnitScalarWhereWithAggregatesInput = {
    AND?: BusinessUnitScalarWhereWithAggregatesInput | BusinessUnitScalarWhereWithAggregatesInput[]
    OR?: BusinessUnitScalarWhereWithAggregatesInput[]
    NOT?: BusinessUnitScalarWhereWithAggregatesInput | BusinessUnitScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BusinessUnit"> | number
    businessUnitCode?: StringWithAggregatesFilter<"BusinessUnit"> | string
    businessUnitDesc?: StringWithAggregatesFilter<"BusinessUnit"> | string
    street1?: StringWithAggregatesFilter<"BusinessUnit"> | string
    street2?: StringNullableWithAggregatesFilter<"BusinessUnit"> | string | null
    city?: StringWithAggregatesFilter<"BusinessUnit"> | string
    state?: StringWithAggregatesFilter<"BusinessUnit"> | string
    region?: StringNullableWithAggregatesFilter<"BusinessUnit"> | string | null
    country?: StringWithAggregatesFilter<"BusinessUnit"> | string
    pinCode?: StringWithAggregatesFilter<"BusinessUnit"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BusinessUnit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessUnit"> | Date | string
  }

  export type BusinessEntityUnitPairWhereInput = {
    AND?: BusinessEntityUnitPairWhereInput | BusinessEntityUnitPairWhereInput[]
    OR?: BusinessEntityUnitPairWhereInput[]
    NOT?: BusinessEntityUnitPairWhereInput | BusinessEntityUnitPairWhereInput[]
    id?: IntFilter<"BusinessEntityUnitPair"> | number
    businessEntityCode?: StringFilter<"BusinessEntityUnitPair"> | string
    businessUnitCode?: StringFilter<"BusinessEntityUnitPair"> | string
    createdAt?: DateTimeFilter<"BusinessEntityUnitPair"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessEntityUnitPair"> | Date | string
    businessEntity?: XOR<BusinessEntityScalarRelationFilter, BusinessEntityWhereInput>
    businessUnit?: XOR<BusinessUnitScalarRelationFilter, BusinessUnitWhereInput>
  }

  export type BusinessEntityUnitPairOrderByWithRelationInput = {
    id?: SortOrder
    businessEntityCode?: SortOrder
    businessUnitCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    businessEntity?: BusinessEntityOrderByWithRelationInput
    businessUnit?: BusinessUnitOrderByWithRelationInput
  }

  export type BusinessEntityUnitPairWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    businessEntityCode_businessUnitCode?: BusinessEntityUnitPairBusinessEntityCodeBusinessUnitCodeCompoundUniqueInput
    AND?: BusinessEntityUnitPairWhereInput | BusinessEntityUnitPairWhereInput[]
    OR?: BusinessEntityUnitPairWhereInput[]
    NOT?: BusinessEntityUnitPairWhereInput | BusinessEntityUnitPairWhereInput[]
    businessEntityCode?: StringFilter<"BusinessEntityUnitPair"> | string
    businessUnitCode?: StringFilter<"BusinessEntityUnitPair"> | string
    createdAt?: DateTimeFilter<"BusinessEntityUnitPair"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessEntityUnitPair"> | Date | string
    businessEntity?: XOR<BusinessEntityScalarRelationFilter, BusinessEntityWhereInput>
    businessUnit?: XOR<BusinessUnitScalarRelationFilter, BusinessUnitWhereInput>
  }, "id" | "businessEntityCode_businessUnitCode">

  export type BusinessEntityUnitPairOrderByWithAggregationInput = {
    id?: SortOrder
    businessEntityCode?: SortOrder
    businessUnitCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BusinessEntityUnitPairCountOrderByAggregateInput
    _avg?: BusinessEntityUnitPairAvgOrderByAggregateInput
    _max?: BusinessEntityUnitPairMaxOrderByAggregateInput
    _min?: BusinessEntityUnitPairMinOrderByAggregateInput
    _sum?: BusinessEntityUnitPairSumOrderByAggregateInput
  }

  export type BusinessEntityUnitPairScalarWhereWithAggregatesInput = {
    AND?: BusinessEntityUnitPairScalarWhereWithAggregatesInput | BusinessEntityUnitPairScalarWhereWithAggregatesInput[]
    OR?: BusinessEntityUnitPairScalarWhereWithAggregatesInput[]
    NOT?: BusinessEntityUnitPairScalarWhereWithAggregatesInput | BusinessEntityUnitPairScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BusinessEntityUnitPair"> | number
    businessEntityCode?: StringWithAggregatesFilter<"BusinessEntityUnitPair"> | string
    businessUnitCode?: StringWithAggregatesFilter<"BusinessEntityUnitPair"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BusinessEntityUnitPair"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessEntityUnitPair"> | Date | string
  }

  export type SalesChannelWhereInput = {
    AND?: SalesChannelWhereInput | SalesChannelWhereInput[]
    OR?: SalesChannelWhereInput[]
    NOT?: SalesChannelWhereInput | SalesChannelWhereInput[]
    id?: IntFilter<"SalesChannel"> | number
    salesChannelCode?: StringFilter<"SalesChannel"> | string
    salesChannelName?: StringFilter<"SalesChannel"> | string
    salesChannelDesc?: StringNullableFilter<"SalesChannel"> | string | null
    createdAt?: DateTimeFilter<"SalesChannel"> | Date | string
    updatedAt?: DateTimeFilter<"SalesChannel"> | Date | string
    channelOfficePairs?: SalesChannelOfficeTeamPairListRelationFilter
    businessUnitSalesPairs?: BusinessUnitSalesPairListRelationFilter
  }

  export type SalesChannelOrderByWithRelationInput = {
    id?: SortOrder
    salesChannelCode?: SortOrder
    salesChannelName?: SortOrder
    salesChannelDesc?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    channelOfficePairs?: SalesChannelOfficeTeamPairOrderByRelationAggregateInput
    businessUnitSalesPairs?: BusinessUnitSalesPairOrderByRelationAggregateInput
  }

  export type SalesChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    salesChannelCode?: string
    AND?: SalesChannelWhereInput | SalesChannelWhereInput[]
    OR?: SalesChannelWhereInput[]
    NOT?: SalesChannelWhereInput | SalesChannelWhereInput[]
    salesChannelName?: StringFilter<"SalesChannel"> | string
    salesChannelDesc?: StringNullableFilter<"SalesChannel"> | string | null
    createdAt?: DateTimeFilter<"SalesChannel"> | Date | string
    updatedAt?: DateTimeFilter<"SalesChannel"> | Date | string
    channelOfficePairs?: SalesChannelOfficeTeamPairListRelationFilter
    businessUnitSalesPairs?: BusinessUnitSalesPairListRelationFilter
  }, "id" | "salesChannelCode">

  export type SalesChannelOrderByWithAggregationInput = {
    id?: SortOrder
    salesChannelCode?: SortOrder
    salesChannelName?: SortOrder
    salesChannelDesc?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesChannelCountOrderByAggregateInput
    _avg?: SalesChannelAvgOrderByAggregateInput
    _max?: SalesChannelMaxOrderByAggregateInput
    _min?: SalesChannelMinOrderByAggregateInput
    _sum?: SalesChannelSumOrderByAggregateInput
  }

  export type SalesChannelScalarWhereWithAggregatesInput = {
    AND?: SalesChannelScalarWhereWithAggregatesInput | SalesChannelScalarWhereWithAggregatesInput[]
    OR?: SalesChannelScalarWhereWithAggregatesInput[]
    NOT?: SalesChannelScalarWhereWithAggregatesInput | SalesChannelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalesChannel"> | number
    salesChannelCode?: StringWithAggregatesFilter<"SalesChannel"> | string
    salesChannelName?: StringWithAggregatesFilter<"SalesChannel"> | string
    salesChannelDesc?: StringNullableWithAggregatesFilter<"SalesChannel"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SalesChannel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesChannel"> | Date | string
  }

  export type SalesOfficeWhereInput = {
    AND?: SalesOfficeWhereInput | SalesOfficeWhereInput[]
    OR?: SalesOfficeWhereInput[]
    NOT?: SalesOfficeWhereInput | SalesOfficeWhereInput[]
    id?: IntFilter<"SalesOffice"> | number
    salesOfficeId?: StringFilter<"SalesOffice"> | string
    organizationName?: StringFilter<"SalesOffice"> | string
    salesOfficeDesc?: StringNullableFilter<"SalesOffice"> | string | null
    street1?: StringFilter<"SalesOffice"> | string
    street2?: StringNullableFilter<"SalesOffice"> | string | null
    city?: StringFilter<"SalesOffice"> | string
    state?: StringFilter<"SalesOffice"> | string
    region?: StringNullableFilter<"SalesOffice"> | string | null
    country?: StringFilter<"SalesOffice"> | string
    pinCode?: StringFilter<"SalesOffice"> | string
    validFrom?: DateTimeFilter<"SalesOffice"> | Date | string
    validTo?: DateTimeFilter<"SalesOffice"> | Date | string
    company?: StringFilter<"SalesOffice"> | string
    parentUnit?: StringNullableFilter<"SalesOffice"> | string | null
    createdAt?: DateTimeFilter<"SalesOffice"> | Date | string
    updatedAt?: DateTimeFilter<"SalesOffice"> | Date | string
    officeTeamPairs?: SalesChannelOfficeTeamPairListRelationFilter
    businessUnitSalesPairs?: BusinessUnitSalesPairListRelationFilter
  }

  export type SalesOfficeOrderByWithRelationInput = {
    id?: SortOrder
    salesOfficeId?: SortOrder
    organizationName?: SortOrder
    salesOfficeDesc?: SortOrderInput | SortOrder
    street1?: SortOrder
    street2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrderInput | SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    company?: SortOrder
    parentUnit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeTeamPairs?: SalesChannelOfficeTeamPairOrderByRelationAggregateInput
    businessUnitSalesPairs?: BusinessUnitSalesPairOrderByRelationAggregateInput
  }

  export type SalesOfficeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    salesOfficeId?: string
    AND?: SalesOfficeWhereInput | SalesOfficeWhereInput[]
    OR?: SalesOfficeWhereInput[]
    NOT?: SalesOfficeWhereInput | SalesOfficeWhereInput[]
    organizationName?: StringFilter<"SalesOffice"> | string
    salesOfficeDesc?: StringNullableFilter<"SalesOffice"> | string | null
    street1?: StringFilter<"SalesOffice"> | string
    street2?: StringNullableFilter<"SalesOffice"> | string | null
    city?: StringFilter<"SalesOffice"> | string
    state?: StringFilter<"SalesOffice"> | string
    region?: StringNullableFilter<"SalesOffice"> | string | null
    country?: StringFilter<"SalesOffice"> | string
    pinCode?: StringFilter<"SalesOffice"> | string
    validFrom?: DateTimeFilter<"SalesOffice"> | Date | string
    validTo?: DateTimeFilter<"SalesOffice"> | Date | string
    company?: StringFilter<"SalesOffice"> | string
    parentUnit?: StringNullableFilter<"SalesOffice"> | string | null
    createdAt?: DateTimeFilter<"SalesOffice"> | Date | string
    updatedAt?: DateTimeFilter<"SalesOffice"> | Date | string
    officeTeamPairs?: SalesChannelOfficeTeamPairListRelationFilter
    businessUnitSalesPairs?: BusinessUnitSalesPairListRelationFilter
  }, "id" | "salesOfficeId">

  export type SalesOfficeOrderByWithAggregationInput = {
    id?: SortOrder
    salesOfficeId?: SortOrder
    organizationName?: SortOrder
    salesOfficeDesc?: SortOrderInput | SortOrder
    street1?: SortOrder
    street2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrderInput | SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    company?: SortOrder
    parentUnit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesOfficeCountOrderByAggregateInput
    _avg?: SalesOfficeAvgOrderByAggregateInput
    _max?: SalesOfficeMaxOrderByAggregateInput
    _min?: SalesOfficeMinOrderByAggregateInput
    _sum?: SalesOfficeSumOrderByAggregateInput
  }

  export type SalesOfficeScalarWhereWithAggregatesInput = {
    AND?: SalesOfficeScalarWhereWithAggregatesInput | SalesOfficeScalarWhereWithAggregatesInput[]
    OR?: SalesOfficeScalarWhereWithAggregatesInput[]
    NOT?: SalesOfficeScalarWhereWithAggregatesInput | SalesOfficeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalesOffice"> | number
    salesOfficeId?: StringWithAggregatesFilter<"SalesOffice"> | string
    organizationName?: StringWithAggregatesFilter<"SalesOffice"> | string
    salesOfficeDesc?: StringNullableWithAggregatesFilter<"SalesOffice"> | string | null
    street1?: StringWithAggregatesFilter<"SalesOffice"> | string
    street2?: StringNullableWithAggregatesFilter<"SalesOffice"> | string | null
    city?: StringWithAggregatesFilter<"SalesOffice"> | string
    state?: StringWithAggregatesFilter<"SalesOffice"> | string
    region?: StringNullableWithAggregatesFilter<"SalesOffice"> | string | null
    country?: StringWithAggregatesFilter<"SalesOffice"> | string
    pinCode?: StringWithAggregatesFilter<"SalesOffice"> | string
    validFrom?: DateTimeWithAggregatesFilter<"SalesOffice"> | Date | string
    validTo?: DateTimeWithAggregatesFilter<"SalesOffice"> | Date | string
    company?: StringWithAggregatesFilter<"SalesOffice"> | string
    parentUnit?: StringNullableWithAggregatesFilter<"SalesOffice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SalesOffice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesOffice"> | Date | string
  }

  export type SalesTeamWhereInput = {
    AND?: SalesTeamWhereInput | SalesTeamWhereInput[]
    OR?: SalesTeamWhereInput[]
    NOT?: SalesTeamWhereInput | SalesTeamWhereInput[]
    id?: IntFilter<"SalesTeam"> | number
    salesTeamCode?: StringFilter<"SalesTeam"> | string
    salesTeamName?: StringFilter<"SalesTeam"> | string
    createdAt?: DateTimeFilter<"SalesTeam"> | Date | string
    updatedAt?: DateTimeFilter<"SalesTeam"> | Date | string
    officeTeamPairs?: SalesChannelOfficeTeamPairListRelationFilter
    businessUnitSalesPairs?: BusinessUnitSalesPairListRelationFilter
  }

  export type SalesTeamOrderByWithRelationInput = {
    id?: SortOrder
    salesTeamCode?: SortOrder
    salesTeamName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeTeamPairs?: SalesChannelOfficeTeamPairOrderByRelationAggregateInput
    businessUnitSalesPairs?: BusinessUnitSalesPairOrderByRelationAggregateInput
  }

  export type SalesTeamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    salesTeamCode?: string
    AND?: SalesTeamWhereInput | SalesTeamWhereInput[]
    OR?: SalesTeamWhereInput[]
    NOT?: SalesTeamWhereInput | SalesTeamWhereInput[]
    salesTeamName?: StringFilter<"SalesTeam"> | string
    createdAt?: DateTimeFilter<"SalesTeam"> | Date | string
    updatedAt?: DateTimeFilter<"SalesTeam"> | Date | string
    officeTeamPairs?: SalesChannelOfficeTeamPairListRelationFilter
    businessUnitSalesPairs?: BusinessUnitSalesPairListRelationFilter
  }, "id" | "salesTeamCode">

  export type SalesTeamOrderByWithAggregationInput = {
    id?: SortOrder
    salesTeamCode?: SortOrder
    salesTeamName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesTeamCountOrderByAggregateInput
    _avg?: SalesTeamAvgOrderByAggregateInput
    _max?: SalesTeamMaxOrderByAggregateInput
    _min?: SalesTeamMinOrderByAggregateInput
    _sum?: SalesTeamSumOrderByAggregateInput
  }

  export type SalesTeamScalarWhereWithAggregatesInput = {
    AND?: SalesTeamScalarWhereWithAggregatesInput | SalesTeamScalarWhereWithAggregatesInput[]
    OR?: SalesTeamScalarWhereWithAggregatesInput[]
    NOT?: SalesTeamScalarWhereWithAggregatesInput | SalesTeamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalesTeam"> | number
    salesTeamCode?: StringWithAggregatesFilter<"SalesTeam"> | string
    salesTeamName?: StringWithAggregatesFilter<"SalesTeam"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SalesTeam"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesTeam"> | Date | string
  }

  export type SalesChannelOfficeTeamPairWhereInput = {
    AND?: SalesChannelOfficeTeamPairWhereInput | SalesChannelOfficeTeamPairWhereInput[]
    OR?: SalesChannelOfficeTeamPairWhereInput[]
    NOT?: SalesChannelOfficeTeamPairWhereInput | SalesChannelOfficeTeamPairWhereInput[]
    id?: IntFilter<"SalesChannelOfficeTeamPair"> | number
    salesChannelCode?: StringFilter<"SalesChannelOfficeTeamPair"> | string
    salesOfficeId?: StringFilter<"SalesChannelOfficeTeamPair"> | string
    salesTeamCode?: StringFilter<"SalesChannelOfficeTeamPair"> | string
    salesChannel?: XOR<SalesChannelScalarRelationFilter, SalesChannelWhereInput>
    salesOffice?: XOR<SalesOfficeScalarRelationFilter, SalesOfficeWhereInput>
    salesTeam?: XOR<SalesTeamScalarRelationFilter, SalesTeamWhereInput>
  }

  export type SalesChannelOfficeTeamPairOrderByWithRelationInput = {
    id?: SortOrder
    salesChannelCode?: SortOrder
    salesOfficeId?: SortOrder
    salesTeamCode?: SortOrder
    salesChannel?: SalesChannelOrderByWithRelationInput
    salesOffice?: SalesOfficeOrderByWithRelationInput
    salesTeam?: SalesTeamOrderByWithRelationInput
  }

  export type SalesChannelOfficeTeamPairWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    salesChannelCode_salesOfficeId_salesTeamCode?: SalesChannelOfficeTeamPairSalesChannelCodeSalesOfficeIdSalesTeamCodeCompoundUniqueInput
    AND?: SalesChannelOfficeTeamPairWhereInput | SalesChannelOfficeTeamPairWhereInput[]
    OR?: SalesChannelOfficeTeamPairWhereInput[]
    NOT?: SalesChannelOfficeTeamPairWhereInput | SalesChannelOfficeTeamPairWhereInput[]
    salesChannelCode?: StringFilter<"SalesChannelOfficeTeamPair"> | string
    salesOfficeId?: StringFilter<"SalesChannelOfficeTeamPair"> | string
    salesTeamCode?: StringFilter<"SalesChannelOfficeTeamPair"> | string
    salesChannel?: XOR<SalesChannelScalarRelationFilter, SalesChannelWhereInput>
    salesOffice?: XOR<SalesOfficeScalarRelationFilter, SalesOfficeWhereInput>
    salesTeam?: XOR<SalesTeamScalarRelationFilter, SalesTeamWhereInput>
  }, "id" | "salesChannelCode_salesOfficeId_salesTeamCode">

  export type SalesChannelOfficeTeamPairOrderByWithAggregationInput = {
    id?: SortOrder
    salesChannelCode?: SortOrder
    salesOfficeId?: SortOrder
    salesTeamCode?: SortOrder
    _count?: SalesChannelOfficeTeamPairCountOrderByAggregateInput
    _avg?: SalesChannelOfficeTeamPairAvgOrderByAggregateInput
    _max?: SalesChannelOfficeTeamPairMaxOrderByAggregateInput
    _min?: SalesChannelOfficeTeamPairMinOrderByAggregateInput
    _sum?: SalesChannelOfficeTeamPairSumOrderByAggregateInput
  }

  export type SalesChannelOfficeTeamPairScalarWhereWithAggregatesInput = {
    AND?: SalesChannelOfficeTeamPairScalarWhereWithAggregatesInput | SalesChannelOfficeTeamPairScalarWhereWithAggregatesInput[]
    OR?: SalesChannelOfficeTeamPairScalarWhereWithAggregatesInput[]
    NOT?: SalesChannelOfficeTeamPairScalarWhereWithAggregatesInput | SalesChannelOfficeTeamPairScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalesChannelOfficeTeamPair"> | number
    salesChannelCode?: StringWithAggregatesFilter<"SalesChannelOfficeTeamPair"> | string
    salesOfficeId?: StringWithAggregatesFilter<"SalesChannelOfficeTeamPair"> | string
    salesTeamCode?: StringWithAggregatesFilter<"SalesChannelOfficeTeamPair"> | string
  }

  export type MarketingChannelWhereInput = {
    AND?: MarketingChannelWhereInput | MarketingChannelWhereInput[]
    OR?: MarketingChannelWhereInput[]
    NOT?: MarketingChannelWhereInput | MarketingChannelWhereInput[]
    id?: IntFilter<"MarketingChannel"> | number
    marketingChannelCode?: StringFilter<"MarketingChannel"> | string
    marketingChannelName?: StringFilter<"MarketingChannel"> | string
    marketingChannelDesc?: StringNullableFilter<"MarketingChannel"> | string | null
    createdAt?: DateTimeFilter<"MarketingChannel"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingChannel"> | Date | string
    channelOfficePairs?: MarketingChannelOfficeTeamPairListRelationFilter
    businessUnitMarketingPairs?: BusinessUnitMarketingPairListRelationFilter
  }

  export type MarketingChannelOrderByWithRelationInput = {
    id?: SortOrder
    marketingChannelCode?: SortOrder
    marketingChannelName?: SortOrder
    marketingChannelDesc?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    channelOfficePairs?: MarketingChannelOfficeTeamPairOrderByRelationAggregateInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairOrderByRelationAggregateInput
  }

  export type MarketingChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    marketingChannelCode?: string
    AND?: MarketingChannelWhereInput | MarketingChannelWhereInput[]
    OR?: MarketingChannelWhereInput[]
    NOT?: MarketingChannelWhereInput | MarketingChannelWhereInput[]
    marketingChannelName?: StringFilter<"MarketingChannel"> | string
    marketingChannelDesc?: StringNullableFilter<"MarketingChannel"> | string | null
    createdAt?: DateTimeFilter<"MarketingChannel"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingChannel"> | Date | string
    channelOfficePairs?: MarketingChannelOfficeTeamPairListRelationFilter
    businessUnitMarketingPairs?: BusinessUnitMarketingPairListRelationFilter
  }, "id" | "marketingChannelCode">

  export type MarketingChannelOrderByWithAggregationInput = {
    id?: SortOrder
    marketingChannelCode?: SortOrder
    marketingChannelName?: SortOrder
    marketingChannelDesc?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarketingChannelCountOrderByAggregateInput
    _avg?: MarketingChannelAvgOrderByAggregateInput
    _max?: MarketingChannelMaxOrderByAggregateInput
    _min?: MarketingChannelMinOrderByAggregateInput
    _sum?: MarketingChannelSumOrderByAggregateInput
  }

  export type MarketingChannelScalarWhereWithAggregatesInput = {
    AND?: MarketingChannelScalarWhereWithAggregatesInput | MarketingChannelScalarWhereWithAggregatesInput[]
    OR?: MarketingChannelScalarWhereWithAggregatesInput[]
    NOT?: MarketingChannelScalarWhereWithAggregatesInput | MarketingChannelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MarketingChannel"> | number
    marketingChannelCode?: StringWithAggregatesFilter<"MarketingChannel"> | string
    marketingChannelName?: StringWithAggregatesFilter<"MarketingChannel"> | string
    marketingChannelDesc?: StringNullableWithAggregatesFilter<"MarketingChannel"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MarketingChannel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketingChannel"> | Date | string
  }

  export type MarketingOfficeWhereInput = {
    AND?: MarketingOfficeWhereInput | MarketingOfficeWhereInput[]
    OR?: MarketingOfficeWhereInput[]
    NOT?: MarketingOfficeWhereInput | MarketingOfficeWhereInput[]
    id?: IntFilter<"MarketingOffice"> | number
    marketingOfficeId?: StringFilter<"MarketingOffice"> | string
    organizationName?: StringFilter<"MarketingOffice"> | string
    marketingOfficeDesc?: StringNullableFilter<"MarketingOffice"> | string | null
    street1?: StringFilter<"MarketingOffice"> | string
    street2?: StringNullableFilter<"MarketingOffice"> | string | null
    city?: StringFilter<"MarketingOffice"> | string
    state?: StringFilter<"MarketingOffice"> | string
    region?: StringNullableFilter<"MarketingOffice"> | string | null
    country?: StringFilter<"MarketingOffice"> | string
    pinCode?: StringFilter<"MarketingOffice"> | string
    validFrom?: DateTimeFilter<"MarketingOffice"> | Date | string
    validTo?: DateTimeFilter<"MarketingOffice"> | Date | string
    company?: StringFilter<"MarketingOffice"> | string
    parentUnit?: StringNullableFilter<"MarketingOffice"> | string | null
    createdAt?: DateTimeFilter<"MarketingOffice"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingOffice"> | Date | string
    officeTeamPairs?: MarketingChannelOfficeTeamPairListRelationFilter
    businessUnitMarketingPairs?: BusinessUnitMarketingPairListRelationFilter
  }

  export type MarketingOfficeOrderByWithRelationInput = {
    id?: SortOrder
    marketingOfficeId?: SortOrder
    organizationName?: SortOrder
    marketingOfficeDesc?: SortOrderInput | SortOrder
    street1?: SortOrder
    street2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrderInput | SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    company?: SortOrder
    parentUnit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeTeamPairs?: MarketingChannelOfficeTeamPairOrderByRelationAggregateInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairOrderByRelationAggregateInput
  }

  export type MarketingOfficeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    marketingOfficeId?: string
    AND?: MarketingOfficeWhereInput | MarketingOfficeWhereInput[]
    OR?: MarketingOfficeWhereInput[]
    NOT?: MarketingOfficeWhereInput | MarketingOfficeWhereInput[]
    organizationName?: StringFilter<"MarketingOffice"> | string
    marketingOfficeDesc?: StringNullableFilter<"MarketingOffice"> | string | null
    street1?: StringFilter<"MarketingOffice"> | string
    street2?: StringNullableFilter<"MarketingOffice"> | string | null
    city?: StringFilter<"MarketingOffice"> | string
    state?: StringFilter<"MarketingOffice"> | string
    region?: StringNullableFilter<"MarketingOffice"> | string | null
    country?: StringFilter<"MarketingOffice"> | string
    pinCode?: StringFilter<"MarketingOffice"> | string
    validFrom?: DateTimeFilter<"MarketingOffice"> | Date | string
    validTo?: DateTimeFilter<"MarketingOffice"> | Date | string
    company?: StringFilter<"MarketingOffice"> | string
    parentUnit?: StringNullableFilter<"MarketingOffice"> | string | null
    createdAt?: DateTimeFilter<"MarketingOffice"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingOffice"> | Date | string
    officeTeamPairs?: MarketingChannelOfficeTeamPairListRelationFilter
    businessUnitMarketingPairs?: BusinessUnitMarketingPairListRelationFilter
  }, "id" | "marketingOfficeId">

  export type MarketingOfficeOrderByWithAggregationInput = {
    id?: SortOrder
    marketingOfficeId?: SortOrder
    organizationName?: SortOrder
    marketingOfficeDesc?: SortOrderInput | SortOrder
    street1?: SortOrder
    street2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrderInput | SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    company?: SortOrder
    parentUnit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarketingOfficeCountOrderByAggregateInput
    _avg?: MarketingOfficeAvgOrderByAggregateInput
    _max?: MarketingOfficeMaxOrderByAggregateInput
    _min?: MarketingOfficeMinOrderByAggregateInput
    _sum?: MarketingOfficeSumOrderByAggregateInput
  }

  export type MarketingOfficeScalarWhereWithAggregatesInput = {
    AND?: MarketingOfficeScalarWhereWithAggregatesInput | MarketingOfficeScalarWhereWithAggregatesInput[]
    OR?: MarketingOfficeScalarWhereWithAggregatesInput[]
    NOT?: MarketingOfficeScalarWhereWithAggregatesInput | MarketingOfficeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MarketingOffice"> | number
    marketingOfficeId?: StringWithAggregatesFilter<"MarketingOffice"> | string
    organizationName?: StringWithAggregatesFilter<"MarketingOffice"> | string
    marketingOfficeDesc?: StringNullableWithAggregatesFilter<"MarketingOffice"> | string | null
    street1?: StringWithAggregatesFilter<"MarketingOffice"> | string
    street2?: StringNullableWithAggregatesFilter<"MarketingOffice"> | string | null
    city?: StringWithAggregatesFilter<"MarketingOffice"> | string
    state?: StringWithAggregatesFilter<"MarketingOffice"> | string
    region?: StringNullableWithAggregatesFilter<"MarketingOffice"> | string | null
    country?: StringWithAggregatesFilter<"MarketingOffice"> | string
    pinCode?: StringWithAggregatesFilter<"MarketingOffice"> | string
    validFrom?: DateTimeWithAggregatesFilter<"MarketingOffice"> | Date | string
    validTo?: DateTimeWithAggregatesFilter<"MarketingOffice"> | Date | string
    company?: StringWithAggregatesFilter<"MarketingOffice"> | string
    parentUnit?: StringNullableWithAggregatesFilter<"MarketingOffice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MarketingOffice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketingOffice"> | Date | string
  }

  export type MarketingTeamWhereInput = {
    AND?: MarketingTeamWhereInput | MarketingTeamWhereInput[]
    OR?: MarketingTeamWhereInput[]
    NOT?: MarketingTeamWhereInput | MarketingTeamWhereInput[]
    id?: IntFilter<"MarketingTeam"> | number
    marketingTeamCode?: StringFilter<"MarketingTeam"> | string
    marketingTeamName?: StringFilter<"MarketingTeam"> | string
    createdAt?: DateTimeFilter<"MarketingTeam"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingTeam"> | Date | string
    officeTeamPairs?: MarketingChannelOfficeTeamPairListRelationFilter
    businessUnitMarketingPairs?: BusinessUnitMarketingPairListRelationFilter
  }

  export type MarketingTeamOrderByWithRelationInput = {
    id?: SortOrder
    marketingTeamCode?: SortOrder
    marketingTeamName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeTeamPairs?: MarketingChannelOfficeTeamPairOrderByRelationAggregateInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairOrderByRelationAggregateInput
  }

  export type MarketingTeamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    marketingTeamCode?: string
    AND?: MarketingTeamWhereInput | MarketingTeamWhereInput[]
    OR?: MarketingTeamWhereInput[]
    NOT?: MarketingTeamWhereInput | MarketingTeamWhereInput[]
    marketingTeamName?: StringFilter<"MarketingTeam"> | string
    createdAt?: DateTimeFilter<"MarketingTeam"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingTeam"> | Date | string
    officeTeamPairs?: MarketingChannelOfficeTeamPairListRelationFilter
    businessUnitMarketingPairs?: BusinessUnitMarketingPairListRelationFilter
  }, "id" | "marketingTeamCode">

  export type MarketingTeamOrderByWithAggregationInput = {
    id?: SortOrder
    marketingTeamCode?: SortOrder
    marketingTeamName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarketingTeamCountOrderByAggregateInput
    _avg?: MarketingTeamAvgOrderByAggregateInput
    _max?: MarketingTeamMaxOrderByAggregateInput
    _min?: MarketingTeamMinOrderByAggregateInput
    _sum?: MarketingTeamSumOrderByAggregateInput
  }

  export type MarketingTeamScalarWhereWithAggregatesInput = {
    AND?: MarketingTeamScalarWhereWithAggregatesInput | MarketingTeamScalarWhereWithAggregatesInput[]
    OR?: MarketingTeamScalarWhereWithAggregatesInput[]
    NOT?: MarketingTeamScalarWhereWithAggregatesInput | MarketingTeamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MarketingTeam"> | number
    marketingTeamCode?: StringWithAggregatesFilter<"MarketingTeam"> | string
    marketingTeamName?: StringWithAggregatesFilter<"MarketingTeam"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MarketingTeam"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketingTeam"> | Date | string
  }

  export type MarketingChannelOfficeTeamPairWhereInput = {
    AND?: MarketingChannelOfficeTeamPairWhereInput | MarketingChannelOfficeTeamPairWhereInput[]
    OR?: MarketingChannelOfficeTeamPairWhereInput[]
    NOT?: MarketingChannelOfficeTeamPairWhereInput | MarketingChannelOfficeTeamPairWhereInput[]
    id?: IntFilter<"MarketingChannelOfficeTeamPair"> | number
    marketingChannelCode?: StringFilter<"MarketingChannelOfficeTeamPair"> | string
    marketingOfficeId?: StringFilter<"MarketingChannelOfficeTeamPair"> | string
    marketingTeamCode?: StringFilter<"MarketingChannelOfficeTeamPair"> | string
    marketingChannel?: XOR<MarketingChannelScalarRelationFilter, MarketingChannelWhereInput>
    marketingOffice?: XOR<MarketingOfficeScalarRelationFilter, MarketingOfficeWhereInput>
    marketingTeam?: XOR<MarketingTeamScalarRelationFilter, MarketingTeamWhereInput>
  }

  export type MarketingChannelOfficeTeamPairOrderByWithRelationInput = {
    id?: SortOrder
    marketingChannelCode?: SortOrder
    marketingOfficeId?: SortOrder
    marketingTeamCode?: SortOrder
    marketingChannel?: MarketingChannelOrderByWithRelationInput
    marketingOffice?: MarketingOfficeOrderByWithRelationInput
    marketingTeam?: MarketingTeamOrderByWithRelationInput
  }

  export type MarketingChannelOfficeTeamPairWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    marketingChannelCode_marketingOfficeId_marketingTeamCode?: MarketingChannelOfficeTeamPairMarketingChannelCodeMarketingOfficeIdMarketingTeamCodeCompoundUniqueInput
    AND?: MarketingChannelOfficeTeamPairWhereInput | MarketingChannelOfficeTeamPairWhereInput[]
    OR?: MarketingChannelOfficeTeamPairWhereInput[]
    NOT?: MarketingChannelOfficeTeamPairWhereInput | MarketingChannelOfficeTeamPairWhereInput[]
    marketingChannelCode?: StringFilter<"MarketingChannelOfficeTeamPair"> | string
    marketingOfficeId?: StringFilter<"MarketingChannelOfficeTeamPair"> | string
    marketingTeamCode?: StringFilter<"MarketingChannelOfficeTeamPair"> | string
    marketingChannel?: XOR<MarketingChannelScalarRelationFilter, MarketingChannelWhereInput>
    marketingOffice?: XOR<MarketingOfficeScalarRelationFilter, MarketingOfficeWhereInput>
    marketingTeam?: XOR<MarketingTeamScalarRelationFilter, MarketingTeamWhereInput>
  }, "id" | "marketingChannelCode_marketingOfficeId_marketingTeamCode">

  export type MarketingChannelOfficeTeamPairOrderByWithAggregationInput = {
    id?: SortOrder
    marketingChannelCode?: SortOrder
    marketingOfficeId?: SortOrder
    marketingTeamCode?: SortOrder
    _count?: MarketingChannelOfficeTeamPairCountOrderByAggregateInput
    _avg?: MarketingChannelOfficeTeamPairAvgOrderByAggregateInput
    _max?: MarketingChannelOfficeTeamPairMaxOrderByAggregateInput
    _min?: MarketingChannelOfficeTeamPairMinOrderByAggregateInput
    _sum?: MarketingChannelOfficeTeamPairSumOrderByAggregateInput
  }

  export type MarketingChannelOfficeTeamPairScalarWhereWithAggregatesInput = {
    AND?: MarketingChannelOfficeTeamPairScalarWhereWithAggregatesInput | MarketingChannelOfficeTeamPairScalarWhereWithAggregatesInput[]
    OR?: MarketingChannelOfficeTeamPairScalarWhereWithAggregatesInput[]
    NOT?: MarketingChannelOfficeTeamPairScalarWhereWithAggregatesInput | MarketingChannelOfficeTeamPairScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MarketingChannelOfficeTeamPair"> | number
    marketingChannelCode?: StringWithAggregatesFilter<"MarketingChannelOfficeTeamPair"> | string
    marketingOfficeId?: StringWithAggregatesFilter<"MarketingChannelOfficeTeamPair"> | string
    marketingTeamCode?: StringWithAggregatesFilter<"MarketingChannelOfficeTeamPair"> | string
  }

  export type ServiceChannelWhereInput = {
    AND?: ServiceChannelWhereInput | ServiceChannelWhereInput[]
    OR?: ServiceChannelWhereInput[]
    NOT?: ServiceChannelWhereInput | ServiceChannelWhereInput[]
    id?: IntFilter<"ServiceChannel"> | number
    serviceChannelCode?: StringFilter<"ServiceChannel"> | string
    serviceChannelName?: StringFilter<"ServiceChannel"> | string
    serviceChannelDesc?: StringNullableFilter<"ServiceChannel"> | string | null
    createdAt?: DateTimeFilter<"ServiceChannel"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceChannel"> | Date | string
    channelOfficePairs?: ServiceChannelOfficeTeamPairListRelationFilter
    businessUnitServicePairs?: BusinessUnitServicePairListRelationFilter
  }

  export type ServiceChannelOrderByWithRelationInput = {
    id?: SortOrder
    serviceChannelCode?: SortOrder
    serviceChannelName?: SortOrder
    serviceChannelDesc?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    channelOfficePairs?: ServiceChannelOfficeTeamPairOrderByRelationAggregateInput
    businessUnitServicePairs?: BusinessUnitServicePairOrderByRelationAggregateInput
  }

  export type ServiceChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serviceChannelCode?: string
    AND?: ServiceChannelWhereInput | ServiceChannelWhereInput[]
    OR?: ServiceChannelWhereInput[]
    NOT?: ServiceChannelWhereInput | ServiceChannelWhereInput[]
    serviceChannelName?: StringFilter<"ServiceChannel"> | string
    serviceChannelDesc?: StringNullableFilter<"ServiceChannel"> | string | null
    createdAt?: DateTimeFilter<"ServiceChannel"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceChannel"> | Date | string
    channelOfficePairs?: ServiceChannelOfficeTeamPairListRelationFilter
    businessUnitServicePairs?: BusinessUnitServicePairListRelationFilter
  }, "id" | "serviceChannelCode">

  export type ServiceChannelOrderByWithAggregationInput = {
    id?: SortOrder
    serviceChannelCode?: SortOrder
    serviceChannelName?: SortOrder
    serviceChannelDesc?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceChannelCountOrderByAggregateInput
    _avg?: ServiceChannelAvgOrderByAggregateInput
    _max?: ServiceChannelMaxOrderByAggregateInput
    _min?: ServiceChannelMinOrderByAggregateInput
    _sum?: ServiceChannelSumOrderByAggregateInput
  }

  export type ServiceChannelScalarWhereWithAggregatesInput = {
    AND?: ServiceChannelScalarWhereWithAggregatesInput | ServiceChannelScalarWhereWithAggregatesInput[]
    OR?: ServiceChannelScalarWhereWithAggregatesInput[]
    NOT?: ServiceChannelScalarWhereWithAggregatesInput | ServiceChannelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceChannel"> | number
    serviceChannelCode?: StringWithAggregatesFilter<"ServiceChannel"> | string
    serviceChannelName?: StringWithAggregatesFilter<"ServiceChannel"> | string
    serviceChannelDesc?: StringNullableWithAggregatesFilter<"ServiceChannel"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceChannel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceChannel"> | Date | string
  }

  export type ServiceOfficeWhereInput = {
    AND?: ServiceOfficeWhereInput | ServiceOfficeWhereInput[]
    OR?: ServiceOfficeWhereInput[]
    NOT?: ServiceOfficeWhereInput | ServiceOfficeWhereInput[]
    id?: IntFilter<"ServiceOffice"> | number
    serviceOfficeId?: StringFilter<"ServiceOffice"> | string
    organizationName?: StringFilter<"ServiceOffice"> | string
    serviceOfficeDesc?: StringNullableFilter<"ServiceOffice"> | string | null
    street1?: StringFilter<"ServiceOffice"> | string
    street2?: StringNullableFilter<"ServiceOffice"> | string | null
    city?: StringFilter<"ServiceOffice"> | string
    state?: StringFilter<"ServiceOffice"> | string
    region?: StringNullableFilter<"ServiceOffice"> | string | null
    country?: StringFilter<"ServiceOffice"> | string
    pinCode?: StringFilter<"ServiceOffice"> | string
    validFrom?: DateTimeFilter<"ServiceOffice"> | Date | string
    validTo?: DateTimeFilter<"ServiceOffice"> | Date | string
    company?: StringFilter<"ServiceOffice"> | string
    parentUnit?: StringNullableFilter<"ServiceOffice"> | string | null
    createdAt?: DateTimeFilter<"ServiceOffice"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceOffice"> | Date | string
    officeTeamPairs?: ServiceChannelOfficeTeamPairListRelationFilter
    businessUnitServicePairs?: BusinessUnitServicePairListRelationFilter
  }

  export type ServiceOfficeOrderByWithRelationInput = {
    id?: SortOrder
    serviceOfficeId?: SortOrder
    organizationName?: SortOrder
    serviceOfficeDesc?: SortOrderInput | SortOrder
    street1?: SortOrder
    street2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrderInput | SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    company?: SortOrder
    parentUnit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeTeamPairs?: ServiceChannelOfficeTeamPairOrderByRelationAggregateInput
    businessUnitServicePairs?: BusinessUnitServicePairOrderByRelationAggregateInput
  }

  export type ServiceOfficeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serviceOfficeId?: string
    AND?: ServiceOfficeWhereInput | ServiceOfficeWhereInput[]
    OR?: ServiceOfficeWhereInput[]
    NOT?: ServiceOfficeWhereInput | ServiceOfficeWhereInput[]
    organizationName?: StringFilter<"ServiceOffice"> | string
    serviceOfficeDesc?: StringNullableFilter<"ServiceOffice"> | string | null
    street1?: StringFilter<"ServiceOffice"> | string
    street2?: StringNullableFilter<"ServiceOffice"> | string | null
    city?: StringFilter<"ServiceOffice"> | string
    state?: StringFilter<"ServiceOffice"> | string
    region?: StringNullableFilter<"ServiceOffice"> | string | null
    country?: StringFilter<"ServiceOffice"> | string
    pinCode?: StringFilter<"ServiceOffice"> | string
    validFrom?: DateTimeFilter<"ServiceOffice"> | Date | string
    validTo?: DateTimeFilter<"ServiceOffice"> | Date | string
    company?: StringFilter<"ServiceOffice"> | string
    parentUnit?: StringNullableFilter<"ServiceOffice"> | string | null
    createdAt?: DateTimeFilter<"ServiceOffice"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceOffice"> | Date | string
    officeTeamPairs?: ServiceChannelOfficeTeamPairListRelationFilter
    businessUnitServicePairs?: BusinessUnitServicePairListRelationFilter
  }, "id" | "serviceOfficeId">

  export type ServiceOfficeOrderByWithAggregationInput = {
    id?: SortOrder
    serviceOfficeId?: SortOrder
    organizationName?: SortOrder
    serviceOfficeDesc?: SortOrderInput | SortOrder
    street1?: SortOrder
    street2?: SortOrderInput | SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrderInput | SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    company?: SortOrder
    parentUnit?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceOfficeCountOrderByAggregateInput
    _avg?: ServiceOfficeAvgOrderByAggregateInput
    _max?: ServiceOfficeMaxOrderByAggregateInput
    _min?: ServiceOfficeMinOrderByAggregateInput
    _sum?: ServiceOfficeSumOrderByAggregateInput
  }

  export type ServiceOfficeScalarWhereWithAggregatesInput = {
    AND?: ServiceOfficeScalarWhereWithAggregatesInput | ServiceOfficeScalarWhereWithAggregatesInput[]
    OR?: ServiceOfficeScalarWhereWithAggregatesInput[]
    NOT?: ServiceOfficeScalarWhereWithAggregatesInput | ServiceOfficeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceOffice"> | number
    serviceOfficeId?: StringWithAggregatesFilter<"ServiceOffice"> | string
    organizationName?: StringWithAggregatesFilter<"ServiceOffice"> | string
    serviceOfficeDesc?: StringNullableWithAggregatesFilter<"ServiceOffice"> | string | null
    street1?: StringWithAggregatesFilter<"ServiceOffice"> | string
    street2?: StringNullableWithAggregatesFilter<"ServiceOffice"> | string | null
    city?: StringWithAggregatesFilter<"ServiceOffice"> | string
    state?: StringWithAggregatesFilter<"ServiceOffice"> | string
    region?: StringNullableWithAggregatesFilter<"ServiceOffice"> | string | null
    country?: StringWithAggregatesFilter<"ServiceOffice"> | string
    pinCode?: StringWithAggregatesFilter<"ServiceOffice"> | string
    validFrom?: DateTimeWithAggregatesFilter<"ServiceOffice"> | Date | string
    validTo?: DateTimeWithAggregatesFilter<"ServiceOffice"> | Date | string
    company?: StringWithAggregatesFilter<"ServiceOffice"> | string
    parentUnit?: StringNullableWithAggregatesFilter<"ServiceOffice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceOffice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceOffice"> | Date | string
  }

  export type ServiceTeamWhereInput = {
    AND?: ServiceTeamWhereInput | ServiceTeamWhereInput[]
    OR?: ServiceTeamWhereInput[]
    NOT?: ServiceTeamWhereInput | ServiceTeamWhereInput[]
    id?: IntFilter<"ServiceTeam"> | number
    serviceTeamCode?: StringFilter<"ServiceTeam"> | string
    serviceTeamName?: StringFilter<"ServiceTeam"> | string
    createdAt?: DateTimeFilter<"ServiceTeam"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceTeam"> | Date | string
    officeTeamPairs?: ServiceChannelOfficeTeamPairListRelationFilter
    businessUnitServicePairs?: BusinessUnitServicePairListRelationFilter
  }

  export type ServiceTeamOrderByWithRelationInput = {
    id?: SortOrder
    serviceTeamCode?: SortOrder
    serviceTeamName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    officeTeamPairs?: ServiceChannelOfficeTeamPairOrderByRelationAggregateInput
    businessUnitServicePairs?: BusinessUnitServicePairOrderByRelationAggregateInput
  }

  export type ServiceTeamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serviceTeamCode?: string
    AND?: ServiceTeamWhereInput | ServiceTeamWhereInput[]
    OR?: ServiceTeamWhereInput[]
    NOT?: ServiceTeamWhereInput | ServiceTeamWhereInput[]
    serviceTeamName?: StringFilter<"ServiceTeam"> | string
    createdAt?: DateTimeFilter<"ServiceTeam"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceTeam"> | Date | string
    officeTeamPairs?: ServiceChannelOfficeTeamPairListRelationFilter
    businessUnitServicePairs?: BusinessUnitServicePairListRelationFilter
  }, "id" | "serviceTeamCode">

  export type ServiceTeamOrderByWithAggregationInput = {
    id?: SortOrder
    serviceTeamCode?: SortOrder
    serviceTeamName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceTeamCountOrderByAggregateInput
    _avg?: ServiceTeamAvgOrderByAggregateInput
    _max?: ServiceTeamMaxOrderByAggregateInput
    _min?: ServiceTeamMinOrderByAggregateInput
    _sum?: ServiceTeamSumOrderByAggregateInput
  }

  export type ServiceTeamScalarWhereWithAggregatesInput = {
    AND?: ServiceTeamScalarWhereWithAggregatesInput | ServiceTeamScalarWhereWithAggregatesInput[]
    OR?: ServiceTeamScalarWhereWithAggregatesInput[]
    NOT?: ServiceTeamScalarWhereWithAggregatesInput | ServiceTeamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceTeam"> | number
    serviceTeamCode?: StringWithAggregatesFilter<"ServiceTeam"> | string
    serviceTeamName?: StringWithAggregatesFilter<"ServiceTeam"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ServiceTeam"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceTeam"> | Date | string
  }

  export type ServiceChannelOfficeTeamPairWhereInput = {
    AND?: ServiceChannelOfficeTeamPairWhereInput | ServiceChannelOfficeTeamPairWhereInput[]
    OR?: ServiceChannelOfficeTeamPairWhereInput[]
    NOT?: ServiceChannelOfficeTeamPairWhereInput | ServiceChannelOfficeTeamPairWhereInput[]
    id?: IntFilter<"ServiceChannelOfficeTeamPair"> | number
    serviceChannelCode?: StringFilter<"ServiceChannelOfficeTeamPair"> | string
    serviceOfficeId?: StringFilter<"ServiceChannelOfficeTeamPair"> | string
    serviceTeamCode?: StringFilter<"ServiceChannelOfficeTeamPair"> | string
    serviceChannel?: XOR<ServiceChannelScalarRelationFilter, ServiceChannelWhereInput>
    serviceOffice?: XOR<ServiceOfficeScalarRelationFilter, ServiceOfficeWhereInput>
    serviceTeam?: XOR<ServiceTeamScalarRelationFilter, ServiceTeamWhereInput>
  }

  export type ServiceChannelOfficeTeamPairOrderByWithRelationInput = {
    id?: SortOrder
    serviceChannelCode?: SortOrder
    serviceOfficeId?: SortOrder
    serviceTeamCode?: SortOrder
    serviceChannel?: ServiceChannelOrderByWithRelationInput
    serviceOffice?: ServiceOfficeOrderByWithRelationInput
    serviceTeam?: ServiceTeamOrderByWithRelationInput
  }

  export type ServiceChannelOfficeTeamPairWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    serviceChannelCode_serviceOfficeId_serviceTeamCode?: ServiceChannelOfficeTeamPairServiceChannelCodeServiceOfficeIdServiceTeamCodeCompoundUniqueInput
    AND?: ServiceChannelOfficeTeamPairWhereInput | ServiceChannelOfficeTeamPairWhereInput[]
    OR?: ServiceChannelOfficeTeamPairWhereInput[]
    NOT?: ServiceChannelOfficeTeamPairWhereInput | ServiceChannelOfficeTeamPairWhereInput[]
    serviceChannelCode?: StringFilter<"ServiceChannelOfficeTeamPair"> | string
    serviceOfficeId?: StringFilter<"ServiceChannelOfficeTeamPair"> | string
    serviceTeamCode?: StringFilter<"ServiceChannelOfficeTeamPair"> | string
    serviceChannel?: XOR<ServiceChannelScalarRelationFilter, ServiceChannelWhereInput>
    serviceOffice?: XOR<ServiceOfficeScalarRelationFilter, ServiceOfficeWhereInput>
    serviceTeam?: XOR<ServiceTeamScalarRelationFilter, ServiceTeamWhereInput>
  }, "id" | "serviceChannelCode_serviceOfficeId_serviceTeamCode">

  export type ServiceChannelOfficeTeamPairOrderByWithAggregationInput = {
    id?: SortOrder
    serviceChannelCode?: SortOrder
    serviceOfficeId?: SortOrder
    serviceTeamCode?: SortOrder
    _count?: ServiceChannelOfficeTeamPairCountOrderByAggregateInput
    _avg?: ServiceChannelOfficeTeamPairAvgOrderByAggregateInput
    _max?: ServiceChannelOfficeTeamPairMaxOrderByAggregateInput
    _min?: ServiceChannelOfficeTeamPairMinOrderByAggregateInput
    _sum?: ServiceChannelOfficeTeamPairSumOrderByAggregateInput
  }

  export type ServiceChannelOfficeTeamPairScalarWhereWithAggregatesInput = {
    AND?: ServiceChannelOfficeTeamPairScalarWhereWithAggregatesInput | ServiceChannelOfficeTeamPairScalarWhereWithAggregatesInput[]
    OR?: ServiceChannelOfficeTeamPairScalarWhereWithAggregatesInput[]
    NOT?: ServiceChannelOfficeTeamPairScalarWhereWithAggregatesInput | ServiceChannelOfficeTeamPairScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ServiceChannelOfficeTeamPair"> | number
    serviceChannelCode?: StringWithAggregatesFilter<"ServiceChannelOfficeTeamPair"> | string
    serviceOfficeId?: StringWithAggregatesFilter<"ServiceChannelOfficeTeamPair"> | string
    serviceTeamCode?: StringWithAggregatesFilter<"ServiceChannelOfficeTeamPair"> | string
  }

  export type BusinessUnitSalesPairWhereInput = {
    AND?: BusinessUnitSalesPairWhereInput | BusinessUnitSalesPairWhereInput[]
    OR?: BusinessUnitSalesPairWhereInput[]
    NOT?: BusinessUnitSalesPairWhereInput | BusinessUnitSalesPairWhereInput[]
    id?: StringFilter<"BusinessUnitSalesPair"> | string
    businessUnitCode?: StringFilter<"BusinessUnitSalesPair"> | string
    salesChannelCode?: StringFilter<"BusinessUnitSalesPair"> | string
    salesOfficeId?: StringFilter<"BusinessUnitSalesPair"> | string
    salesTeamCode?: StringFilter<"BusinessUnitSalesPair"> | string
    businessUnit?: XOR<BusinessUnitScalarRelationFilter, BusinessUnitWhereInput>
    salesChannel?: XOR<SalesChannelScalarRelationFilter, SalesChannelWhereInput>
    salesOffice?: XOR<SalesOfficeScalarRelationFilter, SalesOfficeWhereInput>
    salesTeam?: XOR<SalesTeamScalarRelationFilter, SalesTeamWhereInput>
  }

  export type BusinessUnitSalesPairOrderByWithRelationInput = {
    id?: SortOrder
    businessUnitCode?: SortOrder
    salesChannelCode?: SortOrder
    salesOfficeId?: SortOrder
    salesTeamCode?: SortOrder
    businessUnit?: BusinessUnitOrderByWithRelationInput
    salesChannel?: SalesChannelOrderByWithRelationInput
    salesOffice?: SalesOfficeOrderByWithRelationInput
    salesTeam?: SalesTeamOrderByWithRelationInput
  }

  export type BusinessUnitSalesPairWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    businessUnitCode_salesChannelCode_salesOfficeId_salesTeamCode?: BusinessUnitSalesPairBusinessUnitCodeSalesChannelCodeSalesOfficeIdSalesTeamCodeCompoundUniqueInput
    AND?: BusinessUnitSalesPairWhereInput | BusinessUnitSalesPairWhereInput[]
    OR?: BusinessUnitSalesPairWhereInput[]
    NOT?: BusinessUnitSalesPairWhereInput | BusinessUnitSalesPairWhereInput[]
    businessUnitCode?: StringFilter<"BusinessUnitSalesPair"> | string
    salesChannelCode?: StringFilter<"BusinessUnitSalesPair"> | string
    salesOfficeId?: StringFilter<"BusinessUnitSalesPair"> | string
    salesTeamCode?: StringFilter<"BusinessUnitSalesPair"> | string
    businessUnit?: XOR<BusinessUnitScalarRelationFilter, BusinessUnitWhereInput>
    salesChannel?: XOR<SalesChannelScalarRelationFilter, SalesChannelWhereInput>
    salesOffice?: XOR<SalesOfficeScalarRelationFilter, SalesOfficeWhereInput>
    salesTeam?: XOR<SalesTeamScalarRelationFilter, SalesTeamWhereInput>
  }, "id" | "businessUnitCode_salesChannelCode_salesOfficeId_salesTeamCode">

  export type BusinessUnitSalesPairOrderByWithAggregationInput = {
    id?: SortOrder
    businessUnitCode?: SortOrder
    salesChannelCode?: SortOrder
    salesOfficeId?: SortOrder
    salesTeamCode?: SortOrder
    _count?: BusinessUnitSalesPairCountOrderByAggregateInput
    _max?: BusinessUnitSalesPairMaxOrderByAggregateInput
    _min?: BusinessUnitSalesPairMinOrderByAggregateInput
  }

  export type BusinessUnitSalesPairScalarWhereWithAggregatesInput = {
    AND?: BusinessUnitSalesPairScalarWhereWithAggregatesInput | BusinessUnitSalesPairScalarWhereWithAggregatesInput[]
    OR?: BusinessUnitSalesPairScalarWhereWithAggregatesInput[]
    NOT?: BusinessUnitSalesPairScalarWhereWithAggregatesInput | BusinessUnitSalesPairScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessUnitSalesPair"> | string
    businessUnitCode?: StringWithAggregatesFilter<"BusinessUnitSalesPair"> | string
    salesChannelCode?: StringWithAggregatesFilter<"BusinessUnitSalesPair"> | string
    salesOfficeId?: StringWithAggregatesFilter<"BusinessUnitSalesPair"> | string
    salesTeamCode?: StringWithAggregatesFilter<"BusinessUnitSalesPair"> | string
  }

  export type BusinessUnitMarketingPairWhereInput = {
    AND?: BusinessUnitMarketingPairWhereInput | BusinessUnitMarketingPairWhereInput[]
    OR?: BusinessUnitMarketingPairWhereInput[]
    NOT?: BusinessUnitMarketingPairWhereInput | BusinessUnitMarketingPairWhereInput[]
    id?: StringFilter<"BusinessUnitMarketingPair"> | string
    businessUnitCode?: StringFilter<"BusinessUnitMarketingPair"> | string
    marketingChannelCode?: StringFilter<"BusinessUnitMarketingPair"> | string
    marketingOfficeId?: StringFilter<"BusinessUnitMarketingPair"> | string
    marketingTeamCode?: StringFilter<"BusinessUnitMarketingPair"> | string
    businessUnit?: XOR<BusinessUnitScalarRelationFilter, BusinessUnitWhereInput>
    marketingChannel?: XOR<MarketingChannelScalarRelationFilter, MarketingChannelWhereInput>
    marketingOffice?: XOR<MarketingOfficeScalarRelationFilter, MarketingOfficeWhereInput>
    marketingTeam?: XOR<MarketingTeamScalarRelationFilter, MarketingTeamWhereInput>
  }

  export type BusinessUnitMarketingPairOrderByWithRelationInput = {
    id?: SortOrder
    businessUnitCode?: SortOrder
    marketingChannelCode?: SortOrder
    marketingOfficeId?: SortOrder
    marketingTeamCode?: SortOrder
    businessUnit?: BusinessUnitOrderByWithRelationInput
    marketingChannel?: MarketingChannelOrderByWithRelationInput
    marketingOffice?: MarketingOfficeOrderByWithRelationInput
    marketingTeam?: MarketingTeamOrderByWithRelationInput
  }

  export type BusinessUnitMarketingPairWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    businessUnitCode_marketingChannelCode_marketingOfficeId_marketingTeamCode?: BusinessUnitMarketingPairBusinessUnitCodeMarketingChannelCodeMarketingOfficeIdMarketingTeamCodeCompoundUniqueInput
    AND?: BusinessUnitMarketingPairWhereInput | BusinessUnitMarketingPairWhereInput[]
    OR?: BusinessUnitMarketingPairWhereInput[]
    NOT?: BusinessUnitMarketingPairWhereInput | BusinessUnitMarketingPairWhereInput[]
    businessUnitCode?: StringFilter<"BusinessUnitMarketingPair"> | string
    marketingChannelCode?: StringFilter<"BusinessUnitMarketingPair"> | string
    marketingOfficeId?: StringFilter<"BusinessUnitMarketingPair"> | string
    marketingTeamCode?: StringFilter<"BusinessUnitMarketingPair"> | string
    businessUnit?: XOR<BusinessUnitScalarRelationFilter, BusinessUnitWhereInput>
    marketingChannel?: XOR<MarketingChannelScalarRelationFilter, MarketingChannelWhereInput>
    marketingOffice?: XOR<MarketingOfficeScalarRelationFilter, MarketingOfficeWhereInput>
    marketingTeam?: XOR<MarketingTeamScalarRelationFilter, MarketingTeamWhereInput>
  }, "id" | "businessUnitCode_marketingChannelCode_marketingOfficeId_marketingTeamCode">

  export type BusinessUnitMarketingPairOrderByWithAggregationInput = {
    id?: SortOrder
    businessUnitCode?: SortOrder
    marketingChannelCode?: SortOrder
    marketingOfficeId?: SortOrder
    marketingTeamCode?: SortOrder
    _count?: BusinessUnitMarketingPairCountOrderByAggregateInput
    _max?: BusinessUnitMarketingPairMaxOrderByAggregateInput
    _min?: BusinessUnitMarketingPairMinOrderByAggregateInput
  }

  export type BusinessUnitMarketingPairScalarWhereWithAggregatesInput = {
    AND?: BusinessUnitMarketingPairScalarWhereWithAggregatesInput | BusinessUnitMarketingPairScalarWhereWithAggregatesInput[]
    OR?: BusinessUnitMarketingPairScalarWhereWithAggregatesInput[]
    NOT?: BusinessUnitMarketingPairScalarWhereWithAggregatesInput | BusinessUnitMarketingPairScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessUnitMarketingPair"> | string
    businessUnitCode?: StringWithAggregatesFilter<"BusinessUnitMarketingPair"> | string
    marketingChannelCode?: StringWithAggregatesFilter<"BusinessUnitMarketingPair"> | string
    marketingOfficeId?: StringWithAggregatesFilter<"BusinessUnitMarketingPair"> | string
    marketingTeamCode?: StringWithAggregatesFilter<"BusinessUnitMarketingPair"> | string
  }

  export type BusinessUnitServicePairWhereInput = {
    AND?: BusinessUnitServicePairWhereInput | BusinessUnitServicePairWhereInput[]
    OR?: BusinessUnitServicePairWhereInput[]
    NOT?: BusinessUnitServicePairWhereInput | BusinessUnitServicePairWhereInput[]
    id?: StringFilter<"BusinessUnitServicePair"> | string
    businessUnitCode?: StringFilter<"BusinessUnitServicePair"> | string
    serviceChannelCode?: StringFilter<"BusinessUnitServicePair"> | string
    serviceOfficeId?: StringFilter<"BusinessUnitServicePair"> | string
    serviceTeamCode?: StringFilter<"BusinessUnitServicePair"> | string
    businessUnit?: XOR<BusinessUnitScalarRelationFilter, BusinessUnitWhereInput>
    serviceChannel?: XOR<ServiceChannelScalarRelationFilter, ServiceChannelWhereInput>
    serviceOffice?: XOR<ServiceOfficeScalarRelationFilter, ServiceOfficeWhereInput>
    serviceTeam?: XOR<ServiceTeamScalarRelationFilter, ServiceTeamWhereInput>
  }

  export type BusinessUnitServicePairOrderByWithRelationInput = {
    id?: SortOrder
    businessUnitCode?: SortOrder
    serviceChannelCode?: SortOrder
    serviceOfficeId?: SortOrder
    serviceTeamCode?: SortOrder
    businessUnit?: BusinessUnitOrderByWithRelationInput
    serviceChannel?: ServiceChannelOrderByWithRelationInput
    serviceOffice?: ServiceOfficeOrderByWithRelationInput
    serviceTeam?: ServiceTeamOrderByWithRelationInput
  }

  export type BusinessUnitServicePairWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    businessUnitCode_serviceChannelCode_serviceOfficeId_serviceTeamCode?: BusinessUnitServicePairBusinessUnitCodeServiceChannelCodeServiceOfficeIdServiceTeamCodeCompoundUniqueInput
    AND?: BusinessUnitServicePairWhereInput | BusinessUnitServicePairWhereInput[]
    OR?: BusinessUnitServicePairWhereInput[]
    NOT?: BusinessUnitServicePairWhereInput | BusinessUnitServicePairWhereInput[]
    businessUnitCode?: StringFilter<"BusinessUnitServicePair"> | string
    serviceChannelCode?: StringFilter<"BusinessUnitServicePair"> | string
    serviceOfficeId?: StringFilter<"BusinessUnitServicePair"> | string
    serviceTeamCode?: StringFilter<"BusinessUnitServicePair"> | string
    businessUnit?: XOR<BusinessUnitScalarRelationFilter, BusinessUnitWhereInput>
    serviceChannel?: XOR<ServiceChannelScalarRelationFilter, ServiceChannelWhereInput>
    serviceOffice?: XOR<ServiceOfficeScalarRelationFilter, ServiceOfficeWhereInput>
    serviceTeam?: XOR<ServiceTeamScalarRelationFilter, ServiceTeamWhereInput>
  }, "id" | "businessUnitCode_serviceChannelCode_serviceOfficeId_serviceTeamCode">

  export type BusinessUnitServicePairOrderByWithAggregationInput = {
    id?: SortOrder
    businessUnitCode?: SortOrder
    serviceChannelCode?: SortOrder
    serviceOfficeId?: SortOrder
    serviceTeamCode?: SortOrder
    _count?: BusinessUnitServicePairCountOrderByAggregateInput
    _max?: BusinessUnitServicePairMaxOrderByAggregateInput
    _min?: BusinessUnitServicePairMinOrderByAggregateInput
  }

  export type BusinessUnitServicePairScalarWhereWithAggregatesInput = {
    AND?: BusinessUnitServicePairScalarWhereWithAggregatesInput | BusinessUnitServicePairScalarWhereWithAggregatesInput[]
    OR?: BusinessUnitServicePairScalarWhereWithAggregatesInput[]
    NOT?: BusinessUnitServicePairScalarWhereWithAggregatesInput | BusinessUnitServicePairScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BusinessUnitServicePair"> | string
    businessUnitCode?: StringWithAggregatesFilter<"BusinessUnitServicePair"> | string
    serviceChannelCode?: StringWithAggregatesFilter<"BusinessUnitServicePair"> | string
    serviceOfficeId?: StringWithAggregatesFilter<"BusinessUnitServicePair"> | string
    serviceTeamCode?: StringWithAggregatesFilter<"BusinessUnitServicePair"> | string
  }

  export type SalesTeamManagerWhereInput = {
    AND?: SalesTeamManagerWhereInput | SalesTeamManagerWhereInput[]
    OR?: SalesTeamManagerWhereInput[]
    NOT?: SalesTeamManagerWhereInput | SalesTeamManagerWhereInput[]
    id?: StringFilter<"SalesTeamManager"> | string
    userId?: StringFilter<"SalesTeamManager"> | string
    validFrom?: DateTimeFilter<"SalesTeamManager"> | Date | string
    validTo?: DateTimeNullableFilter<"SalesTeamManager"> | Date | string | null
    primary?: BoolFilter<"SalesTeamManager"> | boolean
    createdAt?: DateTimeFilter<"SalesTeamManager"> | Date | string
    updatedAt?: DateTimeFilter<"SalesTeamManager"> | Date | string
  }

  export type SalesTeamManagerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrderInput | SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesTeamManagerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SalesTeamManagerWhereInput | SalesTeamManagerWhereInput[]
    OR?: SalesTeamManagerWhereInput[]
    NOT?: SalesTeamManagerWhereInput | SalesTeamManagerWhereInput[]
    userId?: StringFilter<"SalesTeamManager"> | string
    validFrom?: DateTimeFilter<"SalesTeamManager"> | Date | string
    validTo?: DateTimeNullableFilter<"SalesTeamManager"> | Date | string | null
    primary?: BoolFilter<"SalesTeamManager"> | boolean
    createdAt?: DateTimeFilter<"SalesTeamManager"> | Date | string
    updatedAt?: DateTimeFilter<"SalesTeamManager"> | Date | string
  }, "id">

  export type SalesTeamManagerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrderInput | SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesTeamManagerCountOrderByAggregateInput
    _max?: SalesTeamManagerMaxOrderByAggregateInput
    _min?: SalesTeamManagerMinOrderByAggregateInput
  }

  export type SalesTeamManagerScalarWhereWithAggregatesInput = {
    AND?: SalesTeamManagerScalarWhereWithAggregatesInput | SalesTeamManagerScalarWhereWithAggregatesInput[]
    OR?: SalesTeamManagerScalarWhereWithAggregatesInput[]
    NOT?: SalesTeamManagerScalarWhereWithAggregatesInput | SalesTeamManagerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalesTeamManager"> | string
    userId?: StringWithAggregatesFilter<"SalesTeamManager"> | string
    validFrom?: DateTimeWithAggregatesFilter<"SalesTeamManager"> | Date | string
    validTo?: DateTimeNullableWithAggregatesFilter<"SalesTeamManager"> | Date | string | null
    primary?: BoolWithAggregatesFilter<"SalesTeamManager"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SalesTeamManager"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesTeamManager"> | Date | string
  }

  export type MarketingTeamManagerWhereInput = {
    AND?: MarketingTeamManagerWhereInput | MarketingTeamManagerWhereInput[]
    OR?: MarketingTeamManagerWhereInput[]
    NOT?: MarketingTeamManagerWhereInput | MarketingTeamManagerWhereInput[]
    id?: StringFilter<"MarketingTeamManager"> | string
    userId?: StringFilter<"MarketingTeamManager"> | string
    validFrom?: DateTimeFilter<"MarketingTeamManager"> | Date | string
    validTo?: DateTimeNullableFilter<"MarketingTeamManager"> | Date | string | null
    primary?: BoolFilter<"MarketingTeamManager"> | boolean
    createdAt?: DateTimeFilter<"MarketingTeamManager"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingTeamManager"> | Date | string
  }

  export type MarketingTeamManagerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrderInput | SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingTeamManagerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketingTeamManagerWhereInput | MarketingTeamManagerWhereInput[]
    OR?: MarketingTeamManagerWhereInput[]
    NOT?: MarketingTeamManagerWhereInput | MarketingTeamManagerWhereInput[]
    userId?: StringFilter<"MarketingTeamManager"> | string
    validFrom?: DateTimeFilter<"MarketingTeamManager"> | Date | string
    validTo?: DateTimeNullableFilter<"MarketingTeamManager"> | Date | string | null
    primary?: BoolFilter<"MarketingTeamManager"> | boolean
    createdAt?: DateTimeFilter<"MarketingTeamManager"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingTeamManager"> | Date | string
  }, "id">

  export type MarketingTeamManagerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrderInput | SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarketingTeamManagerCountOrderByAggregateInput
    _max?: MarketingTeamManagerMaxOrderByAggregateInput
    _min?: MarketingTeamManagerMinOrderByAggregateInput
  }

  export type MarketingTeamManagerScalarWhereWithAggregatesInput = {
    AND?: MarketingTeamManagerScalarWhereWithAggregatesInput | MarketingTeamManagerScalarWhereWithAggregatesInput[]
    OR?: MarketingTeamManagerScalarWhereWithAggregatesInput[]
    NOT?: MarketingTeamManagerScalarWhereWithAggregatesInput | MarketingTeamManagerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketingTeamManager"> | string
    userId?: StringWithAggregatesFilter<"MarketingTeamManager"> | string
    validFrom?: DateTimeWithAggregatesFilter<"MarketingTeamManager"> | Date | string
    validTo?: DateTimeNullableWithAggregatesFilter<"MarketingTeamManager"> | Date | string | null
    primary?: BoolWithAggregatesFilter<"MarketingTeamManager"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MarketingTeamManager"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketingTeamManager"> | Date | string
  }

  export type ServiceTeamManagerWhereInput = {
    AND?: ServiceTeamManagerWhereInput | ServiceTeamManagerWhereInput[]
    OR?: ServiceTeamManagerWhereInput[]
    NOT?: ServiceTeamManagerWhereInput | ServiceTeamManagerWhereInput[]
    id?: StringFilter<"ServiceTeamManager"> | string
    userId?: StringFilter<"ServiceTeamManager"> | string
    validFrom?: DateTimeFilter<"ServiceTeamManager"> | Date | string
    validTo?: DateTimeNullableFilter<"ServiceTeamManager"> | Date | string | null
    primary?: BoolFilter<"ServiceTeamManager"> | boolean
    createdAt?: DateTimeFilter<"ServiceTeamManager"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceTeamManager"> | Date | string
  }

  export type ServiceTeamManagerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrderInput | SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTeamManagerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceTeamManagerWhereInput | ServiceTeamManagerWhereInput[]
    OR?: ServiceTeamManagerWhereInput[]
    NOT?: ServiceTeamManagerWhereInput | ServiceTeamManagerWhereInput[]
    userId?: StringFilter<"ServiceTeamManager"> | string
    validFrom?: DateTimeFilter<"ServiceTeamManager"> | Date | string
    validTo?: DateTimeNullableFilter<"ServiceTeamManager"> | Date | string | null
    primary?: BoolFilter<"ServiceTeamManager"> | boolean
    createdAt?: DateTimeFilter<"ServiceTeamManager"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceTeamManager"> | Date | string
  }, "id">

  export type ServiceTeamManagerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrderInput | SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceTeamManagerCountOrderByAggregateInput
    _max?: ServiceTeamManagerMaxOrderByAggregateInput
    _min?: ServiceTeamManagerMinOrderByAggregateInput
  }

  export type ServiceTeamManagerScalarWhereWithAggregatesInput = {
    AND?: ServiceTeamManagerScalarWhereWithAggregatesInput | ServiceTeamManagerScalarWhereWithAggregatesInput[]
    OR?: ServiceTeamManagerScalarWhereWithAggregatesInput[]
    NOT?: ServiceTeamManagerScalarWhereWithAggregatesInput | ServiceTeamManagerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceTeamManager"> | string
    userId?: StringWithAggregatesFilter<"ServiceTeamManager"> | string
    validFrom?: DateTimeWithAggregatesFilter<"ServiceTeamManager"> | Date | string
    validTo?: DateTimeNullableWithAggregatesFilter<"ServiceTeamManager"> | Date | string | null
    primary?: BoolWithAggregatesFilter<"ServiceTeamManager"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ServiceTeamManager"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceTeamManager"> | Date | string
  }

  export type SalesTeamEmployeeWhereInput = {
    AND?: SalesTeamEmployeeWhereInput | SalesTeamEmployeeWhereInput[]
    OR?: SalesTeamEmployeeWhereInput[]
    NOT?: SalesTeamEmployeeWhereInput | SalesTeamEmployeeWhereInput[]
    id?: StringFilter<"SalesTeamEmployee"> | string
    userId?: StringFilter<"SalesTeamEmployee"> | string
    validFrom?: DateTimeFilter<"SalesTeamEmployee"> | Date | string
    validTo?: DateTimeNullableFilter<"SalesTeamEmployee"> | Date | string | null
    primary?: BoolFilter<"SalesTeamEmployee"> | boolean
    job?: StringNullableFilter<"SalesTeamEmployee"> | string | null
    createdAt?: DateTimeFilter<"SalesTeamEmployee"> | Date | string
    updatedAt?: DateTimeFilter<"SalesTeamEmployee"> | Date | string
  }

  export type SalesTeamEmployeeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrderInput | SortOrder
    primary?: SortOrder
    job?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesTeamEmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SalesTeamEmployeeWhereInput | SalesTeamEmployeeWhereInput[]
    OR?: SalesTeamEmployeeWhereInput[]
    NOT?: SalesTeamEmployeeWhereInput | SalesTeamEmployeeWhereInput[]
    userId?: StringFilter<"SalesTeamEmployee"> | string
    validFrom?: DateTimeFilter<"SalesTeamEmployee"> | Date | string
    validTo?: DateTimeNullableFilter<"SalesTeamEmployee"> | Date | string | null
    primary?: BoolFilter<"SalesTeamEmployee"> | boolean
    job?: StringNullableFilter<"SalesTeamEmployee"> | string | null
    createdAt?: DateTimeFilter<"SalesTeamEmployee"> | Date | string
    updatedAt?: DateTimeFilter<"SalesTeamEmployee"> | Date | string
  }, "id">

  export type SalesTeamEmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrderInput | SortOrder
    primary?: SortOrder
    job?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalesTeamEmployeeCountOrderByAggregateInput
    _max?: SalesTeamEmployeeMaxOrderByAggregateInput
    _min?: SalesTeamEmployeeMinOrderByAggregateInput
  }

  export type SalesTeamEmployeeScalarWhereWithAggregatesInput = {
    AND?: SalesTeamEmployeeScalarWhereWithAggregatesInput | SalesTeamEmployeeScalarWhereWithAggregatesInput[]
    OR?: SalesTeamEmployeeScalarWhereWithAggregatesInput[]
    NOT?: SalesTeamEmployeeScalarWhereWithAggregatesInput | SalesTeamEmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalesTeamEmployee"> | string
    userId?: StringWithAggregatesFilter<"SalesTeamEmployee"> | string
    validFrom?: DateTimeWithAggregatesFilter<"SalesTeamEmployee"> | Date | string
    validTo?: DateTimeNullableWithAggregatesFilter<"SalesTeamEmployee"> | Date | string | null
    primary?: BoolWithAggregatesFilter<"SalesTeamEmployee"> | boolean
    job?: StringNullableWithAggregatesFilter<"SalesTeamEmployee"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SalesTeamEmployee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesTeamEmployee"> | Date | string
  }

  export type MarketingTeamEmployeeWhereInput = {
    AND?: MarketingTeamEmployeeWhereInput | MarketingTeamEmployeeWhereInput[]
    OR?: MarketingTeamEmployeeWhereInput[]
    NOT?: MarketingTeamEmployeeWhereInput | MarketingTeamEmployeeWhereInput[]
    id?: StringFilter<"MarketingTeamEmployee"> | string
    userId?: StringFilter<"MarketingTeamEmployee"> | string
    validFrom?: DateTimeFilter<"MarketingTeamEmployee"> | Date | string
    validTo?: DateTimeNullableFilter<"MarketingTeamEmployee"> | Date | string | null
    primary?: BoolFilter<"MarketingTeamEmployee"> | boolean
    job?: StringNullableFilter<"MarketingTeamEmployee"> | string | null
    createdAt?: DateTimeFilter<"MarketingTeamEmployee"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingTeamEmployee"> | Date | string
  }

  export type MarketingTeamEmployeeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrderInput | SortOrder
    primary?: SortOrder
    job?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingTeamEmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MarketingTeamEmployeeWhereInput | MarketingTeamEmployeeWhereInput[]
    OR?: MarketingTeamEmployeeWhereInput[]
    NOT?: MarketingTeamEmployeeWhereInput | MarketingTeamEmployeeWhereInput[]
    userId?: StringFilter<"MarketingTeamEmployee"> | string
    validFrom?: DateTimeFilter<"MarketingTeamEmployee"> | Date | string
    validTo?: DateTimeNullableFilter<"MarketingTeamEmployee"> | Date | string | null
    primary?: BoolFilter<"MarketingTeamEmployee"> | boolean
    job?: StringNullableFilter<"MarketingTeamEmployee"> | string | null
    createdAt?: DateTimeFilter<"MarketingTeamEmployee"> | Date | string
    updatedAt?: DateTimeFilter<"MarketingTeamEmployee"> | Date | string
  }, "id">

  export type MarketingTeamEmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrderInput | SortOrder
    primary?: SortOrder
    job?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MarketingTeamEmployeeCountOrderByAggregateInput
    _max?: MarketingTeamEmployeeMaxOrderByAggregateInput
    _min?: MarketingTeamEmployeeMinOrderByAggregateInput
  }

  export type MarketingTeamEmployeeScalarWhereWithAggregatesInput = {
    AND?: MarketingTeamEmployeeScalarWhereWithAggregatesInput | MarketingTeamEmployeeScalarWhereWithAggregatesInput[]
    OR?: MarketingTeamEmployeeScalarWhereWithAggregatesInput[]
    NOT?: MarketingTeamEmployeeScalarWhereWithAggregatesInput | MarketingTeamEmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MarketingTeamEmployee"> | string
    userId?: StringWithAggregatesFilter<"MarketingTeamEmployee"> | string
    validFrom?: DateTimeWithAggregatesFilter<"MarketingTeamEmployee"> | Date | string
    validTo?: DateTimeNullableWithAggregatesFilter<"MarketingTeamEmployee"> | Date | string | null
    primary?: BoolWithAggregatesFilter<"MarketingTeamEmployee"> | boolean
    job?: StringNullableWithAggregatesFilter<"MarketingTeamEmployee"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MarketingTeamEmployee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MarketingTeamEmployee"> | Date | string
  }

  export type ServiceTeamEmployeeWhereInput = {
    AND?: ServiceTeamEmployeeWhereInput | ServiceTeamEmployeeWhereInput[]
    OR?: ServiceTeamEmployeeWhereInput[]
    NOT?: ServiceTeamEmployeeWhereInput | ServiceTeamEmployeeWhereInput[]
    id?: StringFilter<"ServiceTeamEmployee"> | string
    userId?: StringFilter<"ServiceTeamEmployee"> | string
    validFrom?: DateTimeFilter<"ServiceTeamEmployee"> | Date | string
    validTo?: DateTimeNullableFilter<"ServiceTeamEmployee"> | Date | string | null
    primary?: BoolFilter<"ServiceTeamEmployee"> | boolean
    job?: StringNullableFilter<"ServiceTeamEmployee"> | string | null
    createdAt?: DateTimeFilter<"ServiceTeamEmployee"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceTeamEmployee"> | Date | string
  }

  export type ServiceTeamEmployeeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrderInput | SortOrder
    primary?: SortOrder
    job?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTeamEmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceTeamEmployeeWhereInput | ServiceTeamEmployeeWhereInput[]
    OR?: ServiceTeamEmployeeWhereInput[]
    NOT?: ServiceTeamEmployeeWhereInput | ServiceTeamEmployeeWhereInput[]
    userId?: StringFilter<"ServiceTeamEmployee"> | string
    validFrom?: DateTimeFilter<"ServiceTeamEmployee"> | Date | string
    validTo?: DateTimeNullableFilter<"ServiceTeamEmployee"> | Date | string | null
    primary?: BoolFilter<"ServiceTeamEmployee"> | boolean
    job?: StringNullableFilter<"ServiceTeamEmployee"> | string | null
    createdAt?: DateTimeFilter<"ServiceTeamEmployee"> | Date | string
    updatedAt?: DateTimeFilter<"ServiceTeamEmployee"> | Date | string
  }, "id">

  export type ServiceTeamEmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrderInput | SortOrder
    primary?: SortOrder
    job?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceTeamEmployeeCountOrderByAggregateInput
    _max?: ServiceTeamEmployeeMaxOrderByAggregateInput
    _min?: ServiceTeamEmployeeMinOrderByAggregateInput
  }

  export type ServiceTeamEmployeeScalarWhereWithAggregatesInput = {
    AND?: ServiceTeamEmployeeScalarWhereWithAggregatesInput | ServiceTeamEmployeeScalarWhereWithAggregatesInput[]
    OR?: ServiceTeamEmployeeScalarWhereWithAggregatesInput[]
    NOT?: ServiceTeamEmployeeScalarWhereWithAggregatesInput | ServiceTeamEmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceTeamEmployee"> | string
    userId?: StringWithAggregatesFilter<"ServiceTeamEmployee"> | string
    validFrom?: DateTimeWithAggregatesFilter<"ServiceTeamEmployee"> | Date | string
    validTo?: DateTimeNullableWithAggregatesFilter<"ServiceTeamEmployee"> | Date | string | null
    primary?: BoolWithAggregatesFilter<"ServiceTeamEmployee"> | boolean
    job?: StringNullableWithAggregatesFilter<"ServiceTeamEmployee"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceTeamEmployee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServiceTeamEmployee"> | Date | string
  }

  export type BusinessEntityCreateInput = {
    businessEntityCode: string
    businessEntityName: string
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    entityUnitPairs?: BusinessEntityUnitPairCreateNestedManyWithoutBusinessEntityInput
  }

  export type BusinessEntityUncheckedCreateInput = {
    id?: number
    businessEntityCode: string
    businessEntityName: string
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    entityUnitPairs?: BusinessEntityUnitPairUncheckedCreateNestedManyWithoutBusinessEntityInput
  }

  export type BusinessEntityUpdateInput = {
    businessEntityCode?: StringFieldUpdateOperationsInput | string
    businessEntityName?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityUnitPairs?: BusinessEntityUnitPairUpdateManyWithoutBusinessEntityNestedInput
  }

  export type BusinessEntityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessEntityCode?: StringFieldUpdateOperationsInput | string
    businessEntityName?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityUnitPairs?: BusinessEntityUnitPairUncheckedUpdateManyWithoutBusinessEntityNestedInput
  }

  export type BusinessEntityCreateManyInput = {
    id?: number
    businessEntityCode: string
    businessEntityName: string
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessEntityUpdateManyMutationInput = {
    businessEntityCode?: StringFieldUpdateOperationsInput | string
    businessEntityName?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessEntityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessEntityCode?: StringFieldUpdateOperationsInput | string
    businessEntityName?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUnitCreateInput = {
    businessUnitCode: string
    businessUnitDesc: string
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    entityUnitPairs?: BusinessEntityUnitPairCreateNestedManyWithoutBusinessUnitInput
    businessUnitSalesPairs?: BusinessUnitSalesPairCreateNestedManyWithoutBusinessUnitInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairCreateNestedManyWithoutBusinessUnitInput
    businessUnitServicePairs?: BusinessUnitServicePairCreateNestedManyWithoutBusinessUnitInput
  }

  export type BusinessUnitUncheckedCreateInput = {
    id?: number
    businessUnitCode: string
    businessUnitDesc: string
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    entityUnitPairs?: BusinessEntityUnitPairUncheckedCreateNestedManyWithoutBusinessUnitInput
    businessUnitSalesPairs?: BusinessUnitSalesPairUncheckedCreateNestedManyWithoutBusinessUnitInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUncheckedCreateNestedManyWithoutBusinessUnitInput
    businessUnitServicePairs?: BusinessUnitServicePairUncheckedCreateNestedManyWithoutBusinessUnitInput
  }

  export type BusinessUnitUpdateInput = {
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    businessUnitDesc?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityUnitPairs?: BusinessEntityUnitPairUpdateManyWithoutBusinessUnitNestedInput
    businessUnitSalesPairs?: BusinessUnitSalesPairUpdateManyWithoutBusinessUnitNestedInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUpdateManyWithoutBusinessUnitNestedInput
    businessUnitServicePairs?: BusinessUnitServicePairUpdateManyWithoutBusinessUnitNestedInput
  }

  export type BusinessUnitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    businessUnitDesc?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityUnitPairs?: BusinessEntityUnitPairUncheckedUpdateManyWithoutBusinessUnitNestedInput
    businessUnitSalesPairs?: BusinessUnitSalesPairUncheckedUpdateManyWithoutBusinessUnitNestedInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUncheckedUpdateManyWithoutBusinessUnitNestedInput
    businessUnitServicePairs?: BusinessUnitServicePairUncheckedUpdateManyWithoutBusinessUnitNestedInput
  }

  export type BusinessUnitCreateManyInput = {
    id?: number
    businessUnitCode: string
    businessUnitDesc: string
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessUnitUpdateManyMutationInput = {
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    businessUnitDesc?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUnitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    businessUnitDesc?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessEntityUnitPairCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    businessEntity: BusinessEntityCreateNestedOneWithoutEntityUnitPairsInput
    businessUnit: BusinessUnitCreateNestedOneWithoutEntityUnitPairsInput
  }

  export type BusinessEntityUnitPairUncheckedCreateInput = {
    id?: number
    businessEntityCode: string
    businessUnitCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessEntityUnitPairUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessEntity?: BusinessEntityUpdateOneRequiredWithoutEntityUnitPairsNestedInput
    businessUnit?: BusinessUnitUpdateOneRequiredWithoutEntityUnitPairsNestedInput
  }

  export type BusinessEntityUnitPairUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessEntityCode?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessEntityUnitPairCreateManyInput = {
    id?: number
    businessEntityCode: string
    businessUnitCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessEntityUnitPairUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessEntityUnitPairUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessEntityCode?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesChannelCreateInput = {
    salesChannelCode: string
    salesChannelName: string
    salesChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    channelOfficePairs?: SalesChannelOfficeTeamPairCreateNestedManyWithoutSalesChannelInput
    businessUnitSalesPairs?: BusinessUnitSalesPairCreateNestedManyWithoutSalesChannelInput
  }

  export type SalesChannelUncheckedCreateInput = {
    id?: number
    salesChannelCode: string
    salesChannelName: string
    salesChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    channelOfficePairs?: SalesChannelOfficeTeamPairUncheckedCreateNestedManyWithoutSalesChannelInput
    businessUnitSalesPairs?: BusinessUnitSalesPairUncheckedCreateNestedManyWithoutSalesChannelInput
  }

  export type SalesChannelUpdateInput = {
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesChannelName?: StringFieldUpdateOperationsInput | string
    salesChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channelOfficePairs?: SalesChannelOfficeTeamPairUpdateManyWithoutSalesChannelNestedInput
    businessUnitSalesPairs?: BusinessUnitSalesPairUpdateManyWithoutSalesChannelNestedInput
  }

  export type SalesChannelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesChannelName?: StringFieldUpdateOperationsInput | string
    salesChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channelOfficePairs?: SalesChannelOfficeTeamPairUncheckedUpdateManyWithoutSalesChannelNestedInput
    businessUnitSalesPairs?: BusinessUnitSalesPairUncheckedUpdateManyWithoutSalesChannelNestedInput
  }

  export type SalesChannelCreateManyInput = {
    id?: number
    salesChannelCode: string
    salesChannelName: string
    salesChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesChannelUpdateManyMutationInput = {
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesChannelName?: StringFieldUpdateOperationsInput | string
    salesChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesChannelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesChannelName?: StringFieldUpdateOperationsInput | string
    salesChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOfficeCreateInput = {
    salesOfficeId: string
    organizationName: string
    salesOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: SalesChannelOfficeTeamPairCreateNestedManyWithoutSalesOfficeInput
    businessUnitSalesPairs?: BusinessUnitSalesPairCreateNestedManyWithoutSalesOfficeInput
  }

  export type SalesOfficeUncheckedCreateInput = {
    id?: number
    salesOfficeId: string
    organizationName: string
    salesOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: SalesChannelOfficeTeamPairUncheckedCreateNestedManyWithoutSalesOfficeInput
    businessUnitSalesPairs?: BusinessUnitSalesPairUncheckedCreateNestedManyWithoutSalesOfficeInput
  }

  export type SalesOfficeUpdateInput = {
    salesOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    salesOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: SalesChannelOfficeTeamPairUpdateManyWithoutSalesOfficeNestedInput
    businessUnitSalesPairs?: BusinessUnitSalesPairUpdateManyWithoutSalesOfficeNestedInput
  }

  export type SalesOfficeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    salesOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: SalesChannelOfficeTeamPairUncheckedUpdateManyWithoutSalesOfficeNestedInput
    businessUnitSalesPairs?: BusinessUnitSalesPairUncheckedUpdateManyWithoutSalesOfficeNestedInput
  }

  export type SalesOfficeCreateManyInput = {
    id?: number
    salesOfficeId: string
    organizationName: string
    salesOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesOfficeUpdateManyMutationInput = {
    salesOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    salesOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesOfficeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    salesOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamCreateInput = {
    salesTeamCode: string
    salesTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: SalesChannelOfficeTeamPairCreateNestedManyWithoutSalesTeamInput
    businessUnitSalesPairs?: BusinessUnitSalesPairCreateNestedManyWithoutSalesTeamInput
  }

  export type SalesTeamUncheckedCreateInput = {
    id?: number
    salesTeamCode: string
    salesTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: SalesChannelOfficeTeamPairUncheckedCreateNestedManyWithoutSalesTeamInput
    businessUnitSalesPairs?: BusinessUnitSalesPairUncheckedCreateNestedManyWithoutSalesTeamInput
  }

  export type SalesTeamUpdateInput = {
    salesTeamCode?: StringFieldUpdateOperationsInput | string
    salesTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: SalesChannelOfficeTeamPairUpdateManyWithoutSalesTeamNestedInput
    businessUnitSalesPairs?: BusinessUnitSalesPairUpdateManyWithoutSalesTeamNestedInput
  }

  export type SalesTeamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesTeamCode?: StringFieldUpdateOperationsInput | string
    salesTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: SalesChannelOfficeTeamPairUncheckedUpdateManyWithoutSalesTeamNestedInput
    businessUnitSalesPairs?: BusinessUnitSalesPairUncheckedUpdateManyWithoutSalesTeamNestedInput
  }

  export type SalesTeamCreateManyInput = {
    id?: number
    salesTeamCode: string
    salesTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamUpdateManyMutationInput = {
    salesTeamCode?: StringFieldUpdateOperationsInput | string
    salesTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesTeamCode?: StringFieldUpdateOperationsInput | string
    salesTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesChannelOfficeTeamPairCreateInput = {
    salesChannel: SalesChannelCreateNestedOneWithoutChannelOfficePairsInput
    salesOffice: SalesOfficeCreateNestedOneWithoutOfficeTeamPairsInput
    salesTeam: SalesTeamCreateNestedOneWithoutOfficeTeamPairsInput
  }

  export type SalesChannelOfficeTeamPairUncheckedCreateInput = {
    id?: number
    salesChannelCode: string
    salesOfficeId: string
    salesTeamCode: string
  }

  export type SalesChannelOfficeTeamPairUpdateInput = {
    salesChannel?: SalesChannelUpdateOneRequiredWithoutChannelOfficePairsNestedInput
    salesOffice?: SalesOfficeUpdateOneRequiredWithoutOfficeTeamPairsNestedInput
    salesTeam?: SalesTeamUpdateOneRequiredWithoutOfficeTeamPairsNestedInput
  }

  export type SalesChannelOfficeTeamPairUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesOfficeId?: StringFieldUpdateOperationsInput | string
    salesTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type SalesChannelOfficeTeamPairCreateManyInput = {
    id?: number
    salesChannelCode: string
    salesOfficeId: string
    salesTeamCode: string
  }

  export type SalesChannelOfficeTeamPairUpdateManyMutationInput = {

  }

  export type SalesChannelOfficeTeamPairUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesOfficeId?: StringFieldUpdateOperationsInput | string
    salesTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type MarketingChannelCreateInput = {
    marketingChannelCode: string
    marketingChannelName: string
    marketingChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    channelOfficePairs?: MarketingChannelOfficeTeamPairCreateNestedManyWithoutMarketingChannelInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairCreateNestedManyWithoutMarketingChannelInput
  }

  export type MarketingChannelUncheckedCreateInput = {
    id?: number
    marketingChannelCode: string
    marketingChannelName: string
    marketingChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    channelOfficePairs?: MarketingChannelOfficeTeamPairUncheckedCreateNestedManyWithoutMarketingChannelInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUncheckedCreateNestedManyWithoutMarketingChannelInput
  }

  export type MarketingChannelUpdateInput = {
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingChannelName?: StringFieldUpdateOperationsInput | string
    marketingChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channelOfficePairs?: MarketingChannelOfficeTeamPairUpdateManyWithoutMarketingChannelNestedInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUpdateManyWithoutMarketingChannelNestedInput
  }

  export type MarketingChannelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingChannelName?: StringFieldUpdateOperationsInput | string
    marketingChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channelOfficePairs?: MarketingChannelOfficeTeamPairUncheckedUpdateManyWithoutMarketingChannelNestedInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUncheckedUpdateManyWithoutMarketingChannelNestedInput
  }

  export type MarketingChannelCreateManyInput = {
    id?: number
    marketingChannelCode: string
    marketingChannelName: string
    marketingChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingChannelUpdateManyMutationInput = {
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingChannelName?: StringFieldUpdateOperationsInput | string
    marketingChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingChannelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingChannelName?: StringFieldUpdateOperationsInput | string
    marketingChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingOfficeCreateInput = {
    marketingOfficeId: string
    organizationName: string
    marketingOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: MarketingChannelOfficeTeamPairCreateNestedManyWithoutMarketingOfficeInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairCreateNestedManyWithoutMarketingOfficeInput
  }

  export type MarketingOfficeUncheckedCreateInput = {
    id?: number
    marketingOfficeId: string
    organizationName: string
    marketingOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: MarketingChannelOfficeTeamPairUncheckedCreateNestedManyWithoutMarketingOfficeInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUncheckedCreateNestedManyWithoutMarketingOfficeInput
  }

  export type MarketingOfficeUpdateInput = {
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    marketingOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: MarketingChannelOfficeTeamPairUpdateManyWithoutMarketingOfficeNestedInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUpdateManyWithoutMarketingOfficeNestedInput
  }

  export type MarketingOfficeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    marketingOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: MarketingChannelOfficeTeamPairUncheckedUpdateManyWithoutMarketingOfficeNestedInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUncheckedUpdateManyWithoutMarketingOfficeNestedInput
  }

  export type MarketingOfficeCreateManyInput = {
    id?: number
    marketingOfficeId: string
    organizationName: string
    marketingOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingOfficeUpdateManyMutationInput = {
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    marketingOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingOfficeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    marketingOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingTeamCreateInput = {
    marketingTeamCode: string
    marketingTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: MarketingChannelOfficeTeamPairCreateNestedManyWithoutMarketingTeamInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairCreateNestedManyWithoutMarketingTeamInput
  }

  export type MarketingTeamUncheckedCreateInput = {
    id?: number
    marketingTeamCode: string
    marketingTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: MarketingChannelOfficeTeamPairUncheckedCreateNestedManyWithoutMarketingTeamInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUncheckedCreateNestedManyWithoutMarketingTeamInput
  }

  export type MarketingTeamUpdateInput = {
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
    marketingTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: MarketingChannelOfficeTeamPairUpdateManyWithoutMarketingTeamNestedInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUpdateManyWithoutMarketingTeamNestedInput
  }

  export type MarketingTeamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
    marketingTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: MarketingChannelOfficeTeamPairUncheckedUpdateManyWithoutMarketingTeamNestedInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUncheckedUpdateManyWithoutMarketingTeamNestedInput
  }

  export type MarketingTeamCreateManyInput = {
    id?: number
    marketingTeamCode: string
    marketingTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingTeamUpdateManyMutationInput = {
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
    marketingTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingTeamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
    marketingTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingChannelOfficeTeamPairCreateInput = {
    marketingChannel: MarketingChannelCreateNestedOneWithoutChannelOfficePairsInput
    marketingOffice: MarketingOfficeCreateNestedOneWithoutOfficeTeamPairsInput
    marketingTeam: MarketingTeamCreateNestedOneWithoutOfficeTeamPairsInput
  }

  export type MarketingChannelOfficeTeamPairUncheckedCreateInput = {
    id?: number
    marketingChannelCode: string
    marketingOfficeId: string
    marketingTeamCode: string
  }

  export type MarketingChannelOfficeTeamPairUpdateInput = {
    marketingChannel?: MarketingChannelUpdateOneRequiredWithoutChannelOfficePairsNestedInput
    marketingOffice?: MarketingOfficeUpdateOneRequiredWithoutOfficeTeamPairsNestedInput
    marketingTeam?: MarketingTeamUpdateOneRequiredWithoutOfficeTeamPairsNestedInput
  }

  export type MarketingChannelOfficeTeamPairUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type MarketingChannelOfficeTeamPairCreateManyInput = {
    id?: number
    marketingChannelCode: string
    marketingOfficeId: string
    marketingTeamCode: string
  }

  export type MarketingChannelOfficeTeamPairUpdateManyMutationInput = {

  }

  export type MarketingChannelOfficeTeamPairUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceChannelCreateInput = {
    serviceChannelCode: string
    serviceChannelName: string
    serviceChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    channelOfficePairs?: ServiceChannelOfficeTeamPairCreateNestedManyWithoutServiceChannelInput
    businessUnitServicePairs?: BusinessUnitServicePairCreateNestedManyWithoutServiceChannelInput
  }

  export type ServiceChannelUncheckedCreateInput = {
    id?: number
    serviceChannelCode: string
    serviceChannelName: string
    serviceChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    channelOfficePairs?: ServiceChannelOfficeTeamPairUncheckedCreateNestedManyWithoutServiceChannelInput
    businessUnitServicePairs?: BusinessUnitServicePairUncheckedCreateNestedManyWithoutServiceChannelInput
  }

  export type ServiceChannelUpdateInput = {
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceChannelName?: StringFieldUpdateOperationsInput | string
    serviceChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channelOfficePairs?: ServiceChannelOfficeTeamPairUpdateManyWithoutServiceChannelNestedInput
    businessUnitServicePairs?: BusinessUnitServicePairUpdateManyWithoutServiceChannelNestedInput
  }

  export type ServiceChannelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceChannelName?: StringFieldUpdateOperationsInput | string
    serviceChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channelOfficePairs?: ServiceChannelOfficeTeamPairUncheckedUpdateManyWithoutServiceChannelNestedInput
    businessUnitServicePairs?: BusinessUnitServicePairUncheckedUpdateManyWithoutServiceChannelNestedInput
  }

  export type ServiceChannelCreateManyInput = {
    id?: number
    serviceChannelCode: string
    serviceChannelName: string
    serviceChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceChannelUpdateManyMutationInput = {
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceChannelName?: StringFieldUpdateOperationsInput | string
    serviceChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceChannelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceChannelName?: StringFieldUpdateOperationsInput | string
    serviceChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceOfficeCreateInput = {
    serviceOfficeId: string
    organizationName: string
    serviceOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: ServiceChannelOfficeTeamPairCreateNestedManyWithoutServiceOfficeInput
    businessUnitServicePairs?: BusinessUnitServicePairCreateNestedManyWithoutServiceOfficeInput
  }

  export type ServiceOfficeUncheckedCreateInput = {
    id?: number
    serviceOfficeId: string
    organizationName: string
    serviceOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: ServiceChannelOfficeTeamPairUncheckedCreateNestedManyWithoutServiceOfficeInput
    businessUnitServicePairs?: BusinessUnitServicePairUncheckedCreateNestedManyWithoutServiceOfficeInput
  }

  export type ServiceOfficeUpdateInput = {
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    serviceOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: ServiceChannelOfficeTeamPairUpdateManyWithoutServiceOfficeNestedInput
    businessUnitServicePairs?: BusinessUnitServicePairUpdateManyWithoutServiceOfficeNestedInput
  }

  export type ServiceOfficeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    serviceOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: ServiceChannelOfficeTeamPairUncheckedUpdateManyWithoutServiceOfficeNestedInput
    businessUnitServicePairs?: BusinessUnitServicePairUncheckedUpdateManyWithoutServiceOfficeNestedInput
  }

  export type ServiceOfficeCreateManyInput = {
    id?: number
    serviceOfficeId: string
    organizationName: string
    serviceOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceOfficeUpdateManyMutationInput = {
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    serviceOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceOfficeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    serviceOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTeamCreateInput = {
    serviceTeamCode: string
    serviceTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: ServiceChannelOfficeTeamPairCreateNestedManyWithoutServiceTeamInput
    businessUnitServicePairs?: BusinessUnitServicePairCreateNestedManyWithoutServiceTeamInput
  }

  export type ServiceTeamUncheckedCreateInput = {
    id?: number
    serviceTeamCode: string
    serviceTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: ServiceChannelOfficeTeamPairUncheckedCreateNestedManyWithoutServiceTeamInput
    businessUnitServicePairs?: BusinessUnitServicePairUncheckedCreateNestedManyWithoutServiceTeamInput
  }

  export type ServiceTeamUpdateInput = {
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
    serviceTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: ServiceChannelOfficeTeamPairUpdateManyWithoutServiceTeamNestedInput
    businessUnitServicePairs?: BusinessUnitServicePairUpdateManyWithoutServiceTeamNestedInput
  }

  export type ServiceTeamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
    serviceTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: ServiceChannelOfficeTeamPairUncheckedUpdateManyWithoutServiceTeamNestedInput
    businessUnitServicePairs?: BusinessUnitServicePairUncheckedUpdateManyWithoutServiceTeamNestedInput
  }

  export type ServiceTeamCreateManyInput = {
    id?: number
    serviceTeamCode: string
    serviceTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTeamUpdateManyMutationInput = {
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
    serviceTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTeamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
    serviceTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceChannelOfficeTeamPairCreateInput = {
    serviceChannel: ServiceChannelCreateNestedOneWithoutChannelOfficePairsInput
    serviceOffice: ServiceOfficeCreateNestedOneWithoutOfficeTeamPairsInput
    serviceTeam: ServiceTeamCreateNestedOneWithoutOfficeTeamPairsInput
  }

  export type ServiceChannelOfficeTeamPairUncheckedCreateInput = {
    id?: number
    serviceChannelCode: string
    serviceOfficeId: string
    serviceTeamCode: string
  }

  export type ServiceChannelOfficeTeamPairUpdateInput = {
    serviceChannel?: ServiceChannelUpdateOneRequiredWithoutChannelOfficePairsNestedInput
    serviceOffice?: ServiceOfficeUpdateOneRequiredWithoutOfficeTeamPairsNestedInput
    serviceTeam?: ServiceTeamUpdateOneRequiredWithoutOfficeTeamPairsNestedInput
  }

  export type ServiceChannelOfficeTeamPairUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceChannelOfficeTeamPairCreateManyInput = {
    id?: number
    serviceChannelCode: string
    serviceOfficeId: string
    serviceTeamCode: string
  }

  export type ServiceChannelOfficeTeamPairUpdateManyMutationInput = {

  }

  export type ServiceChannelOfficeTeamPairUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitSalesPairCreateInput = {
    id?: string
    businessUnit: BusinessUnitCreateNestedOneWithoutBusinessUnitSalesPairsInput
    salesChannel: SalesChannelCreateNestedOneWithoutBusinessUnitSalesPairsInput
    salesOffice: SalesOfficeCreateNestedOneWithoutBusinessUnitSalesPairsInput
    salesTeam: SalesTeamCreateNestedOneWithoutBusinessUnitSalesPairsInput
  }

  export type BusinessUnitSalesPairUncheckedCreateInput = {
    id?: string
    businessUnitCode: string
    salesChannelCode: string
    salesOfficeId: string
    salesTeamCode: string
  }

  export type BusinessUnitSalesPairUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnit?: BusinessUnitUpdateOneRequiredWithoutBusinessUnitSalesPairsNestedInput
    salesChannel?: SalesChannelUpdateOneRequiredWithoutBusinessUnitSalesPairsNestedInput
    salesOffice?: SalesOfficeUpdateOneRequiredWithoutBusinessUnitSalesPairsNestedInput
    salesTeam?: SalesTeamUpdateOneRequiredWithoutBusinessUnitSalesPairsNestedInput
  }

  export type BusinessUnitSalesPairUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesOfficeId?: StringFieldUpdateOperationsInput | string
    salesTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitSalesPairCreateManyInput = {
    id?: string
    businessUnitCode: string
    salesChannelCode: string
    salesOfficeId: string
    salesTeamCode: string
  }

  export type BusinessUnitSalesPairUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitSalesPairUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesOfficeId?: StringFieldUpdateOperationsInput | string
    salesTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitMarketingPairCreateInput = {
    id?: string
    businessUnit: BusinessUnitCreateNestedOneWithoutBusinessUnitMarketingPairsInput
    marketingChannel: MarketingChannelCreateNestedOneWithoutBusinessUnitMarketingPairsInput
    marketingOffice: MarketingOfficeCreateNestedOneWithoutBusinessUnitMarketingPairsInput
    marketingTeam: MarketingTeamCreateNestedOneWithoutBusinessUnitMarketingPairsInput
  }

  export type BusinessUnitMarketingPairUncheckedCreateInput = {
    id?: string
    businessUnitCode: string
    marketingChannelCode: string
    marketingOfficeId: string
    marketingTeamCode: string
  }

  export type BusinessUnitMarketingPairUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnit?: BusinessUnitUpdateOneRequiredWithoutBusinessUnitMarketingPairsNestedInput
    marketingChannel?: MarketingChannelUpdateOneRequiredWithoutBusinessUnitMarketingPairsNestedInput
    marketingOffice?: MarketingOfficeUpdateOneRequiredWithoutBusinessUnitMarketingPairsNestedInput
    marketingTeam?: MarketingTeamUpdateOneRequiredWithoutBusinessUnitMarketingPairsNestedInput
  }

  export type BusinessUnitMarketingPairUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitMarketingPairCreateManyInput = {
    id?: string
    businessUnitCode: string
    marketingChannelCode: string
    marketingOfficeId: string
    marketingTeamCode: string
  }

  export type BusinessUnitMarketingPairUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitMarketingPairUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitServicePairCreateInput = {
    id?: string
    businessUnit: BusinessUnitCreateNestedOneWithoutBusinessUnitServicePairsInput
    serviceChannel: ServiceChannelCreateNestedOneWithoutBusinessUnitServicePairsInput
    serviceOffice: ServiceOfficeCreateNestedOneWithoutBusinessUnitServicePairsInput
    serviceTeam: ServiceTeamCreateNestedOneWithoutBusinessUnitServicePairsInput
  }

  export type BusinessUnitServicePairUncheckedCreateInput = {
    id?: string
    businessUnitCode: string
    serviceChannelCode: string
    serviceOfficeId: string
    serviceTeamCode: string
  }

  export type BusinessUnitServicePairUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnit?: BusinessUnitUpdateOneRequiredWithoutBusinessUnitServicePairsNestedInput
    serviceChannel?: ServiceChannelUpdateOneRequiredWithoutBusinessUnitServicePairsNestedInput
    serviceOffice?: ServiceOfficeUpdateOneRequiredWithoutBusinessUnitServicePairsNestedInput
    serviceTeam?: ServiceTeamUpdateOneRequiredWithoutBusinessUnitServicePairsNestedInput
  }

  export type BusinessUnitServicePairUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitServicePairCreateManyInput = {
    id?: string
    businessUnitCode: string
    serviceChannelCode: string
    serviceOfficeId: string
    serviceTeamCode: string
  }

  export type BusinessUnitServicePairUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitServicePairUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type SalesTeamManagerCreateInput = {
    id?: string
    userId: string
    validFrom: Date | string
    validTo?: Date | string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamManagerUncheckedCreateInput = {
    id?: string
    userId: string
    validFrom: Date | string
    validTo?: Date | string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamManagerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamManagerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamManagerCreateManyInput = {
    id?: string
    userId: string
    validFrom: Date | string
    validTo?: Date | string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamManagerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamManagerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingTeamManagerCreateInput = {
    id?: string
    userId: string
    validFrom: Date | string
    validTo?: Date | string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingTeamManagerUncheckedCreateInput = {
    id?: string
    userId: string
    validFrom: Date | string
    validTo?: Date | string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingTeamManagerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingTeamManagerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingTeamManagerCreateManyInput = {
    id?: string
    userId: string
    validFrom: Date | string
    validTo?: Date | string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingTeamManagerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingTeamManagerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTeamManagerCreateInput = {
    id?: string
    userId: string
    validFrom: Date | string
    validTo?: Date | string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTeamManagerUncheckedCreateInput = {
    id?: string
    userId: string
    validFrom: Date | string
    validTo?: Date | string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTeamManagerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTeamManagerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTeamManagerCreateManyInput = {
    id?: string
    userId: string
    validFrom: Date | string
    validTo?: Date | string | null
    primary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTeamManagerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTeamManagerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamEmployeeCreateInput = {
    id?: string
    userId: string
    validFrom: Date | string
    validTo?: Date | string | null
    primary?: boolean
    job?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamEmployeeUncheckedCreateInput = {
    id?: string
    userId: string
    validFrom: Date | string
    validTo?: Date | string | null
    primary?: boolean
    job?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamEmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    job?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamEmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    job?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamEmployeeCreateManyInput = {
    id?: string
    userId: string
    validFrom: Date | string
    validTo?: Date | string | null
    primary?: boolean
    job?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalesTeamEmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    job?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalesTeamEmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    job?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingTeamEmployeeCreateInput = {
    id?: string
    userId: string
    validFrom: Date | string
    validTo?: Date | string | null
    primary?: boolean
    job?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingTeamEmployeeUncheckedCreateInput = {
    id?: string
    userId: string
    validFrom: Date | string
    validTo?: Date | string | null
    primary?: boolean
    job?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingTeamEmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    job?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingTeamEmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    job?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingTeamEmployeeCreateManyInput = {
    id?: string
    userId: string
    validFrom: Date | string
    validTo?: Date | string | null
    primary?: boolean
    job?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MarketingTeamEmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    job?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MarketingTeamEmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    job?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTeamEmployeeCreateInput = {
    id?: string
    userId: string
    validFrom: Date | string
    validTo?: Date | string | null
    primary?: boolean
    job?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTeamEmployeeUncheckedCreateInput = {
    id?: string
    userId: string
    validFrom: Date | string
    validTo?: Date | string | null
    primary?: boolean
    job?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTeamEmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    job?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTeamEmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    job?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTeamEmployeeCreateManyInput = {
    id?: string
    userId: string
    validFrom: Date | string
    validTo?: Date | string | null
    primary?: boolean
    job?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceTeamEmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    job?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceTeamEmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    primary?: BoolFieldUpdateOperationsInput | boolean
    job?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BusinessEntityUnitPairListRelationFilter = {
    every?: BusinessEntityUnitPairWhereInput
    some?: BusinessEntityUnitPairWhereInput
    none?: BusinessEntityUnitPairWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BusinessEntityUnitPairOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessEntityCountOrderByAggregateInput = {
    id?: SortOrder
    businessEntityCode?: SortOrder
    businessEntityName?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessEntityAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BusinessEntityMaxOrderByAggregateInput = {
    id?: SortOrder
    businessEntityCode?: SortOrder
    businessEntityName?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessEntityMinOrderByAggregateInput = {
    id?: SortOrder
    businessEntityCode?: SortOrder
    businessEntityName?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessEntitySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BusinessUnitSalesPairListRelationFilter = {
    every?: BusinessUnitSalesPairWhereInput
    some?: BusinessUnitSalesPairWhereInput
    none?: BusinessUnitSalesPairWhereInput
  }

  export type BusinessUnitMarketingPairListRelationFilter = {
    every?: BusinessUnitMarketingPairWhereInput
    some?: BusinessUnitMarketingPairWhereInput
    none?: BusinessUnitMarketingPairWhereInput
  }

  export type BusinessUnitServicePairListRelationFilter = {
    every?: BusinessUnitServicePairWhereInput
    some?: BusinessUnitServicePairWhereInput
    none?: BusinessUnitServicePairWhereInput
  }

  export type BusinessUnitSalesPairOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessUnitMarketingPairOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessUnitServicePairOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessUnitCountOrderByAggregateInput = {
    id?: SortOrder
    businessUnitCode?: SortOrder
    businessUnitDesc?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessUnitAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BusinessUnitMaxOrderByAggregateInput = {
    id?: SortOrder
    businessUnitCode?: SortOrder
    businessUnitDesc?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessUnitMinOrderByAggregateInput = {
    id?: SortOrder
    businessUnitCode?: SortOrder
    businessUnitDesc?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessUnitSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BusinessEntityScalarRelationFilter = {
    is?: BusinessEntityWhereInput
    isNot?: BusinessEntityWhereInput
  }

  export type BusinessUnitScalarRelationFilter = {
    is?: BusinessUnitWhereInput
    isNot?: BusinessUnitWhereInput
  }

  export type BusinessEntityUnitPairBusinessEntityCodeBusinessUnitCodeCompoundUniqueInput = {
    businessEntityCode: string
    businessUnitCode: string
  }

  export type BusinessEntityUnitPairCountOrderByAggregateInput = {
    id?: SortOrder
    businessEntityCode?: SortOrder
    businessUnitCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessEntityUnitPairAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BusinessEntityUnitPairMaxOrderByAggregateInput = {
    id?: SortOrder
    businessEntityCode?: SortOrder
    businessUnitCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessEntityUnitPairMinOrderByAggregateInput = {
    id?: SortOrder
    businessEntityCode?: SortOrder
    businessUnitCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessEntityUnitPairSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SalesChannelOfficeTeamPairListRelationFilter = {
    every?: SalesChannelOfficeTeamPairWhereInput
    some?: SalesChannelOfficeTeamPairWhereInput
    none?: SalesChannelOfficeTeamPairWhereInput
  }

  export type SalesChannelOfficeTeamPairOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesChannelCountOrderByAggregateInput = {
    id?: SortOrder
    salesChannelCode?: SortOrder
    salesChannelName?: SortOrder
    salesChannelDesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesChannelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SalesChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    salesChannelCode?: SortOrder
    salesChannelName?: SortOrder
    salesChannelDesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesChannelMinOrderByAggregateInput = {
    id?: SortOrder
    salesChannelCode?: SortOrder
    salesChannelName?: SortOrder
    salesChannelDesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesChannelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SalesOfficeCountOrderByAggregateInput = {
    id?: SortOrder
    salesOfficeId?: SortOrder
    organizationName?: SortOrder
    salesOfficeDesc?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    company?: SortOrder
    parentUnit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesOfficeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SalesOfficeMaxOrderByAggregateInput = {
    id?: SortOrder
    salesOfficeId?: SortOrder
    organizationName?: SortOrder
    salesOfficeDesc?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    company?: SortOrder
    parentUnit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesOfficeMinOrderByAggregateInput = {
    id?: SortOrder
    salesOfficeId?: SortOrder
    organizationName?: SortOrder
    salesOfficeDesc?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    company?: SortOrder
    parentUnit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesOfficeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SalesTeamCountOrderByAggregateInput = {
    id?: SortOrder
    salesTeamCode?: SortOrder
    salesTeamName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesTeamAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SalesTeamMaxOrderByAggregateInput = {
    id?: SortOrder
    salesTeamCode?: SortOrder
    salesTeamName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesTeamMinOrderByAggregateInput = {
    id?: SortOrder
    salesTeamCode?: SortOrder
    salesTeamName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesTeamSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SalesChannelScalarRelationFilter = {
    is?: SalesChannelWhereInput
    isNot?: SalesChannelWhereInput
  }

  export type SalesOfficeScalarRelationFilter = {
    is?: SalesOfficeWhereInput
    isNot?: SalesOfficeWhereInput
  }

  export type SalesTeamScalarRelationFilter = {
    is?: SalesTeamWhereInput
    isNot?: SalesTeamWhereInput
  }

  export type SalesChannelOfficeTeamPairSalesChannelCodeSalesOfficeIdSalesTeamCodeCompoundUniqueInput = {
    salesChannelCode: string
    salesOfficeId: string
    salesTeamCode: string
  }

  export type SalesChannelOfficeTeamPairCountOrderByAggregateInput = {
    id?: SortOrder
    salesChannelCode?: SortOrder
    salesOfficeId?: SortOrder
    salesTeamCode?: SortOrder
  }

  export type SalesChannelOfficeTeamPairAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SalesChannelOfficeTeamPairMaxOrderByAggregateInput = {
    id?: SortOrder
    salesChannelCode?: SortOrder
    salesOfficeId?: SortOrder
    salesTeamCode?: SortOrder
  }

  export type SalesChannelOfficeTeamPairMinOrderByAggregateInput = {
    id?: SortOrder
    salesChannelCode?: SortOrder
    salesOfficeId?: SortOrder
    salesTeamCode?: SortOrder
  }

  export type SalesChannelOfficeTeamPairSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MarketingChannelOfficeTeamPairListRelationFilter = {
    every?: MarketingChannelOfficeTeamPairWhereInput
    some?: MarketingChannelOfficeTeamPairWhereInput
    none?: MarketingChannelOfficeTeamPairWhereInput
  }

  export type MarketingChannelOfficeTeamPairOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MarketingChannelCountOrderByAggregateInput = {
    id?: SortOrder
    marketingChannelCode?: SortOrder
    marketingChannelName?: SortOrder
    marketingChannelDesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingChannelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MarketingChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    marketingChannelCode?: SortOrder
    marketingChannelName?: SortOrder
    marketingChannelDesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingChannelMinOrderByAggregateInput = {
    id?: SortOrder
    marketingChannelCode?: SortOrder
    marketingChannelName?: SortOrder
    marketingChannelDesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingChannelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MarketingOfficeCountOrderByAggregateInput = {
    id?: SortOrder
    marketingOfficeId?: SortOrder
    organizationName?: SortOrder
    marketingOfficeDesc?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    company?: SortOrder
    parentUnit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingOfficeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MarketingOfficeMaxOrderByAggregateInput = {
    id?: SortOrder
    marketingOfficeId?: SortOrder
    organizationName?: SortOrder
    marketingOfficeDesc?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    company?: SortOrder
    parentUnit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingOfficeMinOrderByAggregateInput = {
    id?: SortOrder
    marketingOfficeId?: SortOrder
    organizationName?: SortOrder
    marketingOfficeDesc?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    company?: SortOrder
    parentUnit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingOfficeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MarketingTeamCountOrderByAggregateInput = {
    id?: SortOrder
    marketingTeamCode?: SortOrder
    marketingTeamName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingTeamAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MarketingTeamMaxOrderByAggregateInput = {
    id?: SortOrder
    marketingTeamCode?: SortOrder
    marketingTeamName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingTeamMinOrderByAggregateInput = {
    id?: SortOrder
    marketingTeamCode?: SortOrder
    marketingTeamName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingTeamSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MarketingChannelScalarRelationFilter = {
    is?: MarketingChannelWhereInput
    isNot?: MarketingChannelWhereInput
  }

  export type MarketingOfficeScalarRelationFilter = {
    is?: MarketingOfficeWhereInput
    isNot?: MarketingOfficeWhereInput
  }

  export type MarketingTeamScalarRelationFilter = {
    is?: MarketingTeamWhereInput
    isNot?: MarketingTeamWhereInput
  }

  export type MarketingChannelOfficeTeamPairMarketingChannelCodeMarketingOfficeIdMarketingTeamCodeCompoundUniqueInput = {
    marketingChannelCode: string
    marketingOfficeId: string
    marketingTeamCode: string
  }

  export type MarketingChannelOfficeTeamPairCountOrderByAggregateInput = {
    id?: SortOrder
    marketingChannelCode?: SortOrder
    marketingOfficeId?: SortOrder
    marketingTeamCode?: SortOrder
  }

  export type MarketingChannelOfficeTeamPairAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MarketingChannelOfficeTeamPairMaxOrderByAggregateInput = {
    id?: SortOrder
    marketingChannelCode?: SortOrder
    marketingOfficeId?: SortOrder
    marketingTeamCode?: SortOrder
  }

  export type MarketingChannelOfficeTeamPairMinOrderByAggregateInput = {
    id?: SortOrder
    marketingChannelCode?: SortOrder
    marketingOfficeId?: SortOrder
    marketingTeamCode?: SortOrder
  }

  export type MarketingChannelOfficeTeamPairSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceChannelOfficeTeamPairListRelationFilter = {
    every?: ServiceChannelOfficeTeamPairWhereInput
    some?: ServiceChannelOfficeTeamPairWhereInput
    none?: ServiceChannelOfficeTeamPairWhereInput
  }

  export type ServiceChannelOfficeTeamPairOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceChannelCountOrderByAggregateInput = {
    id?: SortOrder
    serviceChannelCode?: SortOrder
    serviceChannelName?: SortOrder
    serviceChannelDesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceChannelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceChannelCode?: SortOrder
    serviceChannelName?: SortOrder
    serviceChannelDesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceChannelMinOrderByAggregateInput = {
    id?: SortOrder
    serviceChannelCode?: SortOrder
    serviceChannelName?: SortOrder
    serviceChannelDesc?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceChannelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceOfficeCountOrderByAggregateInput = {
    id?: SortOrder
    serviceOfficeId?: SortOrder
    organizationName?: SortOrder
    serviceOfficeDesc?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    company?: SortOrder
    parentUnit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceOfficeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceOfficeMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceOfficeId?: SortOrder
    organizationName?: SortOrder
    serviceOfficeDesc?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    company?: SortOrder
    parentUnit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceOfficeMinOrderByAggregateInput = {
    id?: SortOrder
    serviceOfficeId?: SortOrder
    organizationName?: SortOrder
    serviceOfficeDesc?: SortOrder
    street1?: SortOrder
    street2?: SortOrder
    city?: SortOrder
    state?: SortOrder
    region?: SortOrder
    country?: SortOrder
    pinCode?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    company?: SortOrder
    parentUnit?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceOfficeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceTeamCountOrderByAggregateInput = {
    id?: SortOrder
    serviceTeamCode?: SortOrder
    serviceTeamName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTeamAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceTeamMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceTeamCode?: SortOrder
    serviceTeamName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTeamMinOrderByAggregateInput = {
    id?: SortOrder
    serviceTeamCode?: SortOrder
    serviceTeamName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTeamSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceChannelScalarRelationFilter = {
    is?: ServiceChannelWhereInput
    isNot?: ServiceChannelWhereInput
  }

  export type ServiceOfficeScalarRelationFilter = {
    is?: ServiceOfficeWhereInput
    isNot?: ServiceOfficeWhereInput
  }

  export type ServiceTeamScalarRelationFilter = {
    is?: ServiceTeamWhereInput
    isNot?: ServiceTeamWhereInput
  }

  export type ServiceChannelOfficeTeamPairServiceChannelCodeServiceOfficeIdServiceTeamCodeCompoundUniqueInput = {
    serviceChannelCode: string
    serviceOfficeId: string
    serviceTeamCode: string
  }

  export type ServiceChannelOfficeTeamPairCountOrderByAggregateInput = {
    id?: SortOrder
    serviceChannelCode?: SortOrder
    serviceOfficeId?: SortOrder
    serviceTeamCode?: SortOrder
  }

  export type ServiceChannelOfficeTeamPairAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceChannelOfficeTeamPairMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceChannelCode?: SortOrder
    serviceOfficeId?: SortOrder
    serviceTeamCode?: SortOrder
  }

  export type ServiceChannelOfficeTeamPairMinOrderByAggregateInput = {
    id?: SortOrder
    serviceChannelCode?: SortOrder
    serviceOfficeId?: SortOrder
    serviceTeamCode?: SortOrder
  }

  export type ServiceChannelOfficeTeamPairSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BusinessUnitSalesPairBusinessUnitCodeSalesChannelCodeSalesOfficeIdSalesTeamCodeCompoundUniqueInput = {
    businessUnitCode: string
    salesChannelCode: string
    salesOfficeId: string
    salesTeamCode: string
  }

  export type BusinessUnitSalesPairCountOrderByAggregateInput = {
    id?: SortOrder
    businessUnitCode?: SortOrder
    salesChannelCode?: SortOrder
    salesOfficeId?: SortOrder
    salesTeamCode?: SortOrder
  }

  export type BusinessUnitSalesPairMaxOrderByAggregateInput = {
    id?: SortOrder
    businessUnitCode?: SortOrder
    salesChannelCode?: SortOrder
    salesOfficeId?: SortOrder
    salesTeamCode?: SortOrder
  }

  export type BusinessUnitSalesPairMinOrderByAggregateInput = {
    id?: SortOrder
    businessUnitCode?: SortOrder
    salesChannelCode?: SortOrder
    salesOfficeId?: SortOrder
    salesTeamCode?: SortOrder
  }

  export type BusinessUnitMarketingPairBusinessUnitCodeMarketingChannelCodeMarketingOfficeIdMarketingTeamCodeCompoundUniqueInput = {
    businessUnitCode: string
    marketingChannelCode: string
    marketingOfficeId: string
    marketingTeamCode: string
  }

  export type BusinessUnitMarketingPairCountOrderByAggregateInput = {
    id?: SortOrder
    businessUnitCode?: SortOrder
    marketingChannelCode?: SortOrder
    marketingOfficeId?: SortOrder
    marketingTeamCode?: SortOrder
  }

  export type BusinessUnitMarketingPairMaxOrderByAggregateInput = {
    id?: SortOrder
    businessUnitCode?: SortOrder
    marketingChannelCode?: SortOrder
    marketingOfficeId?: SortOrder
    marketingTeamCode?: SortOrder
  }

  export type BusinessUnitMarketingPairMinOrderByAggregateInput = {
    id?: SortOrder
    businessUnitCode?: SortOrder
    marketingChannelCode?: SortOrder
    marketingOfficeId?: SortOrder
    marketingTeamCode?: SortOrder
  }

  export type BusinessUnitServicePairBusinessUnitCodeServiceChannelCodeServiceOfficeIdServiceTeamCodeCompoundUniqueInput = {
    businessUnitCode: string
    serviceChannelCode: string
    serviceOfficeId: string
    serviceTeamCode: string
  }

  export type BusinessUnitServicePairCountOrderByAggregateInput = {
    id?: SortOrder
    businessUnitCode?: SortOrder
    serviceChannelCode?: SortOrder
    serviceOfficeId?: SortOrder
    serviceTeamCode?: SortOrder
  }

  export type BusinessUnitServicePairMaxOrderByAggregateInput = {
    id?: SortOrder
    businessUnitCode?: SortOrder
    serviceChannelCode?: SortOrder
    serviceOfficeId?: SortOrder
    serviceTeamCode?: SortOrder
  }

  export type BusinessUnitServicePairMinOrderByAggregateInput = {
    id?: SortOrder
    businessUnitCode?: SortOrder
    serviceChannelCode?: SortOrder
    serviceOfficeId?: SortOrder
    serviceTeamCode?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type SalesTeamManagerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesTeamManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesTeamManagerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type MarketingTeamManagerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingTeamManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingTeamManagerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTeamManagerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTeamManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTeamManagerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    primary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesTeamEmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    primary?: SortOrder
    job?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesTeamEmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    primary?: SortOrder
    job?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalesTeamEmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    primary?: SortOrder
    job?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingTeamEmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    primary?: SortOrder
    job?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingTeamEmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    primary?: SortOrder
    job?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MarketingTeamEmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    primary?: SortOrder
    job?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTeamEmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    primary?: SortOrder
    job?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTeamEmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    primary?: SortOrder
    job?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceTeamEmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    primary?: SortOrder
    job?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BusinessEntityUnitPairCreateNestedManyWithoutBusinessEntityInput = {
    create?: XOR<BusinessEntityUnitPairCreateWithoutBusinessEntityInput, BusinessEntityUnitPairUncheckedCreateWithoutBusinessEntityInput> | BusinessEntityUnitPairCreateWithoutBusinessEntityInput[] | BusinessEntityUnitPairUncheckedCreateWithoutBusinessEntityInput[]
    connectOrCreate?: BusinessEntityUnitPairCreateOrConnectWithoutBusinessEntityInput | BusinessEntityUnitPairCreateOrConnectWithoutBusinessEntityInput[]
    createMany?: BusinessEntityUnitPairCreateManyBusinessEntityInputEnvelope
    connect?: BusinessEntityUnitPairWhereUniqueInput | BusinessEntityUnitPairWhereUniqueInput[]
  }

  export type BusinessEntityUnitPairUncheckedCreateNestedManyWithoutBusinessEntityInput = {
    create?: XOR<BusinessEntityUnitPairCreateWithoutBusinessEntityInput, BusinessEntityUnitPairUncheckedCreateWithoutBusinessEntityInput> | BusinessEntityUnitPairCreateWithoutBusinessEntityInput[] | BusinessEntityUnitPairUncheckedCreateWithoutBusinessEntityInput[]
    connectOrCreate?: BusinessEntityUnitPairCreateOrConnectWithoutBusinessEntityInput | BusinessEntityUnitPairCreateOrConnectWithoutBusinessEntityInput[]
    createMany?: BusinessEntityUnitPairCreateManyBusinessEntityInputEnvelope
    connect?: BusinessEntityUnitPairWhereUniqueInput | BusinessEntityUnitPairWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BusinessEntityUnitPairUpdateManyWithoutBusinessEntityNestedInput = {
    create?: XOR<BusinessEntityUnitPairCreateWithoutBusinessEntityInput, BusinessEntityUnitPairUncheckedCreateWithoutBusinessEntityInput> | BusinessEntityUnitPairCreateWithoutBusinessEntityInput[] | BusinessEntityUnitPairUncheckedCreateWithoutBusinessEntityInput[]
    connectOrCreate?: BusinessEntityUnitPairCreateOrConnectWithoutBusinessEntityInput | BusinessEntityUnitPairCreateOrConnectWithoutBusinessEntityInput[]
    upsert?: BusinessEntityUnitPairUpsertWithWhereUniqueWithoutBusinessEntityInput | BusinessEntityUnitPairUpsertWithWhereUniqueWithoutBusinessEntityInput[]
    createMany?: BusinessEntityUnitPairCreateManyBusinessEntityInputEnvelope
    set?: BusinessEntityUnitPairWhereUniqueInput | BusinessEntityUnitPairWhereUniqueInput[]
    disconnect?: BusinessEntityUnitPairWhereUniqueInput | BusinessEntityUnitPairWhereUniqueInput[]
    delete?: BusinessEntityUnitPairWhereUniqueInput | BusinessEntityUnitPairWhereUniqueInput[]
    connect?: BusinessEntityUnitPairWhereUniqueInput | BusinessEntityUnitPairWhereUniqueInput[]
    update?: BusinessEntityUnitPairUpdateWithWhereUniqueWithoutBusinessEntityInput | BusinessEntityUnitPairUpdateWithWhereUniqueWithoutBusinessEntityInput[]
    updateMany?: BusinessEntityUnitPairUpdateManyWithWhereWithoutBusinessEntityInput | BusinessEntityUnitPairUpdateManyWithWhereWithoutBusinessEntityInput[]
    deleteMany?: BusinessEntityUnitPairScalarWhereInput | BusinessEntityUnitPairScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BusinessEntityUnitPairUncheckedUpdateManyWithoutBusinessEntityNestedInput = {
    create?: XOR<BusinessEntityUnitPairCreateWithoutBusinessEntityInput, BusinessEntityUnitPairUncheckedCreateWithoutBusinessEntityInput> | BusinessEntityUnitPairCreateWithoutBusinessEntityInput[] | BusinessEntityUnitPairUncheckedCreateWithoutBusinessEntityInput[]
    connectOrCreate?: BusinessEntityUnitPairCreateOrConnectWithoutBusinessEntityInput | BusinessEntityUnitPairCreateOrConnectWithoutBusinessEntityInput[]
    upsert?: BusinessEntityUnitPairUpsertWithWhereUniqueWithoutBusinessEntityInput | BusinessEntityUnitPairUpsertWithWhereUniqueWithoutBusinessEntityInput[]
    createMany?: BusinessEntityUnitPairCreateManyBusinessEntityInputEnvelope
    set?: BusinessEntityUnitPairWhereUniqueInput | BusinessEntityUnitPairWhereUniqueInput[]
    disconnect?: BusinessEntityUnitPairWhereUniqueInput | BusinessEntityUnitPairWhereUniqueInput[]
    delete?: BusinessEntityUnitPairWhereUniqueInput | BusinessEntityUnitPairWhereUniqueInput[]
    connect?: BusinessEntityUnitPairWhereUniqueInput | BusinessEntityUnitPairWhereUniqueInput[]
    update?: BusinessEntityUnitPairUpdateWithWhereUniqueWithoutBusinessEntityInput | BusinessEntityUnitPairUpdateWithWhereUniqueWithoutBusinessEntityInput[]
    updateMany?: BusinessEntityUnitPairUpdateManyWithWhereWithoutBusinessEntityInput | BusinessEntityUnitPairUpdateManyWithWhereWithoutBusinessEntityInput[]
    deleteMany?: BusinessEntityUnitPairScalarWhereInput | BusinessEntityUnitPairScalarWhereInput[]
  }

  export type BusinessEntityUnitPairCreateNestedManyWithoutBusinessUnitInput = {
    create?: XOR<BusinessEntityUnitPairCreateWithoutBusinessUnitInput, BusinessEntityUnitPairUncheckedCreateWithoutBusinessUnitInput> | BusinessEntityUnitPairCreateWithoutBusinessUnitInput[] | BusinessEntityUnitPairUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: BusinessEntityUnitPairCreateOrConnectWithoutBusinessUnitInput | BusinessEntityUnitPairCreateOrConnectWithoutBusinessUnitInput[]
    createMany?: BusinessEntityUnitPairCreateManyBusinessUnitInputEnvelope
    connect?: BusinessEntityUnitPairWhereUniqueInput | BusinessEntityUnitPairWhereUniqueInput[]
  }

  export type BusinessUnitSalesPairCreateNestedManyWithoutBusinessUnitInput = {
    create?: XOR<BusinessUnitSalesPairCreateWithoutBusinessUnitInput, BusinessUnitSalesPairUncheckedCreateWithoutBusinessUnitInput> | BusinessUnitSalesPairCreateWithoutBusinessUnitInput[] | BusinessUnitSalesPairUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: BusinessUnitSalesPairCreateOrConnectWithoutBusinessUnitInput | BusinessUnitSalesPairCreateOrConnectWithoutBusinessUnitInput[]
    createMany?: BusinessUnitSalesPairCreateManyBusinessUnitInputEnvelope
    connect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
  }

  export type BusinessUnitMarketingPairCreateNestedManyWithoutBusinessUnitInput = {
    create?: XOR<BusinessUnitMarketingPairCreateWithoutBusinessUnitInput, BusinessUnitMarketingPairUncheckedCreateWithoutBusinessUnitInput> | BusinessUnitMarketingPairCreateWithoutBusinessUnitInput[] | BusinessUnitMarketingPairUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: BusinessUnitMarketingPairCreateOrConnectWithoutBusinessUnitInput | BusinessUnitMarketingPairCreateOrConnectWithoutBusinessUnitInput[]
    createMany?: BusinessUnitMarketingPairCreateManyBusinessUnitInputEnvelope
    connect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
  }

  export type BusinessUnitServicePairCreateNestedManyWithoutBusinessUnitInput = {
    create?: XOR<BusinessUnitServicePairCreateWithoutBusinessUnitInput, BusinessUnitServicePairUncheckedCreateWithoutBusinessUnitInput> | BusinessUnitServicePairCreateWithoutBusinessUnitInput[] | BusinessUnitServicePairUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: BusinessUnitServicePairCreateOrConnectWithoutBusinessUnitInput | BusinessUnitServicePairCreateOrConnectWithoutBusinessUnitInput[]
    createMany?: BusinessUnitServicePairCreateManyBusinessUnitInputEnvelope
    connect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
  }

  export type BusinessEntityUnitPairUncheckedCreateNestedManyWithoutBusinessUnitInput = {
    create?: XOR<BusinessEntityUnitPairCreateWithoutBusinessUnitInput, BusinessEntityUnitPairUncheckedCreateWithoutBusinessUnitInput> | BusinessEntityUnitPairCreateWithoutBusinessUnitInput[] | BusinessEntityUnitPairUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: BusinessEntityUnitPairCreateOrConnectWithoutBusinessUnitInput | BusinessEntityUnitPairCreateOrConnectWithoutBusinessUnitInput[]
    createMany?: BusinessEntityUnitPairCreateManyBusinessUnitInputEnvelope
    connect?: BusinessEntityUnitPairWhereUniqueInput | BusinessEntityUnitPairWhereUniqueInput[]
  }

  export type BusinessUnitSalesPairUncheckedCreateNestedManyWithoutBusinessUnitInput = {
    create?: XOR<BusinessUnitSalesPairCreateWithoutBusinessUnitInput, BusinessUnitSalesPairUncheckedCreateWithoutBusinessUnitInput> | BusinessUnitSalesPairCreateWithoutBusinessUnitInput[] | BusinessUnitSalesPairUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: BusinessUnitSalesPairCreateOrConnectWithoutBusinessUnitInput | BusinessUnitSalesPairCreateOrConnectWithoutBusinessUnitInput[]
    createMany?: BusinessUnitSalesPairCreateManyBusinessUnitInputEnvelope
    connect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
  }

  export type BusinessUnitMarketingPairUncheckedCreateNestedManyWithoutBusinessUnitInput = {
    create?: XOR<BusinessUnitMarketingPairCreateWithoutBusinessUnitInput, BusinessUnitMarketingPairUncheckedCreateWithoutBusinessUnitInput> | BusinessUnitMarketingPairCreateWithoutBusinessUnitInput[] | BusinessUnitMarketingPairUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: BusinessUnitMarketingPairCreateOrConnectWithoutBusinessUnitInput | BusinessUnitMarketingPairCreateOrConnectWithoutBusinessUnitInput[]
    createMany?: BusinessUnitMarketingPairCreateManyBusinessUnitInputEnvelope
    connect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
  }

  export type BusinessUnitServicePairUncheckedCreateNestedManyWithoutBusinessUnitInput = {
    create?: XOR<BusinessUnitServicePairCreateWithoutBusinessUnitInput, BusinessUnitServicePairUncheckedCreateWithoutBusinessUnitInput> | BusinessUnitServicePairCreateWithoutBusinessUnitInput[] | BusinessUnitServicePairUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: BusinessUnitServicePairCreateOrConnectWithoutBusinessUnitInput | BusinessUnitServicePairCreateOrConnectWithoutBusinessUnitInput[]
    createMany?: BusinessUnitServicePairCreateManyBusinessUnitInputEnvelope
    connect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
  }

  export type BusinessEntityUnitPairUpdateManyWithoutBusinessUnitNestedInput = {
    create?: XOR<BusinessEntityUnitPairCreateWithoutBusinessUnitInput, BusinessEntityUnitPairUncheckedCreateWithoutBusinessUnitInput> | BusinessEntityUnitPairCreateWithoutBusinessUnitInput[] | BusinessEntityUnitPairUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: BusinessEntityUnitPairCreateOrConnectWithoutBusinessUnitInput | BusinessEntityUnitPairCreateOrConnectWithoutBusinessUnitInput[]
    upsert?: BusinessEntityUnitPairUpsertWithWhereUniqueWithoutBusinessUnitInput | BusinessEntityUnitPairUpsertWithWhereUniqueWithoutBusinessUnitInput[]
    createMany?: BusinessEntityUnitPairCreateManyBusinessUnitInputEnvelope
    set?: BusinessEntityUnitPairWhereUniqueInput | BusinessEntityUnitPairWhereUniqueInput[]
    disconnect?: BusinessEntityUnitPairWhereUniqueInput | BusinessEntityUnitPairWhereUniqueInput[]
    delete?: BusinessEntityUnitPairWhereUniqueInput | BusinessEntityUnitPairWhereUniqueInput[]
    connect?: BusinessEntityUnitPairWhereUniqueInput | BusinessEntityUnitPairWhereUniqueInput[]
    update?: BusinessEntityUnitPairUpdateWithWhereUniqueWithoutBusinessUnitInput | BusinessEntityUnitPairUpdateWithWhereUniqueWithoutBusinessUnitInput[]
    updateMany?: BusinessEntityUnitPairUpdateManyWithWhereWithoutBusinessUnitInput | BusinessEntityUnitPairUpdateManyWithWhereWithoutBusinessUnitInput[]
    deleteMany?: BusinessEntityUnitPairScalarWhereInput | BusinessEntityUnitPairScalarWhereInput[]
  }

  export type BusinessUnitSalesPairUpdateManyWithoutBusinessUnitNestedInput = {
    create?: XOR<BusinessUnitSalesPairCreateWithoutBusinessUnitInput, BusinessUnitSalesPairUncheckedCreateWithoutBusinessUnitInput> | BusinessUnitSalesPairCreateWithoutBusinessUnitInput[] | BusinessUnitSalesPairUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: BusinessUnitSalesPairCreateOrConnectWithoutBusinessUnitInput | BusinessUnitSalesPairCreateOrConnectWithoutBusinessUnitInput[]
    upsert?: BusinessUnitSalesPairUpsertWithWhereUniqueWithoutBusinessUnitInput | BusinessUnitSalesPairUpsertWithWhereUniqueWithoutBusinessUnitInput[]
    createMany?: BusinessUnitSalesPairCreateManyBusinessUnitInputEnvelope
    set?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    disconnect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    delete?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    connect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    update?: BusinessUnitSalesPairUpdateWithWhereUniqueWithoutBusinessUnitInput | BusinessUnitSalesPairUpdateWithWhereUniqueWithoutBusinessUnitInput[]
    updateMany?: BusinessUnitSalesPairUpdateManyWithWhereWithoutBusinessUnitInput | BusinessUnitSalesPairUpdateManyWithWhereWithoutBusinessUnitInput[]
    deleteMany?: BusinessUnitSalesPairScalarWhereInput | BusinessUnitSalesPairScalarWhereInput[]
  }

  export type BusinessUnitMarketingPairUpdateManyWithoutBusinessUnitNestedInput = {
    create?: XOR<BusinessUnitMarketingPairCreateWithoutBusinessUnitInput, BusinessUnitMarketingPairUncheckedCreateWithoutBusinessUnitInput> | BusinessUnitMarketingPairCreateWithoutBusinessUnitInput[] | BusinessUnitMarketingPairUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: BusinessUnitMarketingPairCreateOrConnectWithoutBusinessUnitInput | BusinessUnitMarketingPairCreateOrConnectWithoutBusinessUnitInput[]
    upsert?: BusinessUnitMarketingPairUpsertWithWhereUniqueWithoutBusinessUnitInput | BusinessUnitMarketingPairUpsertWithWhereUniqueWithoutBusinessUnitInput[]
    createMany?: BusinessUnitMarketingPairCreateManyBusinessUnitInputEnvelope
    set?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    disconnect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    delete?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    connect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    update?: BusinessUnitMarketingPairUpdateWithWhereUniqueWithoutBusinessUnitInput | BusinessUnitMarketingPairUpdateWithWhereUniqueWithoutBusinessUnitInput[]
    updateMany?: BusinessUnitMarketingPairUpdateManyWithWhereWithoutBusinessUnitInput | BusinessUnitMarketingPairUpdateManyWithWhereWithoutBusinessUnitInput[]
    deleteMany?: BusinessUnitMarketingPairScalarWhereInput | BusinessUnitMarketingPairScalarWhereInput[]
  }

  export type BusinessUnitServicePairUpdateManyWithoutBusinessUnitNestedInput = {
    create?: XOR<BusinessUnitServicePairCreateWithoutBusinessUnitInput, BusinessUnitServicePairUncheckedCreateWithoutBusinessUnitInput> | BusinessUnitServicePairCreateWithoutBusinessUnitInput[] | BusinessUnitServicePairUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: BusinessUnitServicePairCreateOrConnectWithoutBusinessUnitInput | BusinessUnitServicePairCreateOrConnectWithoutBusinessUnitInput[]
    upsert?: BusinessUnitServicePairUpsertWithWhereUniqueWithoutBusinessUnitInput | BusinessUnitServicePairUpsertWithWhereUniqueWithoutBusinessUnitInput[]
    createMany?: BusinessUnitServicePairCreateManyBusinessUnitInputEnvelope
    set?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    disconnect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    delete?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    connect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    update?: BusinessUnitServicePairUpdateWithWhereUniqueWithoutBusinessUnitInput | BusinessUnitServicePairUpdateWithWhereUniqueWithoutBusinessUnitInput[]
    updateMany?: BusinessUnitServicePairUpdateManyWithWhereWithoutBusinessUnitInput | BusinessUnitServicePairUpdateManyWithWhereWithoutBusinessUnitInput[]
    deleteMany?: BusinessUnitServicePairScalarWhereInput | BusinessUnitServicePairScalarWhereInput[]
  }

  export type BusinessEntityUnitPairUncheckedUpdateManyWithoutBusinessUnitNestedInput = {
    create?: XOR<BusinessEntityUnitPairCreateWithoutBusinessUnitInput, BusinessEntityUnitPairUncheckedCreateWithoutBusinessUnitInput> | BusinessEntityUnitPairCreateWithoutBusinessUnitInput[] | BusinessEntityUnitPairUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: BusinessEntityUnitPairCreateOrConnectWithoutBusinessUnitInput | BusinessEntityUnitPairCreateOrConnectWithoutBusinessUnitInput[]
    upsert?: BusinessEntityUnitPairUpsertWithWhereUniqueWithoutBusinessUnitInput | BusinessEntityUnitPairUpsertWithWhereUniqueWithoutBusinessUnitInput[]
    createMany?: BusinessEntityUnitPairCreateManyBusinessUnitInputEnvelope
    set?: BusinessEntityUnitPairWhereUniqueInput | BusinessEntityUnitPairWhereUniqueInput[]
    disconnect?: BusinessEntityUnitPairWhereUniqueInput | BusinessEntityUnitPairWhereUniqueInput[]
    delete?: BusinessEntityUnitPairWhereUniqueInput | BusinessEntityUnitPairWhereUniqueInput[]
    connect?: BusinessEntityUnitPairWhereUniqueInput | BusinessEntityUnitPairWhereUniqueInput[]
    update?: BusinessEntityUnitPairUpdateWithWhereUniqueWithoutBusinessUnitInput | BusinessEntityUnitPairUpdateWithWhereUniqueWithoutBusinessUnitInput[]
    updateMany?: BusinessEntityUnitPairUpdateManyWithWhereWithoutBusinessUnitInput | BusinessEntityUnitPairUpdateManyWithWhereWithoutBusinessUnitInput[]
    deleteMany?: BusinessEntityUnitPairScalarWhereInput | BusinessEntityUnitPairScalarWhereInput[]
  }

  export type BusinessUnitSalesPairUncheckedUpdateManyWithoutBusinessUnitNestedInput = {
    create?: XOR<BusinessUnitSalesPairCreateWithoutBusinessUnitInput, BusinessUnitSalesPairUncheckedCreateWithoutBusinessUnitInput> | BusinessUnitSalesPairCreateWithoutBusinessUnitInput[] | BusinessUnitSalesPairUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: BusinessUnitSalesPairCreateOrConnectWithoutBusinessUnitInput | BusinessUnitSalesPairCreateOrConnectWithoutBusinessUnitInput[]
    upsert?: BusinessUnitSalesPairUpsertWithWhereUniqueWithoutBusinessUnitInput | BusinessUnitSalesPairUpsertWithWhereUniqueWithoutBusinessUnitInput[]
    createMany?: BusinessUnitSalesPairCreateManyBusinessUnitInputEnvelope
    set?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    disconnect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    delete?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    connect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    update?: BusinessUnitSalesPairUpdateWithWhereUniqueWithoutBusinessUnitInput | BusinessUnitSalesPairUpdateWithWhereUniqueWithoutBusinessUnitInput[]
    updateMany?: BusinessUnitSalesPairUpdateManyWithWhereWithoutBusinessUnitInput | BusinessUnitSalesPairUpdateManyWithWhereWithoutBusinessUnitInput[]
    deleteMany?: BusinessUnitSalesPairScalarWhereInput | BusinessUnitSalesPairScalarWhereInput[]
  }

  export type BusinessUnitMarketingPairUncheckedUpdateManyWithoutBusinessUnitNestedInput = {
    create?: XOR<BusinessUnitMarketingPairCreateWithoutBusinessUnitInput, BusinessUnitMarketingPairUncheckedCreateWithoutBusinessUnitInput> | BusinessUnitMarketingPairCreateWithoutBusinessUnitInput[] | BusinessUnitMarketingPairUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: BusinessUnitMarketingPairCreateOrConnectWithoutBusinessUnitInput | BusinessUnitMarketingPairCreateOrConnectWithoutBusinessUnitInput[]
    upsert?: BusinessUnitMarketingPairUpsertWithWhereUniqueWithoutBusinessUnitInput | BusinessUnitMarketingPairUpsertWithWhereUniqueWithoutBusinessUnitInput[]
    createMany?: BusinessUnitMarketingPairCreateManyBusinessUnitInputEnvelope
    set?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    disconnect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    delete?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    connect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    update?: BusinessUnitMarketingPairUpdateWithWhereUniqueWithoutBusinessUnitInput | BusinessUnitMarketingPairUpdateWithWhereUniqueWithoutBusinessUnitInput[]
    updateMany?: BusinessUnitMarketingPairUpdateManyWithWhereWithoutBusinessUnitInput | BusinessUnitMarketingPairUpdateManyWithWhereWithoutBusinessUnitInput[]
    deleteMany?: BusinessUnitMarketingPairScalarWhereInput | BusinessUnitMarketingPairScalarWhereInput[]
  }

  export type BusinessUnitServicePairUncheckedUpdateManyWithoutBusinessUnitNestedInput = {
    create?: XOR<BusinessUnitServicePairCreateWithoutBusinessUnitInput, BusinessUnitServicePairUncheckedCreateWithoutBusinessUnitInput> | BusinessUnitServicePairCreateWithoutBusinessUnitInput[] | BusinessUnitServicePairUncheckedCreateWithoutBusinessUnitInput[]
    connectOrCreate?: BusinessUnitServicePairCreateOrConnectWithoutBusinessUnitInput | BusinessUnitServicePairCreateOrConnectWithoutBusinessUnitInput[]
    upsert?: BusinessUnitServicePairUpsertWithWhereUniqueWithoutBusinessUnitInput | BusinessUnitServicePairUpsertWithWhereUniqueWithoutBusinessUnitInput[]
    createMany?: BusinessUnitServicePairCreateManyBusinessUnitInputEnvelope
    set?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    disconnect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    delete?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    connect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    update?: BusinessUnitServicePairUpdateWithWhereUniqueWithoutBusinessUnitInput | BusinessUnitServicePairUpdateWithWhereUniqueWithoutBusinessUnitInput[]
    updateMany?: BusinessUnitServicePairUpdateManyWithWhereWithoutBusinessUnitInput | BusinessUnitServicePairUpdateManyWithWhereWithoutBusinessUnitInput[]
    deleteMany?: BusinessUnitServicePairScalarWhereInput | BusinessUnitServicePairScalarWhereInput[]
  }

  export type BusinessEntityCreateNestedOneWithoutEntityUnitPairsInput = {
    create?: XOR<BusinessEntityCreateWithoutEntityUnitPairsInput, BusinessEntityUncheckedCreateWithoutEntityUnitPairsInput>
    connectOrCreate?: BusinessEntityCreateOrConnectWithoutEntityUnitPairsInput
    connect?: BusinessEntityWhereUniqueInput
  }

  export type BusinessUnitCreateNestedOneWithoutEntityUnitPairsInput = {
    create?: XOR<BusinessUnitCreateWithoutEntityUnitPairsInput, BusinessUnitUncheckedCreateWithoutEntityUnitPairsInput>
    connectOrCreate?: BusinessUnitCreateOrConnectWithoutEntityUnitPairsInput
    connect?: BusinessUnitWhereUniqueInput
  }

  export type BusinessEntityUpdateOneRequiredWithoutEntityUnitPairsNestedInput = {
    create?: XOR<BusinessEntityCreateWithoutEntityUnitPairsInput, BusinessEntityUncheckedCreateWithoutEntityUnitPairsInput>
    connectOrCreate?: BusinessEntityCreateOrConnectWithoutEntityUnitPairsInput
    upsert?: BusinessEntityUpsertWithoutEntityUnitPairsInput
    connect?: BusinessEntityWhereUniqueInput
    update?: XOR<XOR<BusinessEntityUpdateToOneWithWhereWithoutEntityUnitPairsInput, BusinessEntityUpdateWithoutEntityUnitPairsInput>, BusinessEntityUncheckedUpdateWithoutEntityUnitPairsInput>
  }

  export type BusinessUnitUpdateOneRequiredWithoutEntityUnitPairsNestedInput = {
    create?: XOR<BusinessUnitCreateWithoutEntityUnitPairsInput, BusinessUnitUncheckedCreateWithoutEntityUnitPairsInput>
    connectOrCreate?: BusinessUnitCreateOrConnectWithoutEntityUnitPairsInput
    upsert?: BusinessUnitUpsertWithoutEntityUnitPairsInput
    connect?: BusinessUnitWhereUniqueInput
    update?: XOR<XOR<BusinessUnitUpdateToOneWithWhereWithoutEntityUnitPairsInput, BusinessUnitUpdateWithoutEntityUnitPairsInput>, BusinessUnitUncheckedUpdateWithoutEntityUnitPairsInput>
  }

  export type SalesChannelOfficeTeamPairCreateNestedManyWithoutSalesChannelInput = {
    create?: XOR<SalesChannelOfficeTeamPairCreateWithoutSalesChannelInput, SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesChannelInput> | SalesChannelOfficeTeamPairCreateWithoutSalesChannelInput[] | SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesChannelInput[]
    connectOrCreate?: SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesChannelInput | SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesChannelInput[]
    createMany?: SalesChannelOfficeTeamPairCreateManySalesChannelInputEnvelope
    connect?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
  }

  export type BusinessUnitSalesPairCreateNestedManyWithoutSalesChannelInput = {
    create?: XOR<BusinessUnitSalesPairCreateWithoutSalesChannelInput, BusinessUnitSalesPairUncheckedCreateWithoutSalesChannelInput> | BusinessUnitSalesPairCreateWithoutSalesChannelInput[] | BusinessUnitSalesPairUncheckedCreateWithoutSalesChannelInput[]
    connectOrCreate?: BusinessUnitSalesPairCreateOrConnectWithoutSalesChannelInput | BusinessUnitSalesPairCreateOrConnectWithoutSalesChannelInput[]
    createMany?: BusinessUnitSalesPairCreateManySalesChannelInputEnvelope
    connect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
  }

  export type SalesChannelOfficeTeamPairUncheckedCreateNestedManyWithoutSalesChannelInput = {
    create?: XOR<SalesChannelOfficeTeamPairCreateWithoutSalesChannelInput, SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesChannelInput> | SalesChannelOfficeTeamPairCreateWithoutSalesChannelInput[] | SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesChannelInput[]
    connectOrCreate?: SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesChannelInput | SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesChannelInput[]
    createMany?: SalesChannelOfficeTeamPairCreateManySalesChannelInputEnvelope
    connect?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
  }

  export type BusinessUnitSalesPairUncheckedCreateNestedManyWithoutSalesChannelInput = {
    create?: XOR<BusinessUnitSalesPairCreateWithoutSalesChannelInput, BusinessUnitSalesPairUncheckedCreateWithoutSalesChannelInput> | BusinessUnitSalesPairCreateWithoutSalesChannelInput[] | BusinessUnitSalesPairUncheckedCreateWithoutSalesChannelInput[]
    connectOrCreate?: BusinessUnitSalesPairCreateOrConnectWithoutSalesChannelInput | BusinessUnitSalesPairCreateOrConnectWithoutSalesChannelInput[]
    createMany?: BusinessUnitSalesPairCreateManySalesChannelInputEnvelope
    connect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
  }

  export type SalesChannelOfficeTeamPairUpdateManyWithoutSalesChannelNestedInput = {
    create?: XOR<SalesChannelOfficeTeamPairCreateWithoutSalesChannelInput, SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesChannelInput> | SalesChannelOfficeTeamPairCreateWithoutSalesChannelInput[] | SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesChannelInput[]
    connectOrCreate?: SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesChannelInput | SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesChannelInput[]
    upsert?: SalesChannelOfficeTeamPairUpsertWithWhereUniqueWithoutSalesChannelInput | SalesChannelOfficeTeamPairUpsertWithWhereUniqueWithoutSalesChannelInput[]
    createMany?: SalesChannelOfficeTeamPairCreateManySalesChannelInputEnvelope
    set?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    disconnect?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    delete?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    connect?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    update?: SalesChannelOfficeTeamPairUpdateWithWhereUniqueWithoutSalesChannelInput | SalesChannelOfficeTeamPairUpdateWithWhereUniqueWithoutSalesChannelInput[]
    updateMany?: SalesChannelOfficeTeamPairUpdateManyWithWhereWithoutSalesChannelInput | SalesChannelOfficeTeamPairUpdateManyWithWhereWithoutSalesChannelInput[]
    deleteMany?: SalesChannelOfficeTeamPairScalarWhereInput | SalesChannelOfficeTeamPairScalarWhereInput[]
  }

  export type BusinessUnitSalesPairUpdateManyWithoutSalesChannelNestedInput = {
    create?: XOR<BusinessUnitSalesPairCreateWithoutSalesChannelInput, BusinessUnitSalesPairUncheckedCreateWithoutSalesChannelInput> | BusinessUnitSalesPairCreateWithoutSalesChannelInput[] | BusinessUnitSalesPairUncheckedCreateWithoutSalesChannelInput[]
    connectOrCreate?: BusinessUnitSalesPairCreateOrConnectWithoutSalesChannelInput | BusinessUnitSalesPairCreateOrConnectWithoutSalesChannelInput[]
    upsert?: BusinessUnitSalesPairUpsertWithWhereUniqueWithoutSalesChannelInput | BusinessUnitSalesPairUpsertWithWhereUniqueWithoutSalesChannelInput[]
    createMany?: BusinessUnitSalesPairCreateManySalesChannelInputEnvelope
    set?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    disconnect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    delete?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    connect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    update?: BusinessUnitSalesPairUpdateWithWhereUniqueWithoutSalesChannelInput | BusinessUnitSalesPairUpdateWithWhereUniqueWithoutSalesChannelInput[]
    updateMany?: BusinessUnitSalesPairUpdateManyWithWhereWithoutSalesChannelInput | BusinessUnitSalesPairUpdateManyWithWhereWithoutSalesChannelInput[]
    deleteMany?: BusinessUnitSalesPairScalarWhereInput | BusinessUnitSalesPairScalarWhereInput[]
  }

  export type SalesChannelOfficeTeamPairUncheckedUpdateManyWithoutSalesChannelNestedInput = {
    create?: XOR<SalesChannelOfficeTeamPairCreateWithoutSalesChannelInput, SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesChannelInput> | SalesChannelOfficeTeamPairCreateWithoutSalesChannelInput[] | SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesChannelInput[]
    connectOrCreate?: SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesChannelInput | SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesChannelInput[]
    upsert?: SalesChannelOfficeTeamPairUpsertWithWhereUniqueWithoutSalesChannelInput | SalesChannelOfficeTeamPairUpsertWithWhereUniqueWithoutSalesChannelInput[]
    createMany?: SalesChannelOfficeTeamPairCreateManySalesChannelInputEnvelope
    set?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    disconnect?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    delete?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    connect?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    update?: SalesChannelOfficeTeamPairUpdateWithWhereUniqueWithoutSalesChannelInput | SalesChannelOfficeTeamPairUpdateWithWhereUniqueWithoutSalesChannelInput[]
    updateMany?: SalesChannelOfficeTeamPairUpdateManyWithWhereWithoutSalesChannelInput | SalesChannelOfficeTeamPairUpdateManyWithWhereWithoutSalesChannelInput[]
    deleteMany?: SalesChannelOfficeTeamPairScalarWhereInput | SalesChannelOfficeTeamPairScalarWhereInput[]
  }

  export type BusinessUnitSalesPairUncheckedUpdateManyWithoutSalesChannelNestedInput = {
    create?: XOR<BusinessUnitSalesPairCreateWithoutSalesChannelInput, BusinessUnitSalesPairUncheckedCreateWithoutSalesChannelInput> | BusinessUnitSalesPairCreateWithoutSalesChannelInput[] | BusinessUnitSalesPairUncheckedCreateWithoutSalesChannelInput[]
    connectOrCreate?: BusinessUnitSalesPairCreateOrConnectWithoutSalesChannelInput | BusinessUnitSalesPairCreateOrConnectWithoutSalesChannelInput[]
    upsert?: BusinessUnitSalesPairUpsertWithWhereUniqueWithoutSalesChannelInput | BusinessUnitSalesPairUpsertWithWhereUniqueWithoutSalesChannelInput[]
    createMany?: BusinessUnitSalesPairCreateManySalesChannelInputEnvelope
    set?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    disconnect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    delete?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    connect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    update?: BusinessUnitSalesPairUpdateWithWhereUniqueWithoutSalesChannelInput | BusinessUnitSalesPairUpdateWithWhereUniqueWithoutSalesChannelInput[]
    updateMany?: BusinessUnitSalesPairUpdateManyWithWhereWithoutSalesChannelInput | BusinessUnitSalesPairUpdateManyWithWhereWithoutSalesChannelInput[]
    deleteMany?: BusinessUnitSalesPairScalarWhereInput | BusinessUnitSalesPairScalarWhereInput[]
  }

  export type SalesChannelOfficeTeamPairCreateNestedManyWithoutSalesOfficeInput = {
    create?: XOR<SalesChannelOfficeTeamPairCreateWithoutSalesOfficeInput, SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesOfficeInput> | SalesChannelOfficeTeamPairCreateWithoutSalesOfficeInput[] | SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesOfficeInput[]
    connectOrCreate?: SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesOfficeInput | SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesOfficeInput[]
    createMany?: SalesChannelOfficeTeamPairCreateManySalesOfficeInputEnvelope
    connect?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
  }

  export type BusinessUnitSalesPairCreateNestedManyWithoutSalesOfficeInput = {
    create?: XOR<BusinessUnitSalesPairCreateWithoutSalesOfficeInput, BusinessUnitSalesPairUncheckedCreateWithoutSalesOfficeInput> | BusinessUnitSalesPairCreateWithoutSalesOfficeInput[] | BusinessUnitSalesPairUncheckedCreateWithoutSalesOfficeInput[]
    connectOrCreate?: BusinessUnitSalesPairCreateOrConnectWithoutSalesOfficeInput | BusinessUnitSalesPairCreateOrConnectWithoutSalesOfficeInput[]
    createMany?: BusinessUnitSalesPairCreateManySalesOfficeInputEnvelope
    connect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
  }

  export type SalesChannelOfficeTeamPairUncheckedCreateNestedManyWithoutSalesOfficeInput = {
    create?: XOR<SalesChannelOfficeTeamPairCreateWithoutSalesOfficeInput, SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesOfficeInput> | SalesChannelOfficeTeamPairCreateWithoutSalesOfficeInput[] | SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesOfficeInput[]
    connectOrCreate?: SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesOfficeInput | SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesOfficeInput[]
    createMany?: SalesChannelOfficeTeamPairCreateManySalesOfficeInputEnvelope
    connect?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
  }

  export type BusinessUnitSalesPairUncheckedCreateNestedManyWithoutSalesOfficeInput = {
    create?: XOR<BusinessUnitSalesPairCreateWithoutSalesOfficeInput, BusinessUnitSalesPairUncheckedCreateWithoutSalesOfficeInput> | BusinessUnitSalesPairCreateWithoutSalesOfficeInput[] | BusinessUnitSalesPairUncheckedCreateWithoutSalesOfficeInput[]
    connectOrCreate?: BusinessUnitSalesPairCreateOrConnectWithoutSalesOfficeInput | BusinessUnitSalesPairCreateOrConnectWithoutSalesOfficeInput[]
    createMany?: BusinessUnitSalesPairCreateManySalesOfficeInputEnvelope
    connect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
  }

  export type SalesChannelOfficeTeamPairUpdateManyWithoutSalesOfficeNestedInput = {
    create?: XOR<SalesChannelOfficeTeamPairCreateWithoutSalesOfficeInput, SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesOfficeInput> | SalesChannelOfficeTeamPairCreateWithoutSalesOfficeInput[] | SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesOfficeInput[]
    connectOrCreate?: SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesOfficeInput | SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesOfficeInput[]
    upsert?: SalesChannelOfficeTeamPairUpsertWithWhereUniqueWithoutSalesOfficeInput | SalesChannelOfficeTeamPairUpsertWithWhereUniqueWithoutSalesOfficeInput[]
    createMany?: SalesChannelOfficeTeamPairCreateManySalesOfficeInputEnvelope
    set?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    disconnect?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    delete?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    connect?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    update?: SalesChannelOfficeTeamPairUpdateWithWhereUniqueWithoutSalesOfficeInput | SalesChannelOfficeTeamPairUpdateWithWhereUniqueWithoutSalesOfficeInput[]
    updateMany?: SalesChannelOfficeTeamPairUpdateManyWithWhereWithoutSalesOfficeInput | SalesChannelOfficeTeamPairUpdateManyWithWhereWithoutSalesOfficeInput[]
    deleteMany?: SalesChannelOfficeTeamPairScalarWhereInput | SalesChannelOfficeTeamPairScalarWhereInput[]
  }

  export type BusinessUnitSalesPairUpdateManyWithoutSalesOfficeNestedInput = {
    create?: XOR<BusinessUnitSalesPairCreateWithoutSalesOfficeInput, BusinessUnitSalesPairUncheckedCreateWithoutSalesOfficeInput> | BusinessUnitSalesPairCreateWithoutSalesOfficeInput[] | BusinessUnitSalesPairUncheckedCreateWithoutSalesOfficeInput[]
    connectOrCreate?: BusinessUnitSalesPairCreateOrConnectWithoutSalesOfficeInput | BusinessUnitSalesPairCreateOrConnectWithoutSalesOfficeInput[]
    upsert?: BusinessUnitSalesPairUpsertWithWhereUniqueWithoutSalesOfficeInput | BusinessUnitSalesPairUpsertWithWhereUniqueWithoutSalesOfficeInput[]
    createMany?: BusinessUnitSalesPairCreateManySalesOfficeInputEnvelope
    set?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    disconnect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    delete?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    connect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    update?: BusinessUnitSalesPairUpdateWithWhereUniqueWithoutSalesOfficeInput | BusinessUnitSalesPairUpdateWithWhereUniqueWithoutSalesOfficeInput[]
    updateMany?: BusinessUnitSalesPairUpdateManyWithWhereWithoutSalesOfficeInput | BusinessUnitSalesPairUpdateManyWithWhereWithoutSalesOfficeInput[]
    deleteMany?: BusinessUnitSalesPairScalarWhereInput | BusinessUnitSalesPairScalarWhereInput[]
  }

  export type SalesChannelOfficeTeamPairUncheckedUpdateManyWithoutSalesOfficeNestedInput = {
    create?: XOR<SalesChannelOfficeTeamPairCreateWithoutSalesOfficeInput, SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesOfficeInput> | SalesChannelOfficeTeamPairCreateWithoutSalesOfficeInput[] | SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesOfficeInput[]
    connectOrCreate?: SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesOfficeInput | SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesOfficeInput[]
    upsert?: SalesChannelOfficeTeamPairUpsertWithWhereUniqueWithoutSalesOfficeInput | SalesChannelOfficeTeamPairUpsertWithWhereUniqueWithoutSalesOfficeInput[]
    createMany?: SalesChannelOfficeTeamPairCreateManySalesOfficeInputEnvelope
    set?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    disconnect?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    delete?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    connect?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    update?: SalesChannelOfficeTeamPairUpdateWithWhereUniqueWithoutSalesOfficeInput | SalesChannelOfficeTeamPairUpdateWithWhereUniqueWithoutSalesOfficeInput[]
    updateMany?: SalesChannelOfficeTeamPairUpdateManyWithWhereWithoutSalesOfficeInput | SalesChannelOfficeTeamPairUpdateManyWithWhereWithoutSalesOfficeInput[]
    deleteMany?: SalesChannelOfficeTeamPairScalarWhereInput | SalesChannelOfficeTeamPairScalarWhereInput[]
  }

  export type BusinessUnitSalesPairUncheckedUpdateManyWithoutSalesOfficeNestedInput = {
    create?: XOR<BusinessUnitSalesPairCreateWithoutSalesOfficeInput, BusinessUnitSalesPairUncheckedCreateWithoutSalesOfficeInput> | BusinessUnitSalesPairCreateWithoutSalesOfficeInput[] | BusinessUnitSalesPairUncheckedCreateWithoutSalesOfficeInput[]
    connectOrCreate?: BusinessUnitSalesPairCreateOrConnectWithoutSalesOfficeInput | BusinessUnitSalesPairCreateOrConnectWithoutSalesOfficeInput[]
    upsert?: BusinessUnitSalesPairUpsertWithWhereUniqueWithoutSalesOfficeInput | BusinessUnitSalesPairUpsertWithWhereUniqueWithoutSalesOfficeInput[]
    createMany?: BusinessUnitSalesPairCreateManySalesOfficeInputEnvelope
    set?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    disconnect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    delete?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    connect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    update?: BusinessUnitSalesPairUpdateWithWhereUniqueWithoutSalesOfficeInput | BusinessUnitSalesPairUpdateWithWhereUniqueWithoutSalesOfficeInput[]
    updateMany?: BusinessUnitSalesPairUpdateManyWithWhereWithoutSalesOfficeInput | BusinessUnitSalesPairUpdateManyWithWhereWithoutSalesOfficeInput[]
    deleteMany?: BusinessUnitSalesPairScalarWhereInput | BusinessUnitSalesPairScalarWhereInput[]
  }

  export type SalesChannelOfficeTeamPairCreateNestedManyWithoutSalesTeamInput = {
    create?: XOR<SalesChannelOfficeTeamPairCreateWithoutSalesTeamInput, SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesTeamInput> | SalesChannelOfficeTeamPairCreateWithoutSalesTeamInput[] | SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesTeamInput[]
    connectOrCreate?: SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesTeamInput | SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesTeamInput[]
    createMany?: SalesChannelOfficeTeamPairCreateManySalesTeamInputEnvelope
    connect?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
  }

  export type BusinessUnitSalesPairCreateNestedManyWithoutSalesTeamInput = {
    create?: XOR<BusinessUnitSalesPairCreateWithoutSalesTeamInput, BusinessUnitSalesPairUncheckedCreateWithoutSalesTeamInput> | BusinessUnitSalesPairCreateWithoutSalesTeamInput[] | BusinessUnitSalesPairUncheckedCreateWithoutSalesTeamInput[]
    connectOrCreate?: BusinessUnitSalesPairCreateOrConnectWithoutSalesTeamInput | BusinessUnitSalesPairCreateOrConnectWithoutSalesTeamInput[]
    createMany?: BusinessUnitSalesPairCreateManySalesTeamInputEnvelope
    connect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
  }

  export type SalesChannelOfficeTeamPairUncheckedCreateNestedManyWithoutSalesTeamInput = {
    create?: XOR<SalesChannelOfficeTeamPairCreateWithoutSalesTeamInput, SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesTeamInput> | SalesChannelOfficeTeamPairCreateWithoutSalesTeamInput[] | SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesTeamInput[]
    connectOrCreate?: SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesTeamInput | SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesTeamInput[]
    createMany?: SalesChannelOfficeTeamPairCreateManySalesTeamInputEnvelope
    connect?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
  }

  export type BusinessUnitSalesPairUncheckedCreateNestedManyWithoutSalesTeamInput = {
    create?: XOR<BusinessUnitSalesPairCreateWithoutSalesTeamInput, BusinessUnitSalesPairUncheckedCreateWithoutSalesTeamInput> | BusinessUnitSalesPairCreateWithoutSalesTeamInput[] | BusinessUnitSalesPairUncheckedCreateWithoutSalesTeamInput[]
    connectOrCreate?: BusinessUnitSalesPairCreateOrConnectWithoutSalesTeamInput | BusinessUnitSalesPairCreateOrConnectWithoutSalesTeamInput[]
    createMany?: BusinessUnitSalesPairCreateManySalesTeamInputEnvelope
    connect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
  }

  export type SalesChannelOfficeTeamPairUpdateManyWithoutSalesTeamNestedInput = {
    create?: XOR<SalesChannelOfficeTeamPairCreateWithoutSalesTeamInput, SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesTeamInput> | SalesChannelOfficeTeamPairCreateWithoutSalesTeamInput[] | SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesTeamInput[]
    connectOrCreate?: SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesTeamInput | SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesTeamInput[]
    upsert?: SalesChannelOfficeTeamPairUpsertWithWhereUniqueWithoutSalesTeamInput | SalesChannelOfficeTeamPairUpsertWithWhereUniqueWithoutSalesTeamInput[]
    createMany?: SalesChannelOfficeTeamPairCreateManySalesTeamInputEnvelope
    set?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    disconnect?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    delete?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    connect?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    update?: SalesChannelOfficeTeamPairUpdateWithWhereUniqueWithoutSalesTeamInput | SalesChannelOfficeTeamPairUpdateWithWhereUniqueWithoutSalesTeamInput[]
    updateMany?: SalesChannelOfficeTeamPairUpdateManyWithWhereWithoutSalesTeamInput | SalesChannelOfficeTeamPairUpdateManyWithWhereWithoutSalesTeamInput[]
    deleteMany?: SalesChannelOfficeTeamPairScalarWhereInput | SalesChannelOfficeTeamPairScalarWhereInput[]
  }

  export type BusinessUnitSalesPairUpdateManyWithoutSalesTeamNestedInput = {
    create?: XOR<BusinessUnitSalesPairCreateWithoutSalesTeamInput, BusinessUnitSalesPairUncheckedCreateWithoutSalesTeamInput> | BusinessUnitSalesPairCreateWithoutSalesTeamInput[] | BusinessUnitSalesPairUncheckedCreateWithoutSalesTeamInput[]
    connectOrCreate?: BusinessUnitSalesPairCreateOrConnectWithoutSalesTeamInput | BusinessUnitSalesPairCreateOrConnectWithoutSalesTeamInput[]
    upsert?: BusinessUnitSalesPairUpsertWithWhereUniqueWithoutSalesTeamInput | BusinessUnitSalesPairUpsertWithWhereUniqueWithoutSalesTeamInput[]
    createMany?: BusinessUnitSalesPairCreateManySalesTeamInputEnvelope
    set?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    disconnect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    delete?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    connect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    update?: BusinessUnitSalesPairUpdateWithWhereUniqueWithoutSalesTeamInput | BusinessUnitSalesPairUpdateWithWhereUniqueWithoutSalesTeamInput[]
    updateMany?: BusinessUnitSalesPairUpdateManyWithWhereWithoutSalesTeamInput | BusinessUnitSalesPairUpdateManyWithWhereWithoutSalesTeamInput[]
    deleteMany?: BusinessUnitSalesPairScalarWhereInput | BusinessUnitSalesPairScalarWhereInput[]
  }

  export type SalesChannelOfficeTeamPairUncheckedUpdateManyWithoutSalesTeamNestedInput = {
    create?: XOR<SalesChannelOfficeTeamPairCreateWithoutSalesTeamInput, SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesTeamInput> | SalesChannelOfficeTeamPairCreateWithoutSalesTeamInput[] | SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesTeamInput[]
    connectOrCreate?: SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesTeamInput | SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesTeamInput[]
    upsert?: SalesChannelOfficeTeamPairUpsertWithWhereUniqueWithoutSalesTeamInput | SalesChannelOfficeTeamPairUpsertWithWhereUniqueWithoutSalesTeamInput[]
    createMany?: SalesChannelOfficeTeamPairCreateManySalesTeamInputEnvelope
    set?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    disconnect?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    delete?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    connect?: SalesChannelOfficeTeamPairWhereUniqueInput | SalesChannelOfficeTeamPairWhereUniqueInput[]
    update?: SalesChannelOfficeTeamPairUpdateWithWhereUniqueWithoutSalesTeamInput | SalesChannelOfficeTeamPairUpdateWithWhereUniqueWithoutSalesTeamInput[]
    updateMany?: SalesChannelOfficeTeamPairUpdateManyWithWhereWithoutSalesTeamInput | SalesChannelOfficeTeamPairUpdateManyWithWhereWithoutSalesTeamInput[]
    deleteMany?: SalesChannelOfficeTeamPairScalarWhereInput | SalesChannelOfficeTeamPairScalarWhereInput[]
  }

  export type BusinessUnitSalesPairUncheckedUpdateManyWithoutSalesTeamNestedInput = {
    create?: XOR<BusinessUnitSalesPairCreateWithoutSalesTeamInput, BusinessUnitSalesPairUncheckedCreateWithoutSalesTeamInput> | BusinessUnitSalesPairCreateWithoutSalesTeamInput[] | BusinessUnitSalesPairUncheckedCreateWithoutSalesTeamInput[]
    connectOrCreate?: BusinessUnitSalesPairCreateOrConnectWithoutSalesTeamInput | BusinessUnitSalesPairCreateOrConnectWithoutSalesTeamInput[]
    upsert?: BusinessUnitSalesPairUpsertWithWhereUniqueWithoutSalesTeamInput | BusinessUnitSalesPairUpsertWithWhereUniqueWithoutSalesTeamInput[]
    createMany?: BusinessUnitSalesPairCreateManySalesTeamInputEnvelope
    set?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    disconnect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    delete?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    connect?: BusinessUnitSalesPairWhereUniqueInput | BusinessUnitSalesPairWhereUniqueInput[]
    update?: BusinessUnitSalesPairUpdateWithWhereUniqueWithoutSalesTeamInput | BusinessUnitSalesPairUpdateWithWhereUniqueWithoutSalesTeamInput[]
    updateMany?: BusinessUnitSalesPairUpdateManyWithWhereWithoutSalesTeamInput | BusinessUnitSalesPairUpdateManyWithWhereWithoutSalesTeamInput[]
    deleteMany?: BusinessUnitSalesPairScalarWhereInput | BusinessUnitSalesPairScalarWhereInput[]
  }

  export type SalesChannelCreateNestedOneWithoutChannelOfficePairsInput = {
    create?: XOR<SalesChannelCreateWithoutChannelOfficePairsInput, SalesChannelUncheckedCreateWithoutChannelOfficePairsInput>
    connectOrCreate?: SalesChannelCreateOrConnectWithoutChannelOfficePairsInput
    connect?: SalesChannelWhereUniqueInput
  }

  export type SalesOfficeCreateNestedOneWithoutOfficeTeamPairsInput = {
    create?: XOR<SalesOfficeCreateWithoutOfficeTeamPairsInput, SalesOfficeUncheckedCreateWithoutOfficeTeamPairsInput>
    connectOrCreate?: SalesOfficeCreateOrConnectWithoutOfficeTeamPairsInput
    connect?: SalesOfficeWhereUniqueInput
  }

  export type SalesTeamCreateNestedOneWithoutOfficeTeamPairsInput = {
    create?: XOR<SalesTeamCreateWithoutOfficeTeamPairsInput, SalesTeamUncheckedCreateWithoutOfficeTeamPairsInput>
    connectOrCreate?: SalesTeamCreateOrConnectWithoutOfficeTeamPairsInput
    connect?: SalesTeamWhereUniqueInput
  }

  export type SalesChannelUpdateOneRequiredWithoutChannelOfficePairsNestedInput = {
    create?: XOR<SalesChannelCreateWithoutChannelOfficePairsInput, SalesChannelUncheckedCreateWithoutChannelOfficePairsInput>
    connectOrCreate?: SalesChannelCreateOrConnectWithoutChannelOfficePairsInput
    upsert?: SalesChannelUpsertWithoutChannelOfficePairsInput
    connect?: SalesChannelWhereUniqueInput
    update?: XOR<XOR<SalesChannelUpdateToOneWithWhereWithoutChannelOfficePairsInput, SalesChannelUpdateWithoutChannelOfficePairsInput>, SalesChannelUncheckedUpdateWithoutChannelOfficePairsInput>
  }

  export type SalesOfficeUpdateOneRequiredWithoutOfficeTeamPairsNestedInput = {
    create?: XOR<SalesOfficeCreateWithoutOfficeTeamPairsInput, SalesOfficeUncheckedCreateWithoutOfficeTeamPairsInput>
    connectOrCreate?: SalesOfficeCreateOrConnectWithoutOfficeTeamPairsInput
    upsert?: SalesOfficeUpsertWithoutOfficeTeamPairsInput
    connect?: SalesOfficeWhereUniqueInput
    update?: XOR<XOR<SalesOfficeUpdateToOneWithWhereWithoutOfficeTeamPairsInput, SalesOfficeUpdateWithoutOfficeTeamPairsInput>, SalesOfficeUncheckedUpdateWithoutOfficeTeamPairsInput>
  }

  export type SalesTeamUpdateOneRequiredWithoutOfficeTeamPairsNestedInput = {
    create?: XOR<SalesTeamCreateWithoutOfficeTeamPairsInput, SalesTeamUncheckedCreateWithoutOfficeTeamPairsInput>
    connectOrCreate?: SalesTeamCreateOrConnectWithoutOfficeTeamPairsInput
    upsert?: SalesTeamUpsertWithoutOfficeTeamPairsInput
    connect?: SalesTeamWhereUniqueInput
    update?: XOR<XOR<SalesTeamUpdateToOneWithWhereWithoutOfficeTeamPairsInput, SalesTeamUpdateWithoutOfficeTeamPairsInput>, SalesTeamUncheckedUpdateWithoutOfficeTeamPairsInput>
  }

  export type MarketingChannelOfficeTeamPairCreateNestedManyWithoutMarketingChannelInput = {
    create?: XOR<MarketingChannelOfficeTeamPairCreateWithoutMarketingChannelInput, MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingChannelInput> | MarketingChannelOfficeTeamPairCreateWithoutMarketingChannelInput[] | MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingChannelInput[]
    connectOrCreate?: MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingChannelInput | MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingChannelInput[]
    createMany?: MarketingChannelOfficeTeamPairCreateManyMarketingChannelInputEnvelope
    connect?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
  }

  export type BusinessUnitMarketingPairCreateNestedManyWithoutMarketingChannelInput = {
    create?: XOR<BusinessUnitMarketingPairCreateWithoutMarketingChannelInput, BusinessUnitMarketingPairUncheckedCreateWithoutMarketingChannelInput> | BusinessUnitMarketingPairCreateWithoutMarketingChannelInput[] | BusinessUnitMarketingPairUncheckedCreateWithoutMarketingChannelInput[]
    connectOrCreate?: BusinessUnitMarketingPairCreateOrConnectWithoutMarketingChannelInput | BusinessUnitMarketingPairCreateOrConnectWithoutMarketingChannelInput[]
    createMany?: BusinessUnitMarketingPairCreateManyMarketingChannelInputEnvelope
    connect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
  }

  export type MarketingChannelOfficeTeamPairUncheckedCreateNestedManyWithoutMarketingChannelInput = {
    create?: XOR<MarketingChannelOfficeTeamPairCreateWithoutMarketingChannelInput, MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingChannelInput> | MarketingChannelOfficeTeamPairCreateWithoutMarketingChannelInput[] | MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingChannelInput[]
    connectOrCreate?: MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingChannelInput | MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingChannelInput[]
    createMany?: MarketingChannelOfficeTeamPairCreateManyMarketingChannelInputEnvelope
    connect?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
  }

  export type BusinessUnitMarketingPairUncheckedCreateNestedManyWithoutMarketingChannelInput = {
    create?: XOR<BusinessUnitMarketingPairCreateWithoutMarketingChannelInput, BusinessUnitMarketingPairUncheckedCreateWithoutMarketingChannelInput> | BusinessUnitMarketingPairCreateWithoutMarketingChannelInput[] | BusinessUnitMarketingPairUncheckedCreateWithoutMarketingChannelInput[]
    connectOrCreate?: BusinessUnitMarketingPairCreateOrConnectWithoutMarketingChannelInput | BusinessUnitMarketingPairCreateOrConnectWithoutMarketingChannelInput[]
    createMany?: BusinessUnitMarketingPairCreateManyMarketingChannelInputEnvelope
    connect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
  }

  export type MarketingChannelOfficeTeamPairUpdateManyWithoutMarketingChannelNestedInput = {
    create?: XOR<MarketingChannelOfficeTeamPairCreateWithoutMarketingChannelInput, MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingChannelInput> | MarketingChannelOfficeTeamPairCreateWithoutMarketingChannelInput[] | MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingChannelInput[]
    connectOrCreate?: MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingChannelInput | MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingChannelInput[]
    upsert?: MarketingChannelOfficeTeamPairUpsertWithWhereUniqueWithoutMarketingChannelInput | MarketingChannelOfficeTeamPairUpsertWithWhereUniqueWithoutMarketingChannelInput[]
    createMany?: MarketingChannelOfficeTeamPairCreateManyMarketingChannelInputEnvelope
    set?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    disconnect?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    delete?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    connect?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    update?: MarketingChannelOfficeTeamPairUpdateWithWhereUniqueWithoutMarketingChannelInput | MarketingChannelOfficeTeamPairUpdateWithWhereUniqueWithoutMarketingChannelInput[]
    updateMany?: MarketingChannelOfficeTeamPairUpdateManyWithWhereWithoutMarketingChannelInput | MarketingChannelOfficeTeamPairUpdateManyWithWhereWithoutMarketingChannelInput[]
    deleteMany?: MarketingChannelOfficeTeamPairScalarWhereInput | MarketingChannelOfficeTeamPairScalarWhereInput[]
  }

  export type BusinessUnitMarketingPairUpdateManyWithoutMarketingChannelNestedInput = {
    create?: XOR<BusinessUnitMarketingPairCreateWithoutMarketingChannelInput, BusinessUnitMarketingPairUncheckedCreateWithoutMarketingChannelInput> | BusinessUnitMarketingPairCreateWithoutMarketingChannelInput[] | BusinessUnitMarketingPairUncheckedCreateWithoutMarketingChannelInput[]
    connectOrCreate?: BusinessUnitMarketingPairCreateOrConnectWithoutMarketingChannelInput | BusinessUnitMarketingPairCreateOrConnectWithoutMarketingChannelInput[]
    upsert?: BusinessUnitMarketingPairUpsertWithWhereUniqueWithoutMarketingChannelInput | BusinessUnitMarketingPairUpsertWithWhereUniqueWithoutMarketingChannelInput[]
    createMany?: BusinessUnitMarketingPairCreateManyMarketingChannelInputEnvelope
    set?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    disconnect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    delete?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    connect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    update?: BusinessUnitMarketingPairUpdateWithWhereUniqueWithoutMarketingChannelInput | BusinessUnitMarketingPairUpdateWithWhereUniqueWithoutMarketingChannelInput[]
    updateMany?: BusinessUnitMarketingPairUpdateManyWithWhereWithoutMarketingChannelInput | BusinessUnitMarketingPairUpdateManyWithWhereWithoutMarketingChannelInput[]
    deleteMany?: BusinessUnitMarketingPairScalarWhereInput | BusinessUnitMarketingPairScalarWhereInput[]
  }

  export type MarketingChannelOfficeTeamPairUncheckedUpdateManyWithoutMarketingChannelNestedInput = {
    create?: XOR<MarketingChannelOfficeTeamPairCreateWithoutMarketingChannelInput, MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingChannelInput> | MarketingChannelOfficeTeamPairCreateWithoutMarketingChannelInput[] | MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingChannelInput[]
    connectOrCreate?: MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingChannelInput | MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingChannelInput[]
    upsert?: MarketingChannelOfficeTeamPairUpsertWithWhereUniqueWithoutMarketingChannelInput | MarketingChannelOfficeTeamPairUpsertWithWhereUniqueWithoutMarketingChannelInput[]
    createMany?: MarketingChannelOfficeTeamPairCreateManyMarketingChannelInputEnvelope
    set?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    disconnect?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    delete?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    connect?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    update?: MarketingChannelOfficeTeamPairUpdateWithWhereUniqueWithoutMarketingChannelInput | MarketingChannelOfficeTeamPairUpdateWithWhereUniqueWithoutMarketingChannelInput[]
    updateMany?: MarketingChannelOfficeTeamPairUpdateManyWithWhereWithoutMarketingChannelInput | MarketingChannelOfficeTeamPairUpdateManyWithWhereWithoutMarketingChannelInput[]
    deleteMany?: MarketingChannelOfficeTeamPairScalarWhereInput | MarketingChannelOfficeTeamPairScalarWhereInput[]
  }

  export type BusinessUnitMarketingPairUncheckedUpdateManyWithoutMarketingChannelNestedInput = {
    create?: XOR<BusinessUnitMarketingPairCreateWithoutMarketingChannelInput, BusinessUnitMarketingPairUncheckedCreateWithoutMarketingChannelInput> | BusinessUnitMarketingPairCreateWithoutMarketingChannelInput[] | BusinessUnitMarketingPairUncheckedCreateWithoutMarketingChannelInput[]
    connectOrCreate?: BusinessUnitMarketingPairCreateOrConnectWithoutMarketingChannelInput | BusinessUnitMarketingPairCreateOrConnectWithoutMarketingChannelInput[]
    upsert?: BusinessUnitMarketingPairUpsertWithWhereUniqueWithoutMarketingChannelInput | BusinessUnitMarketingPairUpsertWithWhereUniqueWithoutMarketingChannelInput[]
    createMany?: BusinessUnitMarketingPairCreateManyMarketingChannelInputEnvelope
    set?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    disconnect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    delete?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    connect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    update?: BusinessUnitMarketingPairUpdateWithWhereUniqueWithoutMarketingChannelInput | BusinessUnitMarketingPairUpdateWithWhereUniqueWithoutMarketingChannelInput[]
    updateMany?: BusinessUnitMarketingPairUpdateManyWithWhereWithoutMarketingChannelInput | BusinessUnitMarketingPairUpdateManyWithWhereWithoutMarketingChannelInput[]
    deleteMany?: BusinessUnitMarketingPairScalarWhereInput | BusinessUnitMarketingPairScalarWhereInput[]
  }

  export type MarketingChannelOfficeTeamPairCreateNestedManyWithoutMarketingOfficeInput = {
    create?: XOR<MarketingChannelOfficeTeamPairCreateWithoutMarketingOfficeInput, MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingOfficeInput> | MarketingChannelOfficeTeamPairCreateWithoutMarketingOfficeInput[] | MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingOfficeInput[]
    connectOrCreate?: MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingOfficeInput | MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingOfficeInput[]
    createMany?: MarketingChannelOfficeTeamPairCreateManyMarketingOfficeInputEnvelope
    connect?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
  }

  export type BusinessUnitMarketingPairCreateNestedManyWithoutMarketingOfficeInput = {
    create?: XOR<BusinessUnitMarketingPairCreateWithoutMarketingOfficeInput, BusinessUnitMarketingPairUncheckedCreateWithoutMarketingOfficeInput> | BusinessUnitMarketingPairCreateWithoutMarketingOfficeInput[] | BusinessUnitMarketingPairUncheckedCreateWithoutMarketingOfficeInput[]
    connectOrCreate?: BusinessUnitMarketingPairCreateOrConnectWithoutMarketingOfficeInput | BusinessUnitMarketingPairCreateOrConnectWithoutMarketingOfficeInput[]
    createMany?: BusinessUnitMarketingPairCreateManyMarketingOfficeInputEnvelope
    connect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
  }

  export type MarketingChannelOfficeTeamPairUncheckedCreateNestedManyWithoutMarketingOfficeInput = {
    create?: XOR<MarketingChannelOfficeTeamPairCreateWithoutMarketingOfficeInput, MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingOfficeInput> | MarketingChannelOfficeTeamPairCreateWithoutMarketingOfficeInput[] | MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingOfficeInput[]
    connectOrCreate?: MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingOfficeInput | MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingOfficeInput[]
    createMany?: MarketingChannelOfficeTeamPairCreateManyMarketingOfficeInputEnvelope
    connect?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
  }

  export type BusinessUnitMarketingPairUncheckedCreateNestedManyWithoutMarketingOfficeInput = {
    create?: XOR<BusinessUnitMarketingPairCreateWithoutMarketingOfficeInput, BusinessUnitMarketingPairUncheckedCreateWithoutMarketingOfficeInput> | BusinessUnitMarketingPairCreateWithoutMarketingOfficeInput[] | BusinessUnitMarketingPairUncheckedCreateWithoutMarketingOfficeInput[]
    connectOrCreate?: BusinessUnitMarketingPairCreateOrConnectWithoutMarketingOfficeInput | BusinessUnitMarketingPairCreateOrConnectWithoutMarketingOfficeInput[]
    createMany?: BusinessUnitMarketingPairCreateManyMarketingOfficeInputEnvelope
    connect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
  }

  export type MarketingChannelOfficeTeamPairUpdateManyWithoutMarketingOfficeNestedInput = {
    create?: XOR<MarketingChannelOfficeTeamPairCreateWithoutMarketingOfficeInput, MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingOfficeInput> | MarketingChannelOfficeTeamPairCreateWithoutMarketingOfficeInput[] | MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingOfficeInput[]
    connectOrCreate?: MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingOfficeInput | MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingOfficeInput[]
    upsert?: MarketingChannelOfficeTeamPairUpsertWithWhereUniqueWithoutMarketingOfficeInput | MarketingChannelOfficeTeamPairUpsertWithWhereUniqueWithoutMarketingOfficeInput[]
    createMany?: MarketingChannelOfficeTeamPairCreateManyMarketingOfficeInputEnvelope
    set?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    disconnect?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    delete?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    connect?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    update?: MarketingChannelOfficeTeamPairUpdateWithWhereUniqueWithoutMarketingOfficeInput | MarketingChannelOfficeTeamPairUpdateWithWhereUniqueWithoutMarketingOfficeInput[]
    updateMany?: MarketingChannelOfficeTeamPairUpdateManyWithWhereWithoutMarketingOfficeInput | MarketingChannelOfficeTeamPairUpdateManyWithWhereWithoutMarketingOfficeInput[]
    deleteMany?: MarketingChannelOfficeTeamPairScalarWhereInput | MarketingChannelOfficeTeamPairScalarWhereInput[]
  }

  export type BusinessUnitMarketingPairUpdateManyWithoutMarketingOfficeNestedInput = {
    create?: XOR<BusinessUnitMarketingPairCreateWithoutMarketingOfficeInput, BusinessUnitMarketingPairUncheckedCreateWithoutMarketingOfficeInput> | BusinessUnitMarketingPairCreateWithoutMarketingOfficeInput[] | BusinessUnitMarketingPairUncheckedCreateWithoutMarketingOfficeInput[]
    connectOrCreate?: BusinessUnitMarketingPairCreateOrConnectWithoutMarketingOfficeInput | BusinessUnitMarketingPairCreateOrConnectWithoutMarketingOfficeInput[]
    upsert?: BusinessUnitMarketingPairUpsertWithWhereUniqueWithoutMarketingOfficeInput | BusinessUnitMarketingPairUpsertWithWhereUniqueWithoutMarketingOfficeInput[]
    createMany?: BusinessUnitMarketingPairCreateManyMarketingOfficeInputEnvelope
    set?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    disconnect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    delete?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    connect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    update?: BusinessUnitMarketingPairUpdateWithWhereUniqueWithoutMarketingOfficeInput | BusinessUnitMarketingPairUpdateWithWhereUniqueWithoutMarketingOfficeInput[]
    updateMany?: BusinessUnitMarketingPairUpdateManyWithWhereWithoutMarketingOfficeInput | BusinessUnitMarketingPairUpdateManyWithWhereWithoutMarketingOfficeInput[]
    deleteMany?: BusinessUnitMarketingPairScalarWhereInput | BusinessUnitMarketingPairScalarWhereInput[]
  }

  export type MarketingChannelOfficeTeamPairUncheckedUpdateManyWithoutMarketingOfficeNestedInput = {
    create?: XOR<MarketingChannelOfficeTeamPairCreateWithoutMarketingOfficeInput, MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingOfficeInput> | MarketingChannelOfficeTeamPairCreateWithoutMarketingOfficeInput[] | MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingOfficeInput[]
    connectOrCreate?: MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingOfficeInput | MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingOfficeInput[]
    upsert?: MarketingChannelOfficeTeamPairUpsertWithWhereUniqueWithoutMarketingOfficeInput | MarketingChannelOfficeTeamPairUpsertWithWhereUniqueWithoutMarketingOfficeInput[]
    createMany?: MarketingChannelOfficeTeamPairCreateManyMarketingOfficeInputEnvelope
    set?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    disconnect?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    delete?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    connect?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    update?: MarketingChannelOfficeTeamPairUpdateWithWhereUniqueWithoutMarketingOfficeInput | MarketingChannelOfficeTeamPairUpdateWithWhereUniqueWithoutMarketingOfficeInput[]
    updateMany?: MarketingChannelOfficeTeamPairUpdateManyWithWhereWithoutMarketingOfficeInput | MarketingChannelOfficeTeamPairUpdateManyWithWhereWithoutMarketingOfficeInput[]
    deleteMany?: MarketingChannelOfficeTeamPairScalarWhereInput | MarketingChannelOfficeTeamPairScalarWhereInput[]
  }

  export type BusinessUnitMarketingPairUncheckedUpdateManyWithoutMarketingOfficeNestedInput = {
    create?: XOR<BusinessUnitMarketingPairCreateWithoutMarketingOfficeInput, BusinessUnitMarketingPairUncheckedCreateWithoutMarketingOfficeInput> | BusinessUnitMarketingPairCreateWithoutMarketingOfficeInput[] | BusinessUnitMarketingPairUncheckedCreateWithoutMarketingOfficeInput[]
    connectOrCreate?: BusinessUnitMarketingPairCreateOrConnectWithoutMarketingOfficeInput | BusinessUnitMarketingPairCreateOrConnectWithoutMarketingOfficeInput[]
    upsert?: BusinessUnitMarketingPairUpsertWithWhereUniqueWithoutMarketingOfficeInput | BusinessUnitMarketingPairUpsertWithWhereUniqueWithoutMarketingOfficeInput[]
    createMany?: BusinessUnitMarketingPairCreateManyMarketingOfficeInputEnvelope
    set?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    disconnect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    delete?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    connect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    update?: BusinessUnitMarketingPairUpdateWithWhereUniqueWithoutMarketingOfficeInput | BusinessUnitMarketingPairUpdateWithWhereUniqueWithoutMarketingOfficeInput[]
    updateMany?: BusinessUnitMarketingPairUpdateManyWithWhereWithoutMarketingOfficeInput | BusinessUnitMarketingPairUpdateManyWithWhereWithoutMarketingOfficeInput[]
    deleteMany?: BusinessUnitMarketingPairScalarWhereInput | BusinessUnitMarketingPairScalarWhereInput[]
  }

  export type MarketingChannelOfficeTeamPairCreateNestedManyWithoutMarketingTeamInput = {
    create?: XOR<MarketingChannelOfficeTeamPairCreateWithoutMarketingTeamInput, MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingTeamInput> | MarketingChannelOfficeTeamPairCreateWithoutMarketingTeamInput[] | MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingTeamInput[]
    connectOrCreate?: MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingTeamInput | MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingTeamInput[]
    createMany?: MarketingChannelOfficeTeamPairCreateManyMarketingTeamInputEnvelope
    connect?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
  }

  export type BusinessUnitMarketingPairCreateNestedManyWithoutMarketingTeamInput = {
    create?: XOR<BusinessUnitMarketingPairCreateWithoutMarketingTeamInput, BusinessUnitMarketingPairUncheckedCreateWithoutMarketingTeamInput> | BusinessUnitMarketingPairCreateWithoutMarketingTeamInput[] | BusinessUnitMarketingPairUncheckedCreateWithoutMarketingTeamInput[]
    connectOrCreate?: BusinessUnitMarketingPairCreateOrConnectWithoutMarketingTeamInput | BusinessUnitMarketingPairCreateOrConnectWithoutMarketingTeamInput[]
    createMany?: BusinessUnitMarketingPairCreateManyMarketingTeamInputEnvelope
    connect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
  }

  export type MarketingChannelOfficeTeamPairUncheckedCreateNestedManyWithoutMarketingTeamInput = {
    create?: XOR<MarketingChannelOfficeTeamPairCreateWithoutMarketingTeamInput, MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingTeamInput> | MarketingChannelOfficeTeamPairCreateWithoutMarketingTeamInput[] | MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingTeamInput[]
    connectOrCreate?: MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingTeamInput | MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingTeamInput[]
    createMany?: MarketingChannelOfficeTeamPairCreateManyMarketingTeamInputEnvelope
    connect?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
  }

  export type BusinessUnitMarketingPairUncheckedCreateNestedManyWithoutMarketingTeamInput = {
    create?: XOR<BusinessUnitMarketingPairCreateWithoutMarketingTeamInput, BusinessUnitMarketingPairUncheckedCreateWithoutMarketingTeamInput> | BusinessUnitMarketingPairCreateWithoutMarketingTeamInput[] | BusinessUnitMarketingPairUncheckedCreateWithoutMarketingTeamInput[]
    connectOrCreate?: BusinessUnitMarketingPairCreateOrConnectWithoutMarketingTeamInput | BusinessUnitMarketingPairCreateOrConnectWithoutMarketingTeamInput[]
    createMany?: BusinessUnitMarketingPairCreateManyMarketingTeamInputEnvelope
    connect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
  }

  export type MarketingChannelOfficeTeamPairUpdateManyWithoutMarketingTeamNestedInput = {
    create?: XOR<MarketingChannelOfficeTeamPairCreateWithoutMarketingTeamInput, MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingTeamInput> | MarketingChannelOfficeTeamPairCreateWithoutMarketingTeamInput[] | MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingTeamInput[]
    connectOrCreate?: MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingTeamInput | MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingTeamInput[]
    upsert?: MarketingChannelOfficeTeamPairUpsertWithWhereUniqueWithoutMarketingTeamInput | MarketingChannelOfficeTeamPairUpsertWithWhereUniqueWithoutMarketingTeamInput[]
    createMany?: MarketingChannelOfficeTeamPairCreateManyMarketingTeamInputEnvelope
    set?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    disconnect?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    delete?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    connect?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    update?: MarketingChannelOfficeTeamPairUpdateWithWhereUniqueWithoutMarketingTeamInput | MarketingChannelOfficeTeamPairUpdateWithWhereUniqueWithoutMarketingTeamInput[]
    updateMany?: MarketingChannelOfficeTeamPairUpdateManyWithWhereWithoutMarketingTeamInput | MarketingChannelOfficeTeamPairUpdateManyWithWhereWithoutMarketingTeamInput[]
    deleteMany?: MarketingChannelOfficeTeamPairScalarWhereInput | MarketingChannelOfficeTeamPairScalarWhereInput[]
  }

  export type BusinessUnitMarketingPairUpdateManyWithoutMarketingTeamNestedInput = {
    create?: XOR<BusinessUnitMarketingPairCreateWithoutMarketingTeamInput, BusinessUnitMarketingPairUncheckedCreateWithoutMarketingTeamInput> | BusinessUnitMarketingPairCreateWithoutMarketingTeamInput[] | BusinessUnitMarketingPairUncheckedCreateWithoutMarketingTeamInput[]
    connectOrCreate?: BusinessUnitMarketingPairCreateOrConnectWithoutMarketingTeamInput | BusinessUnitMarketingPairCreateOrConnectWithoutMarketingTeamInput[]
    upsert?: BusinessUnitMarketingPairUpsertWithWhereUniqueWithoutMarketingTeamInput | BusinessUnitMarketingPairUpsertWithWhereUniqueWithoutMarketingTeamInput[]
    createMany?: BusinessUnitMarketingPairCreateManyMarketingTeamInputEnvelope
    set?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    disconnect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    delete?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    connect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    update?: BusinessUnitMarketingPairUpdateWithWhereUniqueWithoutMarketingTeamInput | BusinessUnitMarketingPairUpdateWithWhereUniqueWithoutMarketingTeamInput[]
    updateMany?: BusinessUnitMarketingPairUpdateManyWithWhereWithoutMarketingTeamInput | BusinessUnitMarketingPairUpdateManyWithWhereWithoutMarketingTeamInput[]
    deleteMany?: BusinessUnitMarketingPairScalarWhereInput | BusinessUnitMarketingPairScalarWhereInput[]
  }

  export type MarketingChannelOfficeTeamPairUncheckedUpdateManyWithoutMarketingTeamNestedInput = {
    create?: XOR<MarketingChannelOfficeTeamPairCreateWithoutMarketingTeamInput, MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingTeamInput> | MarketingChannelOfficeTeamPairCreateWithoutMarketingTeamInput[] | MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingTeamInput[]
    connectOrCreate?: MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingTeamInput | MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingTeamInput[]
    upsert?: MarketingChannelOfficeTeamPairUpsertWithWhereUniqueWithoutMarketingTeamInput | MarketingChannelOfficeTeamPairUpsertWithWhereUniqueWithoutMarketingTeamInput[]
    createMany?: MarketingChannelOfficeTeamPairCreateManyMarketingTeamInputEnvelope
    set?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    disconnect?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    delete?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    connect?: MarketingChannelOfficeTeamPairWhereUniqueInput | MarketingChannelOfficeTeamPairWhereUniqueInput[]
    update?: MarketingChannelOfficeTeamPairUpdateWithWhereUniqueWithoutMarketingTeamInput | MarketingChannelOfficeTeamPairUpdateWithWhereUniqueWithoutMarketingTeamInput[]
    updateMany?: MarketingChannelOfficeTeamPairUpdateManyWithWhereWithoutMarketingTeamInput | MarketingChannelOfficeTeamPairUpdateManyWithWhereWithoutMarketingTeamInput[]
    deleteMany?: MarketingChannelOfficeTeamPairScalarWhereInput | MarketingChannelOfficeTeamPairScalarWhereInput[]
  }

  export type BusinessUnitMarketingPairUncheckedUpdateManyWithoutMarketingTeamNestedInput = {
    create?: XOR<BusinessUnitMarketingPairCreateWithoutMarketingTeamInput, BusinessUnitMarketingPairUncheckedCreateWithoutMarketingTeamInput> | BusinessUnitMarketingPairCreateWithoutMarketingTeamInput[] | BusinessUnitMarketingPairUncheckedCreateWithoutMarketingTeamInput[]
    connectOrCreate?: BusinessUnitMarketingPairCreateOrConnectWithoutMarketingTeamInput | BusinessUnitMarketingPairCreateOrConnectWithoutMarketingTeamInput[]
    upsert?: BusinessUnitMarketingPairUpsertWithWhereUniqueWithoutMarketingTeamInput | BusinessUnitMarketingPairUpsertWithWhereUniqueWithoutMarketingTeamInput[]
    createMany?: BusinessUnitMarketingPairCreateManyMarketingTeamInputEnvelope
    set?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    disconnect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    delete?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    connect?: BusinessUnitMarketingPairWhereUniqueInput | BusinessUnitMarketingPairWhereUniqueInput[]
    update?: BusinessUnitMarketingPairUpdateWithWhereUniqueWithoutMarketingTeamInput | BusinessUnitMarketingPairUpdateWithWhereUniqueWithoutMarketingTeamInput[]
    updateMany?: BusinessUnitMarketingPairUpdateManyWithWhereWithoutMarketingTeamInput | BusinessUnitMarketingPairUpdateManyWithWhereWithoutMarketingTeamInput[]
    deleteMany?: BusinessUnitMarketingPairScalarWhereInput | BusinessUnitMarketingPairScalarWhereInput[]
  }

  export type MarketingChannelCreateNestedOneWithoutChannelOfficePairsInput = {
    create?: XOR<MarketingChannelCreateWithoutChannelOfficePairsInput, MarketingChannelUncheckedCreateWithoutChannelOfficePairsInput>
    connectOrCreate?: MarketingChannelCreateOrConnectWithoutChannelOfficePairsInput
    connect?: MarketingChannelWhereUniqueInput
  }

  export type MarketingOfficeCreateNestedOneWithoutOfficeTeamPairsInput = {
    create?: XOR<MarketingOfficeCreateWithoutOfficeTeamPairsInput, MarketingOfficeUncheckedCreateWithoutOfficeTeamPairsInput>
    connectOrCreate?: MarketingOfficeCreateOrConnectWithoutOfficeTeamPairsInput
    connect?: MarketingOfficeWhereUniqueInput
  }

  export type MarketingTeamCreateNestedOneWithoutOfficeTeamPairsInput = {
    create?: XOR<MarketingTeamCreateWithoutOfficeTeamPairsInput, MarketingTeamUncheckedCreateWithoutOfficeTeamPairsInput>
    connectOrCreate?: MarketingTeamCreateOrConnectWithoutOfficeTeamPairsInput
    connect?: MarketingTeamWhereUniqueInput
  }

  export type MarketingChannelUpdateOneRequiredWithoutChannelOfficePairsNestedInput = {
    create?: XOR<MarketingChannelCreateWithoutChannelOfficePairsInput, MarketingChannelUncheckedCreateWithoutChannelOfficePairsInput>
    connectOrCreate?: MarketingChannelCreateOrConnectWithoutChannelOfficePairsInput
    upsert?: MarketingChannelUpsertWithoutChannelOfficePairsInput
    connect?: MarketingChannelWhereUniqueInput
    update?: XOR<XOR<MarketingChannelUpdateToOneWithWhereWithoutChannelOfficePairsInput, MarketingChannelUpdateWithoutChannelOfficePairsInput>, MarketingChannelUncheckedUpdateWithoutChannelOfficePairsInput>
  }

  export type MarketingOfficeUpdateOneRequiredWithoutOfficeTeamPairsNestedInput = {
    create?: XOR<MarketingOfficeCreateWithoutOfficeTeamPairsInput, MarketingOfficeUncheckedCreateWithoutOfficeTeamPairsInput>
    connectOrCreate?: MarketingOfficeCreateOrConnectWithoutOfficeTeamPairsInput
    upsert?: MarketingOfficeUpsertWithoutOfficeTeamPairsInput
    connect?: MarketingOfficeWhereUniqueInput
    update?: XOR<XOR<MarketingOfficeUpdateToOneWithWhereWithoutOfficeTeamPairsInput, MarketingOfficeUpdateWithoutOfficeTeamPairsInput>, MarketingOfficeUncheckedUpdateWithoutOfficeTeamPairsInput>
  }

  export type MarketingTeamUpdateOneRequiredWithoutOfficeTeamPairsNestedInput = {
    create?: XOR<MarketingTeamCreateWithoutOfficeTeamPairsInput, MarketingTeamUncheckedCreateWithoutOfficeTeamPairsInput>
    connectOrCreate?: MarketingTeamCreateOrConnectWithoutOfficeTeamPairsInput
    upsert?: MarketingTeamUpsertWithoutOfficeTeamPairsInput
    connect?: MarketingTeamWhereUniqueInput
    update?: XOR<XOR<MarketingTeamUpdateToOneWithWhereWithoutOfficeTeamPairsInput, MarketingTeamUpdateWithoutOfficeTeamPairsInput>, MarketingTeamUncheckedUpdateWithoutOfficeTeamPairsInput>
  }

  export type ServiceChannelOfficeTeamPairCreateNestedManyWithoutServiceChannelInput = {
    create?: XOR<ServiceChannelOfficeTeamPairCreateWithoutServiceChannelInput, ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceChannelInput> | ServiceChannelOfficeTeamPairCreateWithoutServiceChannelInput[] | ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceChannelInput[]
    connectOrCreate?: ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceChannelInput | ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceChannelInput[]
    createMany?: ServiceChannelOfficeTeamPairCreateManyServiceChannelInputEnvelope
    connect?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
  }

  export type BusinessUnitServicePairCreateNestedManyWithoutServiceChannelInput = {
    create?: XOR<BusinessUnitServicePairCreateWithoutServiceChannelInput, BusinessUnitServicePairUncheckedCreateWithoutServiceChannelInput> | BusinessUnitServicePairCreateWithoutServiceChannelInput[] | BusinessUnitServicePairUncheckedCreateWithoutServiceChannelInput[]
    connectOrCreate?: BusinessUnitServicePairCreateOrConnectWithoutServiceChannelInput | BusinessUnitServicePairCreateOrConnectWithoutServiceChannelInput[]
    createMany?: BusinessUnitServicePairCreateManyServiceChannelInputEnvelope
    connect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
  }

  export type ServiceChannelOfficeTeamPairUncheckedCreateNestedManyWithoutServiceChannelInput = {
    create?: XOR<ServiceChannelOfficeTeamPairCreateWithoutServiceChannelInput, ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceChannelInput> | ServiceChannelOfficeTeamPairCreateWithoutServiceChannelInput[] | ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceChannelInput[]
    connectOrCreate?: ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceChannelInput | ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceChannelInput[]
    createMany?: ServiceChannelOfficeTeamPairCreateManyServiceChannelInputEnvelope
    connect?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
  }

  export type BusinessUnitServicePairUncheckedCreateNestedManyWithoutServiceChannelInput = {
    create?: XOR<BusinessUnitServicePairCreateWithoutServiceChannelInput, BusinessUnitServicePairUncheckedCreateWithoutServiceChannelInput> | BusinessUnitServicePairCreateWithoutServiceChannelInput[] | BusinessUnitServicePairUncheckedCreateWithoutServiceChannelInput[]
    connectOrCreate?: BusinessUnitServicePairCreateOrConnectWithoutServiceChannelInput | BusinessUnitServicePairCreateOrConnectWithoutServiceChannelInput[]
    createMany?: BusinessUnitServicePairCreateManyServiceChannelInputEnvelope
    connect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
  }

  export type ServiceChannelOfficeTeamPairUpdateManyWithoutServiceChannelNestedInput = {
    create?: XOR<ServiceChannelOfficeTeamPairCreateWithoutServiceChannelInput, ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceChannelInput> | ServiceChannelOfficeTeamPairCreateWithoutServiceChannelInput[] | ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceChannelInput[]
    connectOrCreate?: ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceChannelInput | ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceChannelInput[]
    upsert?: ServiceChannelOfficeTeamPairUpsertWithWhereUniqueWithoutServiceChannelInput | ServiceChannelOfficeTeamPairUpsertWithWhereUniqueWithoutServiceChannelInput[]
    createMany?: ServiceChannelOfficeTeamPairCreateManyServiceChannelInputEnvelope
    set?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    disconnect?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    delete?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    connect?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    update?: ServiceChannelOfficeTeamPairUpdateWithWhereUniqueWithoutServiceChannelInput | ServiceChannelOfficeTeamPairUpdateWithWhereUniqueWithoutServiceChannelInput[]
    updateMany?: ServiceChannelOfficeTeamPairUpdateManyWithWhereWithoutServiceChannelInput | ServiceChannelOfficeTeamPairUpdateManyWithWhereWithoutServiceChannelInput[]
    deleteMany?: ServiceChannelOfficeTeamPairScalarWhereInput | ServiceChannelOfficeTeamPairScalarWhereInput[]
  }

  export type BusinessUnitServicePairUpdateManyWithoutServiceChannelNestedInput = {
    create?: XOR<BusinessUnitServicePairCreateWithoutServiceChannelInput, BusinessUnitServicePairUncheckedCreateWithoutServiceChannelInput> | BusinessUnitServicePairCreateWithoutServiceChannelInput[] | BusinessUnitServicePairUncheckedCreateWithoutServiceChannelInput[]
    connectOrCreate?: BusinessUnitServicePairCreateOrConnectWithoutServiceChannelInput | BusinessUnitServicePairCreateOrConnectWithoutServiceChannelInput[]
    upsert?: BusinessUnitServicePairUpsertWithWhereUniqueWithoutServiceChannelInput | BusinessUnitServicePairUpsertWithWhereUniqueWithoutServiceChannelInput[]
    createMany?: BusinessUnitServicePairCreateManyServiceChannelInputEnvelope
    set?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    disconnect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    delete?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    connect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    update?: BusinessUnitServicePairUpdateWithWhereUniqueWithoutServiceChannelInput | BusinessUnitServicePairUpdateWithWhereUniqueWithoutServiceChannelInput[]
    updateMany?: BusinessUnitServicePairUpdateManyWithWhereWithoutServiceChannelInput | BusinessUnitServicePairUpdateManyWithWhereWithoutServiceChannelInput[]
    deleteMany?: BusinessUnitServicePairScalarWhereInput | BusinessUnitServicePairScalarWhereInput[]
  }

  export type ServiceChannelOfficeTeamPairUncheckedUpdateManyWithoutServiceChannelNestedInput = {
    create?: XOR<ServiceChannelOfficeTeamPairCreateWithoutServiceChannelInput, ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceChannelInput> | ServiceChannelOfficeTeamPairCreateWithoutServiceChannelInput[] | ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceChannelInput[]
    connectOrCreate?: ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceChannelInput | ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceChannelInput[]
    upsert?: ServiceChannelOfficeTeamPairUpsertWithWhereUniqueWithoutServiceChannelInput | ServiceChannelOfficeTeamPairUpsertWithWhereUniqueWithoutServiceChannelInput[]
    createMany?: ServiceChannelOfficeTeamPairCreateManyServiceChannelInputEnvelope
    set?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    disconnect?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    delete?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    connect?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    update?: ServiceChannelOfficeTeamPairUpdateWithWhereUniqueWithoutServiceChannelInput | ServiceChannelOfficeTeamPairUpdateWithWhereUniqueWithoutServiceChannelInput[]
    updateMany?: ServiceChannelOfficeTeamPairUpdateManyWithWhereWithoutServiceChannelInput | ServiceChannelOfficeTeamPairUpdateManyWithWhereWithoutServiceChannelInput[]
    deleteMany?: ServiceChannelOfficeTeamPairScalarWhereInput | ServiceChannelOfficeTeamPairScalarWhereInput[]
  }

  export type BusinessUnitServicePairUncheckedUpdateManyWithoutServiceChannelNestedInput = {
    create?: XOR<BusinessUnitServicePairCreateWithoutServiceChannelInput, BusinessUnitServicePairUncheckedCreateWithoutServiceChannelInput> | BusinessUnitServicePairCreateWithoutServiceChannelInput[] | BusinessUnitServicePairUncheckedCreateWithoutServiceChannelInput[]
    connectOrCreate?: BusinessUnitServicePairCreateOrConnectWithoutServiceChannelInput | BusinessUnitServicePairCreateOrConnectWithoutServiceChannelInput[]
    upsert?: BusinessUnitServicePairUpsertWithWhereUniqueWithoutServiceChannelInput | BusinessUnitServicePairUpsertWithWhereUniqueWithoutServiceChannelInput[]
    createMany?: BusinessUnitServicePairCreateManyServiceChannelInputEnvelope
    set?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    disconnect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    delete?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    connect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    update?: BusinessUnitServicePairUpdateWithWhereUniqueWithoutServiceChannelInput | BusinessUnitServicePairUpdateWithWhereUniqueWithoutServiceChannelInput[]
    updateMany?: BusinessUnitServicePairUpdateManyWithWhereWithoutServiceChannelInput | BusinessUnitServicePairUpdateManyWithWhereWithoutServiceChannelInput[]
    deleteMany?: BusinessUnitServicePairScalarWhereInput | BusinessUnitServicePairScalarWhereInput[]
  }

  export type ServiceChannelOfficeTeamPairCreateNestedManyWithoutServiceOfficeInput = {
    create?: XOR<ServiceChannelOfficeTeamPairCreateWithoutServiceOfficeInput, ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceOfficeInput> | ServiceChannelOfficeTeamPairCreateWithoutServiceOfficeInput[] | ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceOfficeInput[]
    connectOrCreate?: ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceOfficeInput | ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceOfficeInput[]
    createMany?: ServiceChannelOfficeTeamPairCreateManyServiceOfficeInputEnvelope
    connect?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
  }

  export type BusinessUnitServicePairCreateNestedManyWithoutServiceOfficeInput = {
    create?: XOR<BusinessUnitServicePairCreateWithoutServiceOfficeInput, BusinessUnitServicePairUncheckedCreateWithoutServiceOfficeInput> | BusinessUnitServicePairCreateWithoutServiceOfficeInput[] | BusinessUnitServicePairUncheckedCreateWithoutServiceOfficeInput[]
    connectOrCreate?: BusinessUnitServicePairCreateOrConnectWithoutServiceOfficeInput | BusinessUnitServicePairCreateOrConnectWithoutServiceOfficeInput[]
    createMany?: BusinessUnitServicePairCreateManyServiceOfficeInputEnvelope
    connect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
  }

  export type ServiceChannelOfficeTeamPairUncheckedCreateNestedManyWithoutServiceOfficeInput = {
    create?: XOR<ServiceChannelOfficeTeamPairCreateWithoutServiceOfficeInput, ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceOfficeInput> | ServiceChannelOfficeTeamPairCreateWithoutServiceOfficeInput[] | ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceOfficeInput[]
    connectOrCreate?: ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceOfficeInput | ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceOfficeInput[]
    createMany?: ServiceChannelOfficeTeamPairCreateManyServiceOfficeInputEnvelope
    connect?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
  }

  export type BusinessUnitServicePairUncheckedCreateNestedManyWithoutServiceOfficeInput = {
    create?: XOR<BusinessUnitServicePairCreateWithoutServiceOfficeInput, BusinessUnitServicePairUncheckedCreateWithoutServiceOfficeInput> | BusinessUnitServicePairCreateWithoutServiceOfficeInput[] | BusinessUnitServicePairUncheckedCreateWithoutServiceOfficeInput[]
    connectOrCreate?: BusinessUnitServicePairCreateOrConnectWithoutServiceOfficeInput | BusinessUnitServicePairCreateOrConnectWithoutServiceOfficeInput[]
    createMany?: BusinessUnitServicePairCreateManyServiceOfficeInputEnvelope
    connect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
  }

  export type ServiceChannelOfficeTeamPairUpdateManyWithoutServiceOfficeNestedInput = {
    create?: XOR<ServiceChannelOfficeTeamPairCreateWithoutServiceOfficeInput, ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceOfficeInput> | ServiceChannelOfficeTeamPairCreateWithoutServiceOfficeInput[] | ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceOfficeInput[]
    connectOrCreate?: ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceOfficeInput | ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceOfficeInput[]
    upsert?: ServiceChannelOfficeTeamPairUpsertWithWhereUniqueWithoutServiceOfficeInput | ServiceChannelOfficeTeamPairUpsertWithWhereUniqueWithoutServiceOfficeInput[]
    createMany?: ServiceChannelOfficeTeamPairCreateManyServiceOfficeInputEnvelope
    set?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    disconnect?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    delete?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    connect?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    update?: ServiceChannelOfficeTeamPairUpdateWithWhereUniqueWithoutServiceOfficeInput | ServiceChannelOfficeTeamPairUpdateWithWhereUniqueWithoutServiceOfficeInput[]
    updateMany?: ServiceChannelOfficeTeamPairUpdateManyWithWhereWithoutServiceOfficeInput | ServiceChannelOfficeTeamPairUpdateManyWithWhereWithoutServiceOfficeInput[]
    deleteMany?: ServiceChannelOfficeTeamPairScalarWhereInput | ServiceChannelOfficeTeamPairScalarWhereInput[]
  }

  export type BusinessUnitServicePairUpdateManyWithoutServiceOfficeNestedInput = {
    create?: XOR<BusinessUnitServicePairCreateWithoutServiceOfficeInput, BusinessUnitServicePairUncheckedCreateWithoutServiceOfficeInput> | BusinessUnitServicePairCreateWithoutServiceOfficeInput[] | BusinessUnitServicePairUncheckedCreateWithoutServiceOfficeInput[]
    connectOrCreate?: BusinessUnitServicePairCreateOrConnectWithoutServiceOfficeInput | BusinessUnitServicePairCreateOrConnectWithoutServiceOfficeInput[]
    upsert?: BusinessUnitServicePairUpsertWithWhereUniqueWithoutServiceOfficeInput | BusinessUnitServicePairUpsertWithWhereUniqueWithoutServiceOfficeInput[]
    createMany?: BusinessUnitServicePairCreateManyServiceOfficeInputEnvelope
    set?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    disconnect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    delete?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    connect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    update?: BusinessUnitServicePairUpdateWithWhereUniqueWithoutServiceOfficeInput | BusinessUnitServicePairUpdateWithWhereUniqueWithoutServiceOfficeInput[]
    updateMany?: BusinessUnitServicePairUpdateManyWithWhereWithoutServiceOfficeInput | BusinessUnitServicePairUpdateManyWithWhereWithoutServiceOfficeInput[]
    deleteMany?: BusinessUnitServicePairScalarWhereInput | BusinessUnitServicePairScalarWhereInput[]
  }

  export type ServiceChannelOfficeTeamPairUncheckedUpdateManyWithoutServiceOfficeNestedInput = {
    create?: XOR<ServiceChannelOfficeTeamPairCreateWithoutServiceOfficeInput, ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceOfficeInput> | ServiceChannelOfficeTeamPairCreateWithoutServiceOfficeInput[] | ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceOfficeInput[]
    connectOrCreate?: ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceOfficeInput | ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceOfficeInput[]
    upsert?: ServiceChannelOfficeTeamPairUpsertWithWhereUniqueWithoutServiceOfficeInput | ServiceChannelOfficeTeamPairUpsertWithWhereUniqueWithoutServiceOfficeInput[]
    createMany?: ServiceChannelOfficeTeamPairCreateManyServiceOfficeInputEnvelope
    set?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    disconnect?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    delete?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    connect?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    update?: ServiceChannelOfficeTeamPairUpdateWithWhereUniqueWithoutServiceOfficeInput | ServiceChannelOfficeTeamPairUpdateWithWhereUniqueWithoutServiceOfficeInput[]
    updateMany?: ServiceChannelOfficeTeamPairUpdateManyWithWhereWithoutServiceOfficeInput | ServiceChannelOfficeTeamPairUpdateManyWithWhereWithoutServiceOfficeInput[]
    deleteMany?: ServiceChannelOfficeTeamPairScalarWhereInput | ServiceChannelOfficeTeamPairScalarWhereInput[]
  }

  export type BusinessUnitServicePairUncheckedUpdateManyWithoutServiceOfficeNestedInput = {
    create?: XOR<BusinessUnitServicePairCreateWithoutServiceOfficeInput, BusinessUnitServicePairUncheckedCreateWithoutServiceOfficeInput> | BusinessUnitServicePairCreateWithoutServiceOfficeInput[] | BusinessUnitServicePairUncheckedCreateWithoutServiceOfficeInput[]
    connectOrCreate?: BusinessUnitServicePairCreateOrConnectWithoutServiceOfficeInput | BusinessUnitServicePairCreateOrConnectWithoutServiceOfficeInput[]
    upsert?: BusinessUnitServicePairUpsertWithWhereUniqueWithoutServiceOfficeInput | BusinessUnitServicePairUpsertWithWhereUniqueWithoutServiceOfficeInput[]
    createMany?: BusinessUnitServicePairCreateManyServiceOfficeInputEnvelope
    set?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    disconnect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    delete?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    connect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    update?: BusinessUnitServicePairUpdateWithWhereUniqueWithoutServiceOfficeInput | BusinessUnitServicePairUpdateWithWhereUniqueWithoutServiceOfficeInput[]
    updateMany?: BusinessUnitServicePairUpdateManyWithWhereWithoutServiceOfficeInput | BusinessUnitServicePairUpdateManyWithWhereWithoutServiceOfficeInput[]
    deleteMany?: BusinessUnitServicePairScalarWhereInput | BusinessUnitServicePairScalarWhereInput[]
  }

  export type ServiceChannelOfficeTeamPairCreateNestedManyWithoutServiceTeamInput = {
    create?: XOR<ServiceChannelOfficeTeamPairCreateWithoutServiceTeamInput, ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceTeamInput> | ServiceChannelOfficeTeamPairCreateWithoutServiceTeamInput[] | ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceTeamInput[]
    connectOrCreate?: ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceTeamInput | ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceTeamInput[]
    createMany?: ServiceChannelOfficeTeamPairCreateManyServiceTeamInputEnvelope
    connect?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
  }

  export type BusinessUnitServicePairCreateNestedManyWithoutServiceTeamInput = {
    create?: XOR<BusinessUnitServicePairCreateWithoutServiceTeamInput, BusinessUnitServicePairUncheckedCreateWithoutServiceTeamInput> | BusinessUnitServicePairCreateWithoutServiceTeamInput[] | BusinessUnitServicePairUncheckedCreateWithoutServiceTeamInput[]
    connectOrCreate?: BusinessUnitServicePairCreateOrConnectWithoutServiceTeamInput | BusinessUnitServicePairCreateOrConnectWithoutServiceTeamInput[]
    createMany?: BusinessUnitServicePairCreateManyServiceTeamInputEnvelope
    connect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
  }

  export type ServiceChannelOfficeTeamPairUncheckedCreateNestedManyWithoutServiceTeamInput = {
    create?: XOR<ServiceChannelOfficeTeamPairCreateWithoutServiceTeamInput, ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceTeamInput> | ServiceChannelOfficeTeamPairCreateWithoutServiceTeamInput[] | ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceTeamInput[]
    connectOrCreate?: ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceTeamInput | ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceTeamInput[]
    createMany?: ServiceChannelOfficeTeamPairCreateManyServiceTeamInputEnvelope
    connect?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
  }

  export type BusinessUnitServicePairUncheckedCreateNestedManyWithoutServiceTeamInput = {
    create?: XOR<BusinessUnitServicePairCreateWithoutServiceTeamInput, BusinessUnitServicePairUncheckedCreateWithoutServiceTeamInput> | BusinessUnitServicePairCreateWithoutServiceTeamInput[] | BusinessUnitServicePairUncheckedCreateWithoutServiceTeamInput[]
    connectOrCreate?: BusinessUnitServicePairCreateOrConnectWithoutServiceTeamInput | BusinessUnitServicePairCreateOrConnectWithoutServiceTeamInput[]
    createMany?: BusinessUnitServicePairCreateManyServiceTeamInputEnvelope
    connect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
  }

  export type ServiceChannelOfficeTeamPairUpdateManyWithoutServiceTeamNestedInput = {
    create?: XOR<ServiceChannelOfficeTeamPairCreateWithoutServiceTeamInput, ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceTeamInput> | ServiceChannelOfficeTeamPairCreateWithoutServiceTeamInput[] | ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceTeamInput[]
    connectOrCreate?: ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceTeamInput | ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceTeamInput[]
    upsert?: ServiceChannelOfficeTeamPairUpsertWithWhereUniqueWithoutServiceTeamInput | ServiceChannelOfficeTeamPairUpsertWithWhereUniqueWithoutServiceTeamInput[]
    createMany?: ServiceChannelOfficeTeamPairCreateManyServiceTeamInputEnvelope
    set?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    disconnect?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    delete?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    connect?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    update?: ServiceChannelOfficeTeamPairUpdateWithWhereUniqueWithoutServiceTeamInput | ServiceChannelOfficeTeamPairUpdateWithWhereUniqueWithoutServiceTeamInput[]
    updateMany?: ServiceChannelOfficeTeamPairUpdateManyWithWhereWithoutServiceTeamInput | ServiceChannelOfficeTeamPairUpdateManyWithWhereWithoutServiceTeamInput[]
    deleteMany?: ServiceChannelOfficeTeamPairScalarWhereInput | ServiceChannelOfficeTeamPairScalarWhereInput[]
  }

  export type BusinessUnitServicePairUpdateManyWithoutServiceTeamNestedInput = {
    create?: XOR<BusinessUnitServicePairCreateWithoutServiceTeamInput, BusinessUnitServicePairUncheckedCreateWithoutServiceTeamInput> | BusinessUnitServicePairCreateWithoutServiceTeamInput[] | BusinessUnitServicePairUncheckedCreateWithoutServiceTeamInput[]
    connectOrCreate?: BusinessUnitServicePairCreateOrConnectWithoutServiceTeamInput | BusinessUnitServicePairCreateOrConnectWithoutServiceTeamInput[]
    upsert?: BusinessUnitServicePairUpsertWithWhereUniqueWithoutServiceTeamInput | BusinessUnitServicePairUpsertWithWhereUniqueWithoutServiceTeamInput[]
    createMany?: BusinessUnitServicePairCreateManyServiceTeamInputEnvelope
    set?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    disconnect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    delete?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    connect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    update?: BusinessUnitServicePairUpdateWithWhereUniqueWithoutServiceTeamInput | BusinessUnitServicePairUpdateWithWhereUniqueWithoutServiceTeamInput[]
    updateMany?: BusinessUnitServicePairUpdateManyWithWhereWithoutServiceTeamInput | BusinessUnitServicePairUpdateManyWithWhereWithoutServiceTeamInput[]
    deleteMany?: BusinessUnitServicePairScalarWhereInput | BusinessUnitServicePairScalarWhereInput[]
  }

  export type ServiceChannelOfficeTeamPairUncheckedUpdateManyWithoutServiceTeamNestedInput = {
    create?: XOR<ServiceChannelOfficeTeamPairCreateWithoutServiceTeamInput, ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceTeamInput> | ServiceChannelOfficeTeamPairCreateWithoutServiceTeamInput[] | ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceTeamInput[]
    connectOrCreate?: ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceTeamInput | ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceTeamInput[]
    upsert?: ServiceChannelOfficeTeamPairUpsertWithWhereUniqueWithoutServiceTeamInput | ServiceChannelOfficeTeamPairUpsertWithWhereUniqueWithoutServiceTeamInput[]
    createMany?: ServiceChannelOfficeTeamPairCreateManyServiceTeamInputEnvelope
    set?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    disconnect?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    delete?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    connect?: ServiceChannelOfficeTeamPairWhereUniqueInput | ServiceChannelOfficeTeamPairWhereUniqueInput[]
    update?: ServiceChannelOfficeTeamPairUpdateWithWhereUniqueWithoutServiceTeamInput | ServiceChannelOfficeTeamPairUpdateWithWhereUniqueWithoutServiceTeamInput[]
    updateMany?: ServiceChannelOfficeTeamPairUpdateManyWithWhereWithoutServiceTeamInput | ServiceChannelOfficeTeamPairUpdateManyWithWhereWithoutServiceTeamInput[]
    deleteMany?: ServiceChannelOfficeTeamPairScalarWhereInput | ServiceChannelOfficeTeamPairScalarWhereInput[]
  }

  export type BusinessUnitServicePairUncheckedUpdateManyWithoutServiceTeamNestedInput = {
    create?: XOR<BusinessUnitServicePairCreateWithoutServiceTeamInput, BusinessUnitServicePairUncheckedCreateWithoutServiceTeamInput> | BusinessUnitServicePairCreateWithoutServiceTeamInput[] | BusinessUnitServicePairUncheckedCreateWithoutServiceTeamInput[]
    connectOrCreate?: BusinessUnitServicePairCreateOrConnectWithoutServiceTeamInput | BusinessUnitServicePairCreateOrConnectWithoutServiceTeamInput[]
    upsert?: BusinessUnitServicePairUpsertWithWhereUniqueWithoutServiceTeamInput | BusinessUnitServicePairUpsertWithWhereUniqueWithoutServiceTeamInput[]
    createMany?: BusinessUnitServicePairCreateManyServiceTeamInputEnvelope
    set?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    disconnect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    delete?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    connect?: BusinessUnitServicePairWhereUniqueInput | BusinessUnitServicePairWhereUniqueInput[]
    update?: BusinessUnitServicePairUpdateWithWhereUniqueWithoutServiceTeamInput | BusinessUnitServicePairUpdateWithWhereUniqueWithoutServiceTeamInput[]
    updateMany?: BusinessUnitServicePairUpdateManyWithWhereWithoutServiceTeamInput | BusinessUnitServicePairUpdateManyWithWhereWithoutServiceTeamInput[]
    deleteMany?: BusinessUnitServicePairScalarWhereInput | BusinessUnitServicePairScalarWhereInput[]
  }

  export type ServiceChannelCreateNestedOneWithoutChannelOfficePairsInput = {
    create?: XOR<ServiceChannelCreateWithoutChannelOfficePairsInput, ServiceChannelUncheckedCreateWithoutChannelOfficePairsInput>
    connectOrCreate?: ServiceChannelCreateOrConnectWithoutChannelOfficePairsInput
    connect?: ServiceChannelWhereUniqueInput
  }

  export type ServiceOfficeCreateNestedOneWithoutOfficeTeamPairsInput = {
    create?: XOR<ServiceOfficeCreateWithoutOfficeTeamPairsInput, ServiceOfficeUncheckedCreateWithoutOfficeTeamPairsInput>
    connectOrCreate?: ServiceOfficeCreateOrConnectWithoutOfficeTeamPairsInput
    connect?: ServiceOfficeWhereUniqueInput
  }

  export type ServiceTeamCreateNestedOneWithoutOfficeTeamPairsInput = {
    create?: XOR<ServiceTeamCreateWithoutOfficeTeamPairsInput, ServiceTeamUncheckedCreateWithoutOfficeTeamPairsInput>
    connectOrCreate?: ServiceTeamCreateOrConnectWithoutOfficeTeamPairsInput
    connect?: ServiceTeamWhereUniqueInput
  }

  export type ServiceChannelUpdateOneRequiredWithoutChannelOfficePairsNestedInput = {
    create?: XOR<ServiceChannelCreateWithoutChannelOfficePairsInput, ServiceChannelUncheckedCreateWithoutChannelOfficePairsInput>
    connectOrCreate?: ServiceChannelCreateOrConnectWithoutChannelOfficePairsInput
    upsert?: ServiceChannelUpsertWithoutChannelOfficePairsInput
    connect?: ServiceChannelWhereUniqueInput
    update?: XOR<XOR<ServiceChannelUpdateToOneWithWhereWithoutChannelOfficePairsInput, ServiceChannelUpdateWithoutChannelOfficePairsInput>, ServiceChannelUncheckedUpdateWithoutChannelOfficePairsInput>
  }

  export type ServiceOfficeUpdateOneRequiredWithoutOfficeTeamPairsNestedInput = {
    create?: XOR<ServiceOfficeCreateWithoutOfficeTeamPairsInput, ServiceOfficeUncheckedCreateWithoutOfficeTeamPairsInput>
    connectOrCreate?: ServiceOfficeCreateOrConnectWithoutOfficeTeamPairsInput
    upsert?: ServiceOfficeUpsertWithoutOfficeTeamPairsInput
    connect?: ServiceOfficeWhereUniqueInput
    update?: XOR<XOR<ServiceOfficeUpdateToOneWithWhereWithoutOfficeTeamPairsInput, ServiceOfficeUpdateWithoutOfficeTeamPairsInput>, ServiceOfficeUncheckedUpdateWithoutOfficeTeamPairsInput>
  }

  export type ServiceTeamUpdateOneRequiredWithoutOfficeTeamPairsNestedInput = {
    create?: XOR<ServiceTeamCreateWithoutOfficeTeamPairsInput, ServiceTeamUncheckedCreateWithoutOfficeTeamPairsInput>
    connectOrCreate?: ServiceTeamCreateOrConnectWithoutOfficeTeamPairsInput
    upsert?: ServiceTeamUpsertWithoutOfficeTeamPairsInput
    connect?: ServiceTeamWhereUniqueInput
    update?: XOR<XOR<ServiceTeamUpdateToOneWithWhereWithoutOfficeTeamPairsInput, ServiceTeamUpdateWithoutOfficeTeamPairsInput>, ServiceTeamUncheckedUpdateWithoutOfficeTeamPairsInput>
  }

  export type BusinessUnitCreateNestedOneWithoutBusinessUnitSalesPairsInput = {
    create?: XOR<BusinessUnitCreateWithoutBusinessUnitSalesPairsInput, BusinessUnitUncheckedCreateWithoutBusinessUnitSalesPairsInput>
    connectOrCreate?: BusinessUnitCreateOrConnectWithoutBusinessUnitSalesPairsInput
    connect?: BusinessUnitWhereUniqueInput
  }

  export type SalesChannelCreateNestedOneWithoutBusinessUnitSalesPairsInput = {
    create?: XOR<SalesChannelCreateWithoutBusinessUnitSalesPairsInput, SalesChannelUncheckedCreateWithoutBusinessUnitSalesPairsInput>
    connectOrCreate?: SalesChannelCreateOrConnectWithoutBusinessUnitSalesPairsInput
    connect?: SalesChannelWhereUniqueInput
  }

  export type SalesOfficeCreateNestedOneWithoutBusinessUnitSalesPairsInput = {
    create?: XOR<SalesOfficeCreateWithoutBusinessUnitSalesPairsInput, SalesOfficeUncheckedCreateWithoutBusinessUnitSalesPairsInput>
    connectOrCreate?: SalesOfficeCreateOrConnectWithoutBusinessUnitSalesPairsInput
    connect?: SalesOfficeWhereUniqueInput
  }

  export type SalesTeamCreateNestedOneWithoutBusinessUnitSalesPairsInput = {
    create?: XOR<SalesTeamCreateWithoutBusinessUnitSalesPairsInput, SalesTeamUncheckedCreateWithoutBusinessUnitSalesPairsInput>
    connectOrCreate?: SalesTeamCreateOrConnectWithoutBusinessUnitSalesPairsInput
    connect?: SalesTeamWhereUniqueInput
  }

  export type BusinessUnitUpdateOneRequiredWithoutBusinessUnitSalesPairsNestedInput = {
    create?: XOR<BusinessUnitCreateWithoutBusinessUnitSalesPairsInput, BusinessUnitUncheckedCreateWithoutBusinessUnitSalesPairsInput>
    connectOrCreate?: BusinessUnitCreateOrConnectWithoutBusinessUnitSalesPairsInput
    upsert?: BusinessUnitUpsertWithoutBusinessUnitSalesPairsInput
    connect?: BusinessUnitWhereUniqueInput
    update?: XOR<XOR<BusinessUnitUpdateToOneWithWhereWithoutBusinessUnitSalesPairsInput, BusinessUnitUpdateWithoutBusinessUnitSalesPairsInput>, BusinessUnitUncheckedUpdateWithoutBusinessUnitSalesPairsInput>
  }

  export type SalesChannelUpdateOneRequiredWithoutBusinessUnitSalesPairsNestedInput = {
    create?: XOR<SalesChannelCreateWithoutBusinessUnitSalesPairsInput, SalesChannelUncheckedCreateWithoutBusinessUnitSalesPairsInput>
    connectOrCreate?: SalesChannelCreateOrConnectWithoutBusinessUnitSalesPairsInput
    upsert?: SalesChannelUpsertWithoutBusinessUnitSalesPairsInput
    connect?: SalesChannelWhereUniqueInput
    update?: XOR<XOR<SalesChannelUpdateToOneWithWhereWithoutBusinessUnitSalesPairsInput, SalesChannelUpdateWithoutBusinessUnitSalesPairsInput>, SalesChannelUncheckedUpdateWithoutBusinessUnitSalesPairsInput>
  }

  export type SalesOfficeUpdateOneRequiredWithoutBusinessUnitSalesPairsNestedInput = {
    create?: XOR<SalesOfficeCreateWithoutBusinessUnitSalesPairsInput, SalesOfficeUncheckedCreateWithoutBusinessUnitSalesPairsInput>
    connectOrCreate?: SalesOfficeCreateOrConnectWithoutBusinessUnitSalesPairsInput
    upsert?: SalesOfficeUpsertWithoutBusinessUnitSalesPairsInput
    connect?: SalesOfficeWhereUniqueInput
    update?: XOR<XOR<SalesOfficeUpdateToOneWithWhereWithoutBusinessUnitSalesPairsInput, SalesOfficeUpdateWithoutBusinessUnitSalesPairsInput>, SalesOfficeUncheckedUpdateWithoutBusinessUnitSalesPairsInput>
  }

  export type SalesTeamUpdateOneRequiredWithoutBusinessUnitSalesPairsNestedInput = {
    create?: XOR<SalesTeamCreateWithoutBusinessUnitSalesPairsInput, SalesTeamUncheckedCreateWithoutBusinessUnitSalesPairsInput>
    connectOrCreate?: SalesTeamCreateOrConnectWithoutBusinessUnitSalesPairsInput
    upsert?: SalesTeamUpsertWithoutBusinessUnitSalesPairsInput
    connect?: SalesTeamWhereUniqueInput
    update?: XOR<XOR<SalesTeamUpdateToOneWithWhereWithoutBusinessUnitSalesPairsInput, SalesTeamUpdateWithoutBusinessUnitSalesPairsInput>, SalesTeamUncheckedUpdateWithoutBusinessUnitSalesPairsInput>
  }

  export type BusinessUnitCreateNestedOneWithoutBusinessUnitMarketingPairsInput = {
    create?: XOR<BusinessUnitCreateWithoutBusinessUnitMarketingPairsInput, BusinessUnitUncheckedCreateWithoutBusinessUnitMarketingPairsInput>
    connectOrCreate?: BusinessUnitCreateOrConnectWithoutBusinessUnitMarketingPairsInput
    connect?: BusinessUnitWhereUniqueInput
  }

  export type MarketingChannelCreateNestedOneWithoutBusinessUnitMarketingPairsInput = {
    create?: XOR<MarketingChannelCreateWithoutBusinessUnitMarketingPairsInput, MarketingChannelUncheckedCreateWithoutBusinessUnitMarketingPairsInput>
    connectOrCreate?: MarketingChannelCreateOrConnectWithoutBusinessUnitMarketingPairsInput
    connect?: MarketingChannelWhereUniqueInput
  }

  export type MarketingOfficeCreateNestedOneWithoutBusinessUnitMarketingPairsInput = {
    create?: XOR<MarketingOfficeCreateWithoutBusinessUnitMarketingPairsInput, MarketingOfficeUncheckedCreateWithoutBusinessUnitMarketingPairsInput>
    connectOrCreate?: MarketingOfficeCreateOrConnectWithoutBusinessUnitMarketingPairsInput
    connect?: MarketingOfficeWhereUniqueInput
  }

  export type MarketingTeamCreateNestedOneWithoutBusinessUnitMarketingPairsInput = {
    create?: XOR<MarketingTeamCreateWithoutBusinessUnitMarketingPairsInput, MarketingTeamUncheckedCreateWithoutBusinessUnitMarketingPairsInput>
    connectOrCreate?: MarketingTeamCreateOrConnectWithoutBusinessUnitMarketingPairsInput
    connect?: MarketingTeamWhereUniqueInput
  }

  export type BusinessUnitUpdateOneRequiredWithoutBusinessUnitMarketingPairsNestedInput = {
    create?: XOR<BusinessUnitCreateWithoutBusinessUnitMarketingPairsInput, BusinessUnitUncheckedCreateWithoutBusinessUnitMarketingPairsInput>
    connectOrCreate?: BusinessUnitCreateOrConnectWithoutBusinessUnitMarketingPairsInput
    upsert?: BusinessUnitUpsertWithoutBusinessUnitMarketingPairsInput
    connect?: BusinessUnitWhereUniqueInput
    update?: XOR<XOR<BusinessUnitUpdateToOneWithWhereWithoutBusinessUnitMarketingPairsInput, BusinessUnitUpdateWithoutBusinessUnitMarketingPairsInput>, BusinessUnitUncheckedUpdateWithoutBusinessUnitMarketingPairsInput>
  }

  export type MarketingChannelUpdateOneRequiredWithoutBusinessUnitMarketingPairsNestedInput = {
    create?: XOR<MarketingChannelCreateWithoutBusinessUnitMarketingPairsInput, MarketingChannelUncheckedCreateWithoutBusinessUnitMarketingPairsInput>
    connectOrCreate?: MarketingChannelCreateOrConnectWithoutBusinessUnitMarketingPairsInput
    upsert?: MarketingChannelUpsertWithoutBusinessUnitMarketingPairsInput
    connect?: MarketingChannelWhereUniqueInput
    update?: XOR<XOR<MarketingChannelUpdateToOneWithWhereWithoutBusinessUnitMarketingPairsInput, MarketingChannelUpdateWithoutBusinessUnitMarketingPairsInput>, MarketingChannelUncheckedUpdateWithoutBusinessUnitMarketingPairsInput>
  }

  export type MarketingOfficeUpdateOneRequiredWithoutBusinessUnitMarketingPairsNestedInput = {
    create?: XOR<MarketingOfficeCreateWithoutBusinessUnitMarketingPairsInput, MarketingOfficeUncheckedCreateWithoutBusinessUnitMarketingPairsInput>
    connectOrCreate?: MarketingOfficeCreateOrConnectWithoutBusinessUnitMarketingPairsInput
    upsert?: MarketingOfficeUpsertWithoutBusinessUnitMarketingPairsInput
    connect?: MarketingOfficeWhereUniqueInput
    update?: XOR<XOR<MarketingOfficeUpdateToOneWithWhereWithoutBusinessUnitMarketingPairsInput, MarketingOfficeUpdateWithoutBusinessUnitMarketingPairsInput>, MarketingOfficeUncheckedUpdateWithoutBusinessUnitMarketingPairsInput>
  }

  export type MarketingTeamUpdateOneRequiredWithoutBusinessUnitMarketingPairsNestedInput = {
    create?: XOR<MarketingTeamCreateWithoutBusinessUnitMarketingPairsInput, MarketingTeamUncheckedCreateWithoutBusinessUnitMarketingPairsInput>
    connectOrCreate?: MarketingTeamCreateOrConnectWithoutBusinessUnitMarketingPairsInput
    upsert?: MarketingTeamUpsertWithoutBusinessUnitMarketingPairsInput
    connect?: MarketingTeamWhereUniqueInput
    update?: XOR<XOR<MarketingTeamUpdateToOneWithWhereWithoutBusinessUnitMarketingPairsInput, MarketingTeamUpdateWithoutBusinessUnitMarketingPairsInput>, MarketingTeamUncheckedUpdateWithoutBusinessUnitMarketingPairsInput>
  }

  export type BusinessUnitCreateNestedOneWithoutBusinessUnitServicePairsInput = {
    create?: XOR<BusinessUnitCreateWithoutBusinessUnitServicePairsInput, BusinessUnitUncheckedCreateWithoutBusinessUnitServicePairsInput>
    connectOrCreate?: BusinessUnitCreateOrConnectWithoutBusinessUnitServicePairsInput
    connect?: BusinessUnitWhereUniqueInput
  }

  export type ServiceChannelCreateNestedOneWithoutBusinessUnitServicePairsInput = {
    create?: XOR<ServiceChannelCreateWithoutBusinessUnitServicePairsInput, ServiceChannelUncheckedCreateWithoutBusinessUnitServicePairsInput>
    connectOrCreate?: ServiceChannelCreateOrConnectWithoutBusinessUnitServicePairsInput
    connect?: ServiceChannelWhereUniqueInput
  }

  export type ServiceOfficeCreateNestedOneWithoutBusinessUnitServicePairsInput = {
    create?: XOR<ServiceOfficeCreateWithoutBusinessUnitServicePairsInput, ServiceOfficeUncheckedCreateWithoutBusinessUnitServicePairsInput>
    connectOrCreate?: ServiceOfficeCreateOrConnectWithoutBusinessUnitServicePairsInput
    connect?: ServiceOfficeWhereUniqueInput
  }

  export type ServiceTeamCreateNestedOneWithoutBusinessUnitServicePairsInput = {
    create?: XOR<ServiceTeamCreateWithoutBusinessUnitServicePairsInput, ServiceTeamUncheckedCreateWithoutBusinessUnitServicePairsInput>
    connectOrCreate?: ServiceTeamCreateOrConnectWithoutBusinessUnitServicePairsInput
    connect?: ServiceTeamWhereUniqueInput
  }

  export type BusinessUnitUpdateOneRequiredWithoutBusinessUnitServicePairsNestedInput = {
    create?: XOR<BusinessUnitCreateWithoutBusinessUnitServicePairsInput, BusinessUnitUncheckedCreateWithoutBusinessUnitServicePairsInput>
    connectOrCreate?: BusinessUnitCreateOrConnectWithoutBusinessUnitServicePairsInput
    upsert?: BusinessUnitUpsertWithoutBusinessUnitServicePairsInput
    connect?: BusinessUnitWhereUniqueInput
    update?: XOR<XOR<BusinessUnitUpdateToOneWithWhereWithoutBusinessUnitServicePairsInput, BusinessUnitUpdateWithoutBusinessUnitServicePairsInput>, BusinessUnitUncheckedUpdateWithoutBusinessUnitServicePairsInput>
  }

  export type ServiceChannelUpdateOneRequiredWithoutBusinessUnitServicePairsNestedInput = {
    create?: XOR<ServiceChannelCreateWithoutBusinessUnitServicePairsInput, ServiceChannelUncheckedCreateWithoutBusinessUnitServicePairsInput>
    connectOrCreate?: ServiceChannelCreateOrConnectWithoutBusinessUnitServicePairsInput
    upsert?: ServiceChannelUpsertWithoutBusinessUnitServicePairsInput
    connect?: ServiceChannelWhereUniqueInput
    update?: XOR<XOR<ServiceChannelUpdateToOneWithWhereWithoutBusinessUnitServicePairsInput, ServiceChannelUpdateWithoutBusinessUnitServicePairsInput>, ServiceChannelUncheckedUpdateWithoutBusinessUnitServicePairsInput>
  }

  export type ServiceOfficeUpdateOneRequiredWithoutBusinessUnitServicePairsNestedInput = {
    create?: XOR<ServiceOfficeCreateWithoutBusinessUnitServicePairsInput, ServiceOfficeUncheckedCreateWithoutBusinessUnitServicePairsInput>
    connectOrCreate?: ServiceOfficeCreateOrConnectWithoutBusinessUnitServicePairsInput
    upsert?: ServiceOfficeUpsertWithoutBusinessUnitServicePairsInput
    connect?: ServiceOfficeWhereUniqueInput
    update?: XOR<XOR<ServiceOfficeUpdateToOneWithWhereWithoutBusinessUnitServicePairsInput, ServiceOfficeUpdateWithoutBusinessUnitServicePairsInput>, ServiceOfficeUncheckedUpdateWithoutBusinessUnitServicePairsInput>
  }

  export type ServiceTeamUpdateOneRequiredWithoutBusinessUnitServicePairsNestedInput = {
    create?: XOR<ServiceTeamCreateWithoutBusinessUnitServicePairsInput, ServiceTeamUncheckedCreateWithoutBusinessUnitServicePairsInput>
    connectOrCreate?: ServiceTeamCreateOrConnectWithoutBusinessUnitServicePairsInput
    upsert?: ServiceTeamUpsertWithoutBusinessUnitServicePairsInput
    connect?: ServiceTeamWhereUniqueInput
    update?: XOR<XOR<ServiceTeamUpdateToOneWithWhereWithoutBusinessUnitServicePairsInput, ServiceTeamUpdateWithoutBusinessUnitServicePairsInput>, ServiceTeamUncheckedUpdateWithoutBusinessUnitServicePairsInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BusinessEntityUnitPairCreateWithoutBusinessEntityInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnit: BusinessUnitCreateNestedOneWithoutEntityUnitPairsInput
  }

  export type BusinessEntityUnitPairUncheckedCreateWithoutBusinessEntityInput = {
    id?: number
    businessUnitCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessEntityUnitPairCreateOrConnectWithoutBusinessEntityInput = {
    where: BusinessEntityUnitPairWhereUniqueInput
    create: XOR<BusinessEntityUnitPairCreateWithoutBusinessEntityInput, BusinessEntityUnitPairUncheckedCreateWithoutBusinessEntityInput>
  }

  export type BusinessEntityUnitPairCreateManyBusinessEntityInputEnvelope = {
    data: BusinessEntityUnitPairCreateManyBusinessEntityInput | BusinessEntityUnitPairCreateManyBusinessEntityInput[]
    skipDuplicates?: boolean
  }

  export type BusinessEntityUnitPairUpsertWithWhereUniqueWithoutBusinessEntityInput = {
    where: BusinessEntityUnitPairWhereUniqueInput
    update: XOR<BusinessEntityUnitPairUpdateWithoutBusinessEntityInput, BusinessEntityUnitPairUncheckedUpdateWithoutBusinessEntityInput>
    create: XOR<BusinessEntityUnitPairCreateWithoutBusinessEntityInput, BusinessEntityUnitPairUncheckedCreateWithoutBusinessEntityInput>
  }

  export type BusinessEntityUnitPairUpdateWithWhereUniqueWithoutBusinessEntityInput = {
    where: BusinessEntityUnitPairWhereUniqueInput
    data: XOR<BusinessEntityUnitPairUpdateWithoutBusinessEntityInput, BusinessEntityUnitPairUncheckedUpdateWithoutBusinessEntityInput>
  }

  export type BusinessEntityUnitPairUpdateManyWithWhereWithoutBusinessEntityInput = {
    where: BusinessEntityUnitPairScalarWhereInput
    data: XOR<BusinessEntityUnitPairUpdateManyMutationInput, BusinessEntityUnitPairUncheckedUpdateManyWithoutBusinessEntityInput>
  }

  export type BusinessEntityUnitPairScalarWhereInput = {
    AND?: BusinessEntityUnitPairScalarWhereInput | BusinessEntityUnitPairScalarWhereInput[]
    OR?: BusinessEntityUnitPairScalarWhereInput[]
    NOT?: BusinessEntityUnitPairScalarWhereInput | BusinessEntityUnitPairScalarWhereInput[]
    id?: IntFilter<"BusinessEntityUnitPair"> | number
    businessEntityCode?: StringFilter<"BusinessEntityUnitPair"> | string
    businessUnitCode?: StringFilter<"BusinessEntityUnitPair"> | string
    createdAt?: DateTimeFilter<"BusinessEntityUnitPair"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessEntityUnitPair"> | Date | string
  }

  export type BusinessEntityUnitPairCreateWithoutBusinessUnitInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    businessEntity: BusinessEntityCreateNestedOneWithoutEntityUnitPairsInput
  }

  export type BusinessEntityUnitPairUncheckedCreateWithoutBusinessUnitInput = {
    id?: number
    businessEntityCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessEntityUnitPairCreateOrConnectWithoutBusinessUnitInput = {
    where: BusinessEntityUnitPairWhereUniqueInput
    create: XOR<BusinessEntityUnitPairCreateWithoutBusinessUnitInput, BusinessEntityUnitPairUncheckedCreateWithoutBusinessUnitInput>
  }

  export type BusinessEntityUnitPairCreateManyBusinessUnitInputEnvelope = {
    data: BusinessEntityUnitPairCreateManyBusinessUnitInput | BusinessEntityUnitPairCreateManyBusinessUnitInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUnitSalesPairCreateWithoutBusinessUnitInput = {
    id?: string
    salesChannel: SalesChannelCreateNestedOneWithoutBusinessUnitSalesPairsInput
    salesOffice: SalesOfficeCreateNestedOneWithoutBusinessUnitSalesPairsInput
    salesTeam: SalesTeamCreateNestedOneWithoutBusinessUnitSalesPairsInput
  }

  export type BusinessUnitSalesPairUncheckedCreateWithoutBusinessUnitInput = {
    id?: string
    salesChannelCode: string
    salesOfficeId: string
    salesTeamCode: string
  }

  export type BusinessUnitSalesPairCreateOrConnectWithoutBusinessUnitInput = {
    where: BusinessUnitSalesPairWhereUniqueInput
    create: XOR<BusinessUnitSalesPairCreateWithoutBusinessUnitInput, BusinessUnitSalesPairUncheckedCreateWithoutBusinessUnitInput>
  }

  export type BusinessUnitSalesPairCreateManyBusinessUnitInputEnvelope = {
    data: BusinessUnitSalesPairCreateManyBusinessUnitInput | BusinessUnitSalesPairCreateManyBusinessUnitInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUnitMarketingPairCreateWithoutBusinessUnitInput = {
    id?: string
    marketingChannel: MarketingChannelCreateNestedOneWithoutBusinessUnitMarketingPairsInput
    marketingOffice: MarketingOfficeCreateNestedOneWithoutBusinessUnitMarketingPairsInput
    marketingTeam: MarketingTeamCreateNestedOneWithoutBusinessUnitMarketingPairsInput
  }

  export type BusinessUnitMarketingPairUncheckedCreateWithoutBusinessUnitInput = {
    id?: string
    marketingChannelCode: string
    marketingOfficeId: string
    marketingTeamCode: string
  }

  export type BusinessUnitMarketingPairCreateOrConnectWithoutBusinessUnitInput = {
    where: BusinessUnitMarketingPairWhereUniqueInput
    create: XOR<BusinessUnitMarketingPairCreateWithoutBusinessUnitInput, BusinessUnitMarketingPairUncheckedCreateWithoutBusinessUnitInput>
  }

  export type BusinessUnitMarketingPairCreateManyBusinessUnitInputEnvelope = {
    data: BusinessUnitMarketingPairCreateManyBusinessUnitInput | BusinessUnitMarketingPairCreateManyBusinessUnitInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUnitServicePairCreateWithoutBusinessUnitInput = {
    id?: string
    serviceChannel: ServiceChannelCreateNestedOneWithoutBusinessUnitServicePairsInput
    serviceOffice: ServiceOfficeCreateNestedOneWithoutBusinessUnitServicePairsInput
    serviceTeam: ServiceTeamCreateNestedOneWithoutBusinessUnitServicePairsInput
  }

  export type BusinessUnitServicePairUncheckedCreateWithoutBusinessUnitInput = {
    id?: string
    serviceChannelCode: string
    serviceOfficeId: string
    serviceTeamCode: string
  }

  export type BusinessUnitServicePairCreateOrConnectWithoutBusinessUnitInput = {
    where: BusinessUnitServicePairWhereUniqueInput
    create: XOR<BusinessUnitServicePairCreateWithoutBusinessUnitInput, BusinessUnitServicePairUncheckedCreateWithoutBusinessUnitInput>
  }

  export type BusinessUnitServicePairCreateManyBusinessUnitInputEnvelope = {
    data: BusinessUnitServicePairCreateManyBusinessUnitInput | BusinessUnitServicePairCreateManyBusinessUnitInput[]
    skipDuplicates?: boolean
  }

  export type BusinessEntityUnitPairUpsertWithWhereUniqueWithoutBusinessUnitInput = {
    where: BusinessEntityUnitPairWhereUniqueInput
    update: XOR<BusinessEntityUnitPairUpdateWithoutBusinessUnitInput, BusinessEntityUnitPairUncheckedUpdateWithoutBusinessUnitInput>
    create: XOR<BusinessEntityUnitPairCreateWithoutBusinessUnitInput, BusinessEntityUnitPairUncheckedCreateWithoutBusinessUnitInput>
  }

  export type BusinessEntityUnitPairUpdateWithWhereUniqueWithoutBusinessUnitInput = {
    where: BusinessEntityUnitPairWhereUniqueInput
    data: XOR<BusinessEntityUnitPairUpdateWithoutBusinessUnitInput, BusinessEntityUnitPairUncheckedUpdateWithoutBusinessUnitInput>
  }

  export type BusinessEntityUnitPairUpdateManyWithWhereWithoutBusinessUnitInput = {
    where: BusinessEntityUnitPairScalarWhereInput
    data: XOR<BusinessEntityUnitPairUpdateManyMutationInput, BusinessEntityUnitPairUncheckedUpdateManyWithoutBusinessUnitInput>
  }

  export type BusinessUnitSalesPairUpsertWithWhereUniqueWithoutBusinessUnitInput = {
    where: BusinessUnitSalesPairWhereUniqueInput
    update: XOR<BusinessUnitSalesPairUpdateWithoutBusinessUnitInput, BusinessUnitSalesPairUncheckedUpdateWithoutBusinessUnitInput>
    create: XOR<BusinessUnitSalesPairCreateWithoutBusinessUnitInput, BusinessUnitSalesPairUncheckedCreateWithoutBusinessUnitInput>
  }

  export type BusinessUnitSalesPairUpdateWithWhereUniqueWithoutBusinessUnitInput = {
    where: BusinessUnitSalesPairWhereUniqueInput
    data: XOR<BusinessUnitSalesPairUpdateWithoutBusinessUnitInput, BusinessUnitSalesPairUncheckedUpdateWithoutBusinessUnitInput>
  }

  export type BusinessUnitSalesPairUpdateManyWithWhereWithoutBusinessUnitInput = {
    where: BusinessUnitSalesPairScalarWhereInput
    data: XOR<BusinessUnitSalesPairUpdateManyMutationInput, BusinessUnitSalesPairUncheckedUpdateManyWithoutBusinessUnitInput>
  }

  export type BusinessUnitSalesPairScalarWhereInput = {
    AND?: BusinessUnitSalesPairScalarWhereInput | BusinessUnitSalesPairScalarWhereInput[]
    OR?: BusinessUnitSalesPairScalarWhereInput[]
    NOT?: BusinessUnitSalesPairScalarWhereInput | BusinessUnitSalesPairScalarWhereInput[]
    id?: StringFilter<"BusinessUnitSalesPair"> | string
    businessUnitCode?: StringFilter<"BusinessUnitSalesPair"> | string
    salesChannelCode?: StringFilter<"BusinessUnitSalesPair"> | string
    salesOfficeId?: StringFilter<"BusinessUnitSalesPair"> | string
    salesTeamCode?: StringFilter<"BusinessUnitSalesPair"> | string
  }

  export type BusinessUnitMarketingPairUpsertWithWhereUniqueWithoutBusinessUnitInput = {
    where: BusinessUnitMarketingPairWhereUniqueInput
    update: XOR<BusinessUnitMarketingPairUpdateWithoutBusinessUnitInput, BusinessUnitMarketingPairUncheckedUpdateWithoutBusinessUnitInput>
    create: XOR<BusinessUnitMarketingPairCreateWithoutBusinessUnitInput, BusinessUnitMarketingPairUncheckedCreateWithoutBusinessUnitInput>
  }

  export type BusinessUnitMarketingPairUpdateWithWhereUniqueWithoutBusinessUnitInput = {
    where: BusinessUnitMarketingPairWhereUniqueInput
    data: XOR<BusinessUnitMarketingPairUpdateWithoutBusinessUnitInput, BusinessUnitMarketingPairUncheckedUpdateWithoutBusinessUnitInput>
  }

  export type BusinessUnitMarketingPairUpdateManyWithWhereWithoutBusinessUnitInput = {
    where: BusinessUnitMarketingPairScalarWhereInput
    data: XOR<BusinessUnitMarketingPairUpdateManyMutationInput, BusinessUnitMarketingPairUncheckedUpdateManyWithoutBusinessUnitInput>
  }

  export type BusinessUnitMarketingPairScalarWhereInput = {
    AND?: BusinessUnitMarketingPairScalarWhereInput | BusinessUnitMarketingPairScalarWhereInput[]
    OR?: BusinessUnitMarketingPairScalarWhereInput[]
    NOT?: BusinessUnitMarketingPairScalarWhereInput | BusinessUnitMarketingPairScalarWhereInput[]
    id?: StringFilter<"BusinessUnitMarketingPair"> | string
    businessUnitCode?: StringFilter<"BusinessUnitMarketingPair"> | string
    marketingChannelCode?: StringFilter<"BusinessUnitMarketingPair"> | string
    marketingOfficeId?: StringFilter<"BusinessUnitMarketingPair"> | string
    marketingTeamCode?: StringFilter<"BusinessUnitMarketingPair"> | string
  }

  export type BusinessUnitServicePairUpsertWithWhereUniqueWithoutBusinessUnitInput = {
    where: BusinessUnitServicePairWhereUniqueInput
    update: XOR<BusinessUnitServicePairUpdateWithoutBusinessUnitInput, BusinessUnitServicePairUncheckedUpdateWithoutBusinessUnitInput>
    create: XOR<BusinessUnitServicePairCreateWithoutBusinessUnitInput, BusinessUnitServicePairUncheckedCreateWithoutBusinessUnitInput>
  }

  export type BusinessUnitServicePairUpdateWithWhereUniqueWithoutBusinessUnitInput = {
    where: BusinessUnitServicePairWhereUniqueInput
    data: XOR<BusinessUnitServicePairUpdateWithoutBusinessUnitInput, BusinessUnitServicePairUncheckedUpdateWithoutBusinessUnitInput>
  }

  export type BusinessUnitServicePairUpdateManyWithWhereWithoutBusinessUnitInput = {
    where: BusinessUnitServicePairScalarWhereInput
    data: XOR<BusinessUnitServicePairUpdateManyMutationInput, BusinessUnitServicePairUncheckedUpdateManyWithoutBusinessUnitInput>
  }

  export type BusinessUnitServicePairScalarWhereInput = {
    AND?: BusinessUnitServicePairScalarWhereInput | BusinessUnitServicePairScalarWhereInput[]
    OR?: BusinessUnitServicePairScalarWhereInput[]
    NOT?: BusinessUnitServicePairScalarWhereInput | BusinessUnitServicePairScalarWhereInput[]
    id?: StringFilter<"BusinessUnitServicePair"> | string
    businessUnitCode?: StringFilter<"BusinessUnitServicePair"> | string
    serviceChannelCode?: StringFilter<"BusinessUnitServicePair"> | string
    serviceOfficeId?: StringFilter<"BusinessUnitServicePair"> | string
    serviceTeamCode?: StringFilter<"BusinessUnitServicePair"> | string
  }

  export type BusinessEntityCreateWithoutEntityUnitPairsInput = {
    businessEntityCode: string
    businessEntityName: string
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessEntityUncheckedCreateWithoutEntityUnitPairsInput = {
    id?: number
    businessEntityCode: string
    businessEntityName: string
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessEntityCreateOrConnectWithoutEntityUnitPairsInput = {
    where: BusinessEntityWhereUniqueInput
    create: XOR<BusinessEntityCreateWithoutEntityUnitPairsInput, BusinessEntityUncheckedCreateWithoutEntityUnitPairsInput>
  }

  export type BusinessUnitCreateWithoutEntityUnitPairsInput = {
    businessUnitCode: string
    businessUnitDesc: string
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitSalesPairs?: BusinessUnitSalesPairCreateNestedManyWithoutBusinessUnitInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairCreateNestedManyWithoutBusinessUnitInput
    businessUnitServicePairs?: BusinessUnitServicePairCreateNestedManyWithoutBusinessUnitInput
  }

  export type BusinessUnitUncheckedCreateWithoutEntityUnitPairsInput = {
    id?: number
    businessUnitCode: string
    businessUnitDesc: string
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitSalesPairs?: BusinessUnitSalesPairUncheckedCreateNestedManyWithoutBusinessUnitInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUncheckedCreateNestedManyWithoutBusinessUnitInput
    businessUnitServicePairs?: BusinessUnitServicePairUncheckedCreateNestedManyWithoutBusinessUnitInput
  }

  export type BusinessUnitCreateOrConnectWithoutEntityUnitPairsInput = {
    where: BusinessUnitWhereUniqueInput
    create: XOR<BusinessUnitCreateWithoutEntityUnitPairsInput, BusinessUnitUncheckedCreateWithoutEntityUnitPairsInput>
  }

  export type BusinessEntityUpsertWithoutEntityUnitPairsInput = {
    update: XOR<BusinessEntityUpdateWithoutEntityUnitPairsInput, BusinessEntityUncheckedUpdateWithoutEntityUnitPairsInput>
    create: XOR<BusinessEntityCreateWithoutEntityUnitPairsInput, BusinessEntityUncheckedCreateWithoutEntityUnitPairsInput>
    where?: BusinessEntityWhereInput
  }

  export type BusinessEntityUpdateToOneWithWhereWithoutEntityUnitPairsInput = {
    where?: BusinessEntityWhereInput
    data: XOR<BusinessEntityUpdateWithoutEntityUnitPairsInput, BusinessEntityUncheckedUpdateWithoutEntityUnitPairsInput>
  }

  export type BusinessEntityUpdateWithoutEntityUnitPairsInput = {
    businessEntityCode?: StringFieldUpdateOperationsInput | string
    businessEntityName?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessEntityUncheckedUpdateWithoutEntityUnitPairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessEntityCode?: StringFieldUpdateOperationsInput | string
    businessEntityName?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUnitUpsertWithoutEntityUnitPairsInput = {
    update: XOR<BusinessUnitUpdateWithoutEntityUnitPairsInput, BusinessUnitUncheckedUpdateWithoutEntityUnitPairsInput>
    create: XOR<BusinessUnitCreateWithoutEntityUnitPairsInput, BusinessUnitUncheckedCreateWithoutEntityUnitPairsInput>
    where?: BusinessUnitWhereInput
  }

  export type BusinessUnitUpdateToOneWithWhereWithoutEntityUnitPairsInput = {
    where?: BusinessUnitWhereInput
    data: XOR<BusinessUnitUpdateWithoutEntityUnitPairsInput, BusinessUnitUncheckedUpdateWithoutEntityUnitPairsInput>
  }

  export type BusinessUnitUpdateWithoutEntityUnitPairsInput = {
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    businessUnitDesc?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitSalesPairs?: BusinessUnitSalesPairUpdateManyWithoutBusinessUnitNestedInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUpdateManyWithoutBusinessUnitNestedInput
    businessUnitServicePairs?: BusinessUnitServicePairUpdateManyWithoutBusinessUnitNestedInput
  }

  export type BusinessUnitUncheckedUpdateWithoutEntityUnitPairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    businessUnitDesc?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitSalesPairs?: BusinessUnitSalesPairUncheckedUpdateManyWithoutBusinessUnitNestedInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUncheckedUpdateManyWithoutBusinessUnitNestedInput
    businessUnitServicePairs?: BusinessUnitServicePairUncheckedUpdateManyWithoutBusinessUnitNestedInput
  }

  export type SalesChannelOfficeTeamPairCreateWithoutSalesChannelInput = {
    salesOffice: SalesOfficeCreateNestedOneWithoutOfficeTeamPairsInput
    salesTeam: SalesTeamCreateNestedOneWithoutOfficeTeamPairsInput
  }

  export type SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesChannelInput = {
    id?: number
    salesOfficeId: string
    salesTeamCode: string
  }

  export type SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesChannelInput = {
    where: SalesChannelOfficeTeamPairWhereUniqueInput
    create: XOR<SalesChannelOfficeTeamPairCreateWithoutSalesChannelInput, SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesChannelInput>
  }

  export type SalesChannelOfficeTeamPairCreateManySalesChannelInputEnvelope = {
    data: SalesChannelOfficeTeamPairCreateManySalesChannelInput | SalesChannelOfficeTeamPairCreateManySalesChannelInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUnitSalesPairCreateWithoutSalesChannelInput = {
    id?: string
    businessUnit: BusinessUnitCreateNestedOneWithoutBusinessUnitSalesPairsInput
    salesOffice: SalesOfficeCreateNestedOneWithoutBusinessUnitSalesPairsInput
    salesTeam: SalesTeamCreateNestedOneWithoutBusinessUnitSalesPairsInput
  }

  export type BusinessUnitSalesPairUncheckedCreateWithoutSalesChannelInput = {
    id?: string
    businessUnitCode: string
    salesOfficeId: string
    salesTeamCode: string
  }

  export type BusinessUnitSalesPairCreateOrConnectWithoutSalesChannelInput = {
    where: BusinessUnitSalesPairWhereUniqueInput
    create: XOR<BusinessUnitSalesPairCreateWithoutSalesChannelInput, BusinessUnitSalesPairUncheckedCreateWithoutSalesChannelInput>
  }

  export type BusinessUnitSalesPairCreateManySalesChannelInputEnvelope = {
    data: BusinessUnitSalesPairCreateManySalesChannelInput | BusinessUnitSalesPairCreateManySalesChannelInput[]
    skipDuplicates?: boolean
  }

  export type SalesChannelOfficeTeamPairUpsertWithWhereUniqueWithoutSalesChannelInput = {
    where: SalesChannelOfficeTeamPairWhereUniqueInput
    update: XOR<SalesChannelOfficeTeamPairUpdateWithoutSalesChannelInput, SalesChannelOfficeTeamPairUncheckedUpdateWithoutSalesChannelInput>
    create: XOR<SalesChannelOfficeTeamPairCreateWithoutSalesChannelInput, SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesChannelInput>
  }

  export type SalesChannelOfficeTeamPairUpdateWithWhereUniqueWithoutSalesChannelInput = {
    where: SalesChannelOfficeTeamPairWhereUniqueInput
    data: XOR<SalesChannelOfficeTeamPairUpdateWithoutSalesChannelInput, SalesChannelOfficeTeamPairUncheckedUpdateWithoutSalesChannelInput>
  }

  export type SalesChannelOfficeTeamPairUpdateManyWithWhereWithoutSalesChannelInput = {
    where: SalesChannelOfficeTeamPairScalarWhereInput
    data: XOR<SalesChannelOfficeTeamPairUpdateManyMutationInput, SalesChannelOfficeTeamPairUncheckedUpdateManyWithoutSalesChannelInput>
  }

  export type SalesChannelOfficeTeamPairScalarWhereInput = {
    AND?: SalesChannelOfficeTeamPairScalarWhereInput | SalesChannelOfficeTeamPairScalarWhereInput[]
    OR?: SalesChannelOfficeTeamPairScalarWhereInput[]
    NOT?: SalesChannelOfficeTeamPairScalarWhereInput | SalesChannelOfficeTeamPairScalarWhereInput[]
    id?: IntFilter<"SalesChannelOfficeTeamPair"> | number
    salesChannelCode?: StringFilter<"SalesChannelOfficeTeamPair"> | string
    salesOfficeId?: StringFilter<"SalesChannelOfficeTeamPair"> | string
    salesTeamCode?: StringFilter<"SalesChannelOfficeTeamPair"> | string
  }

  export type BusinessUnitSalesPairUpsertWithWhereUniqueWithoutSalesChannelInput = {
    where: BusinessUnitSalesPairWhereUniqueInput
    update: XOR<BusinessUnitSalesPairUpdateWithoutSalesChannelInput, BusinessUnitSalesPairUncheckedUpdateWithoutSalesChannelInput>
    create: XOR<BusinessUnitSalesPairCreateWithoutSalesChannelInput, BusinessUnitSalesPairUncheckedCreateWithoutSalesChannelInput>
  }

  export type BusinessUnitSalesPairUpdateWithWhereUniqueWithoutSalesChannelInput = {
    where: BusinessUnitSalesPairWhereUniqueInput
    data: XOR<BusinessUnitSalesPairUpdateWithoutSalesChannelInput, BusinessUnitSalesPairUncheckedUpdateWithoutSalesChannelInput>
  }

  export type BusinessUnitSalesPairUpdateManyWithWhereWithoutSalesChannelInput = {
    where: BusinessUnitSalesPairScalarWhereInput
    data: XOR<BusinessUnitSalesPairUpdateManyMutationInput, BusinessUnitSalesPairUncheckedUpdateManyWithoutSalesChannelInput>
  }

  export type SalesChannelOfficeTeamPairCreateWithoutSalesOfficeInput = {
    salesChannel: SalesChannelCreateNestedOneWithoutChannelOfficePairsInput
    salesTeam: SalesTeamCreateNestedOneWithoutOfficeTeamPairsInput
  }

  export type SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesOfficeInput = {
    id?: number
    salesChannelCode: string
    salesTeamCode: string
  }

  export type SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesOfficeInput = {
    where: SalesChannelOfficeTeamPairWhereUniqueInput
    create: XOR<SalesChannelOfficeTeamPairCreateWithoutSalesOfficeInput, SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesOfficeInput>
  }

  export type SalesChannelOfficeTeamPairCreateManySalesOfficeInputEnvelope = {
    data: SalesChannelOfficeTeamPairCreateManySalesOfficeInput | SalesChannelOfficeTeamPairCreateManySalesOfficeInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUnitSalesPairCreateWithoutSalesOfficeInput = {
    id?: string
    businessUnit: BusinessUnitCreateNestedOneWithoutBusinessUnitSalesPairsInput
    salesChannel: SalesChannelCreateNestedOneWithoutBusinessUnitSalesPairsInput
    salesTeam: SalesTeamCreateNestedOneWithoutBusinessUnitSalesPairsInput
  }

  export type BusinessUnitSalesPairUncheckedCreateWithoutSalesOfficeInput = {
    id?: string
    businessUnitCode: string
    salesChannelCode: string
    salesTeamCode: string
  }

  export type BusinessUnitSalesPairCreateOrConnectWithoutSalesOfficeInput = {
    where: BusinessUnitSalesPairWhereUniqueInput
    create: XOR<BusinessUnitSalesPairCreateWithoutSalesOfficeInput, BusinessUnitSalesPairUncheckedCreateWithoutSalesOfficeInput>
  }

  export type BusinessUnitSalesPairCreateManySalesOfficeInputEnvelope = {
    data: BusinessUnitSalesPairCreateManySalesOfficeInput | BusinessUnitSalesPairCreateManySalesOfficeInput[]
    skipDuplicates?: boolean
  }

  export type SalesChannelOfficeTeamPairUpsertWithWhereUniqueWithoutSalesOfficeInput = {
    where: SalesChannelOfficeTeamPairWhereUniqueInput
    update: XOR<SalesChannelOfficeTeamPairUpdateWithoutSalesOfficeInput, SalesChannelOfficeTeamPairUncheckedUpdateWithoutSalesOfficeInput>
    create: XOR<SalesChannelOfficeTeamPairCreateWithoutSalesOfficeInput, SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesOfficeInput>
  }

  export type SalesChannelOfficeTeamPairUpdateWithWhereUniqueWithoutSalesOfficeInput = {
    where: SalesChannelOfficeTeamPairWhereUniqueInput
    data: XOR<SalesChannelOfficeTeamPairUpdateWithoutSalesOfficeInput, SalesChannelOfficeTeamPairUncheckedUpdateWithoutSalesOfficeInput>
  }

  export type SalesChannelOfficeTeamPairUpdateManyWithWhereWithoutSalesOfficeInput = {
    where: SalesChannelOfficeTeamPairScalarWhereInput
    data: XOR<SalesChannelOfficeTeamPairUpdateManyMutationInput, SalesChannelOfficeTeamPairUncheckedUpdateManyWithoutSalesOfficeInput>
  }

  export type BusinessUnitSalesPairUpsertWithWhereUniqueWithoutSalesOfficeInput = {
    where: BusinessUnitSalesPairWhereUniqueInput
    update: XOR<BusinessUnitSalesPairUpdateWithoutSalesOfficeInput, BusinessUnitSalesPairUncheckedUpdateWithoutSalesOfficeInput>
    create: XOR<BusinessUnitSalesPairCreateWithoutSalesOfficeInput, BusinessUnitSalesPairUncheckedCreateWithoutSalesOfficeInput>
  }

  export type BusinessUnitSalesPairUpdateWithWhereUniqueWithoutSalesOfficeInput = {
    where: BusinessUnitSalesPairWhereUniqueInput
    data: XOR<BusinessUnitSalesPairUpdateWithoutSalesOfficeInput, BusinessUnitSalesPairUncheckedUpdateWithoutSalesOfficeInput>
  }

  export type BusinessUnitSalesPairUpdateManyWithWhereWithoutSalesOfficeInput = {
    where: BusinessUnitSalesPairScalarWhereInput
    data: XOR<BusinessUnitSalesPairUpdateManyMutationInput, BusinessUnitSalesPairUncheckedUpdateManyWithoutSalesOfficeInput>
  }

  export type SalesChannelOfficeTeamPairCreateWithoutSalesTeamInput = {
    salesChannel: SalesChannelCreateNestedOneWithoutChannelOfficePairsInput
    salesOffice: SalesOfficeCreateNestedOneWithoutOfficeTeamPairsInput
  }

  export type SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesTeamInput = {
    id?: number
    salesChannelCode: string
    salesOfficeId: string
  }

  export type SalesChannelOfficeTeamPairCreateOrConnectWithoutSalesTeamInput = {
    where: SalesChannelOfficeTeamPairWhereUniqueInput
    create: XOR<SalesChannelOfficeTeamPairCreateWithoutSalesTeamInput, SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesTeamInput>
  }

  export type SalesChannelOfficeTeamPairCreateManySalesTeamInputEnvelope = {
    data: SalesChannelOfficeTeamPairCreateManySalesTeamInput | SalesChannelOfficeTeamPairCreateManySalesTeamInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUnitSalesPairCreateWithoutSalesTeamInput = {
    id?: string
    businessUnit: BusinessUnitCreateNestedOneWithoutBusinessUnitSalesPairsInput
    salesChannel: SalesChannelCreateNestedOneWithoutBusinessUnitSalesPairsInput
    salesOffice: SalesOfficeCreateNestedOneWithoutBusinessUnitSalesPairsInput
  }

  export type BusinessUnitSalesPairUncheckedCreateWithoutSalesTeamInput = {
    id?: string
    businessUnitCode: string
    salesChannelCode: string
    salesOfficeId: string
  }

  export type BusinessUnitSalesPairCreateOrConnectWithoutSalesTeamInput = {
    where: BusinessUnitSalesPairWhereUniqueInput
    create: XOR<BusinessUnitSalesPairCreateWithoutSalesTeamInput, BusinessUnitSalesPairUncheckedCreateWithoutSalesTeamInput>
  }

  export type BusinessUnitSalesPairCreateManySalesTeamInputEnvelope = {
    data: BusinessUnitSalesPairCreateManySalesTeamInput | BusinessUnitSalesPairCreateManySalesTeamInput[]
    skipDuplicates?: boolean
  }

  export type SalesChannelOfficeTeamPairUpsertWithWhereUniqueWithoutSalesTeamInput = {
    where: SalesChannelOfficeTeamPairWhereUniqueInput
    update: XOR<SalesChannelOfficeTeamPairUpdateWithoutSalesTeamInput, SalesChannelOfficeTeamPairUncheckedUpdateWithoutSalesTeamInput>
    create: XOR<SalesChannelOfficeTeamPairCreateWithoutSalesTeamInput, SalesChannelOfficeTeamPairUncheckedCreateWithoutSalesTeamInput>
  }

  export type SalesChannelOfficeTeamPairUpdateWithWhereUniqueWithoutSalesTeamInput = {
    where: SalesChannelOfficeTeamPairWhereUniqueInput
    data: XOR<SalesChannelOfficeTeamPairUpdateWithoutSalesTeamInput, SalesChannelOfficeTeamPairUncheckedUpdateWithoutSalesTeamInput>
  }

  export type SalesChannelOfficeTeamPairUpdateManyWithWhereWithoutSalesTeamInput = {
    where: SalesChannelOfficeTeamPairScalarWhereInput
    data: XOR<SalesChannelOfficeTeamPairUpdateManyMutationInput, SalesChannelOfficeTeamPairUncheckedUpdateManyWithoutSalesTeamInput>
  }

  export type BusinessUnitSalesPairUpsertWithWhereUniqueWithoutSalesTeamInput = {
    where: BusinessUnitSalesPairWhereUniqueInput
    update: XOR<BusinessUnitSalesPairUpdateWithoutSalesTeamInput, BusinessUnitSalesPairUncheckedUpdateWithoutSalesTeamInput>
    create: XOR<BusinessUnitSalesPairCreateWithoutSalesTeamInput, BusinessUnitSalesPairUncheckedCreateWithoutSalesTeamInput>
  }

  export type BusinessUnitSalesPairUpdateWithWhereUniqueWithoutSalesTeamInput = {
    where: BusinessUnitSalesPairWhereUniqueInput
    data: XOR<BusinessUnitSalesPairUpdateWithoutSalesTeamInput, BusinessUnitSalesPairUncheckedUpdateWithoutSalesTeamInput>
  }

  export type BusinessUnitSalesPairUpdateManyWithWhereWithoutSalesTeamInput = {
    where: BusinessUnitSalesPairScalarWhereInput
    data: XOR<BusinessUnitSalesPairUpdateManyMutationInput, BusinessUnitSalesPairUncheckedUpdateManyWithoutSalesTeamInput>
  }

  export type SalesChannelCreateWithoutChannelOfficePairsInput = {
    salesChannelCode: string
    salesChannelName: string
    salesChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitSalesPairs?: BusinessUnitSalesPairCreateNestedManyWithoutSalesChannelInput
  }

  export type SalesChannelUncheckedCreateWithoutChannelOfficePairsInput = {
    id?: number
    salesChannelCode: string
    salesChannelName: string
    salesChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitSalesPairs?: BusinessUnitSalesPairUncheckedCreateNestedManyWithoutSalesChannelInput
  }

  export type SalesChannelCreateOrConnectWithoutChannelOfficePairsInput = {
    where: SalesChannelWhereUniqueInput
    create: XOR<SalesChannelCreateWithoutChannelOfficePairsInput, SalesChannelUncheckedCreateWithoutChannelOfficePairsInput>
  }

  export type SalesOfficeCreateWithoutOfficeTeamPairsInput = {
    salesOfficeId: string
    organizationName: string
    salesOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitSalesPairs?: BusinessUnitSalesPairCreateNestedManyWithoutSalesOfficeInput
  }

  export type SalesOfficeUncheckedCreateWithoutOfficeTeamPairsInput = {
    id?: number
    salesOfficeId: string
    organizationName: string
    salesOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitSalesPairs?: BusinessUnitSalesPairUncheckedCreateNestedManyWithoutSalesOfficeInput
  }

  export type SalesOfficeCreateOrConnectWithoutOfficeTeamPairsInput = {
    where: SalesOfficeWhereUniqueInput
    create: XOR<SalesOfficeCreateWithoutOfficeTeamPairsInput, SalesOfficeUncheckedCreateWithoutOfficeTeamPairsInput>
  }

  export type SalesTeamCreateWithoutOfficeTeamPairsInput = {
    salesTeamCode: string
    salesTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitSalesPairs?: BusinessUnitSalesPairCreateNestedManyWithoutSalesTeamInput
  }

  export type SalesTeamUncheckedCreateWithoutOfficeTeamPairsInput = {
    id?: number
    salesTeamCode: string
    salesTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitSalesPairs?: BusinessUnitSalesPairUncheckedCreateNestedManyWithoutSalesTeamInput
  }

  export type SalesTeamCreateOrConnectWithoutOfficeTeamPairsInput = {
    where: SalesTeamWhereUniqueInput
    create: XOR<SalesTeamCreateWithoutOfficeTeamPairsInput, SalesTeamUncheckedCreateWithoutOfficeTeamPairsInput>
  }

  export type SalesChannelUpsertWithoutChannelOfficePairsInput = {
    update: XOR<SalesChannelUpdateWithoutChannelOfficePairsInput, SalesChannelUncheckedUpdateWithoutChannelOfficePairsInput>
    create: XOR<SalesChannelCreateWithoutChannelOfficePairsInput, SalesChannelUncheckedCreateWithoutChannelOfficePairsInput>
    where?: SalesChannelWhereInput
  }

  export type SalesChannelUpdateToOneWithWhereWithoutChannelOfficePairsInput = {
    where?: SalesChannelWhereInput
    data: XOR<SalesChannelUpdateWithoutChannelOfficePairsInput, SalesChannelUncheckedUpdateWithoutChannelOfficePairsInput>
  }

  export type SalesChannelUpdateWithoutChannelOfficePairsInput = {
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesChannelName?: StringFieldUpdateOperationsInput | string
    salesChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitSalesPairs?: BusinessUnitSalesPairUpdateManyWithoutSalesChannelNestedInput
  }

  export type SalesChannelUncheckedUpdateWithoutChannelOfficePairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesChannelName?: StringFieldUpdateOperationsInput | string
    salesChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitSalesPairs?: BusinessUnitSalesPairUncheckedUpdateManyWithoutSalesChannelNestedInput
  }

  export type SalesOfficeUpsertWithoutOfficeTeamPairsInput = {
    update: XOR<SalesOfficeUpdateWithoutOfficeTeamPairsInput, SalesOfficeUncheckedUpdateWithoutOfficeTeamPairsInput>
    create: XOR<SalesOfficeCreateWithoutOfficeTeamPairsInput, SalesOfficeUncheckedCreateWithoutOfficeTeamPairsInput>
    where?: SalesOfficeWhereInput
  }

  export type SalesOfficeUpdateToOneWithWhereWithoutOfficeTeamPairsInput = {
    where?: SalesOfficeWhereInput
    data: XOR<SalesOfficeUpdateWithoutOfficeTeamPairsInput, SalesOfficeUncheckedUpdateWithoutOfficeTeamPairsInput>
  }

  export type SalesOfficeUpdateWithoutOfficeTeamPairsInput = {
    salesOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    salesOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitSalesPairs?: BusinessUnitSalesPairUpdateManyWithoutSalesOfficeNestedInput
  }

  export type SalesOfficeUncheckedUpdateWithoutOfficeTeamPairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    salesOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitSalesPairs?: BusinessUnitSalesPairUncheckedUpdateManyWithoutSalesOfficeNestedInput
  }

  export type SalesTeamUpsertWithoutOfficeTeamPairsInput = {
    update: XOR<SalesTeamUpdateWithoutOfficeTeamPairsInput, SalesTeamUncheckedUpdateWithoutOfficeTeamPairsInput>
    create: XOR<SalesTeamCreateWithoutOfficeTeamPairsInput, SalesTeamUncheckedCreateWithoutOfficeTeamPairsInput>
    where?: SalesTeamWhereInput
  }

  export type SalesTeamUpdateToOneWithWhereWithoutOfficeTeamPairsInput = {
    where?: SalesTeamWhereInput
    data: XOR<SalesTeamUpdateWithoutOfficeTeamPairsInput, SalesTeamUncheckedUpdateWithoutOfficeTeamPairsInput>
  }

  export type SalesTeamUpdateWithoutOfficeTeamPairsInput = {
    salesTeamCode?: StringFieldUpdateOperationsInput | string
    salesTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitSalesPairs?: BusinessUnitSalesPairUpdateManyWithoutSalesTeamNestedInput
  }

  export type SalesTeamUncheckedUpdateWithoutOfficeTeamPairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesTeamCode?: StringFieldUpdateOperationsInput | string
    salesTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitSalesPairs?: BusinessUnitSalesPairUncheckedUpdateManyWithoutSalesTeamNestedInput
  }

  export type MarketingChannelOfficeTeamPairCreateWithoutMarketingChannelInput = {
    marketingOffice: MarketingOfficeCreateNestedOneWithoutOfficeTeamPairsInput
    marketingTeam: MarketingTeamCreateNestedOneWithoutOfficeTeamPairsInput
  }

  export type MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingChannelInput = {
    id?: number
    marketingOfficeId: string
    marketingTeamCode: string
  }

  export type MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingChannelInput = {
    where: MarketingChannelOfficeTeamPairWhereUniqueInput
    create: XOR<MarketingChannelOfficeTeamPairCreateWithoutMarketingChannelInput, MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingChannelInput>
  }

  export type MarketingChannelOfficeTeamPairCreateManyMarketingChannelInputEnvelope = {
    data: MarketingChannelOfficeTeamPairCreateManyMarketingChannelInput | MarketingChannelOfficeTeamPairCreateManyMarketingChannelInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUnitMarketingPairCreateWithoutMarketingChannelInput = {
    id?: string
    businessUnit: BusinessUnitCreateNestedOneWithoutBusinessUnitMarketingPairsInput
    marketingOffice: MarketingOfficeCreateNestedOneWithoutBusinessUnitMarketingPairsInput
    marketingTeam: MarketingTeamCreateNestedOneWithoutBusinessUnitMarketingPairsInput
  }

  export type BusinessUnitMarketingPairUncheckedCreateWithoutMarketingChannelInput = {
    id?: string
    businessUnitCode: string
    marketingOfficeId: string
    marketingTeamCode: string
  }

  export type BusinessUnitMarketingPairCreateOrConnectWithoutMarketingChannelInput = {
    where: BusinessUnitMarketingPairWhereUniqueInput
    create: XOR<BusinessUnitMarketingPairCreateWithoutMarketingChannelInput, BusinessUnitMarketingPairUncheckedCreateWithoutMarketingChannelInput>
  }

  export type BusinessUnitMarketingPairCreateManyMarketingChannelInputEnvelope = {
    data: BusinessUnitMarketingPairCreateManyMarketingChannelInput | BusinessUnitMarketingPairCreateManyMarketingChannelInput[]
    skipDuplicates?: boolean
  }

  export type MarketingChannelOfficeTeamPairUpsertWithWhereUniqueWithoutMarketingChannelInput = {
    where: MarketingChannelOfficeTeamPairWhereUniqueInput
    update: XOR<MarketingChannelOfficeTeamPairUpdateWithoutMarketingChannelInput, MarketingChannelOfficeTeamPairUncheckedUpdateWithoutMarketingChannelInput>
    create: XOR<MarketingChannelOfficeTeamPairCreateWithoutMarketingChannelInput, MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingChannelInput>
  }

  export type MarketingChannelOfficeTeamPairUpdateWithWhereUniqueWithoutMarketingChannelInput = {
    where: MarketingChannelOfficeTeamPairWhereUniqueInput
    data: XOR<MarketingChannelOfficeTeamPairUpdateWithoutMarketingChannelInput, MarketingChannelOfficeTeamPairUncheckedUpdateWithoutMarketingChannelInput>
  }

  export type MarketingChannelOfficeTeamPairUpdateManyWithWhereWithoutMarketingChannelInput = {
    where: MarketingChannelOfficeTeamPairScalarWhereInput
    data: XOR<MarketingChannelOfficeTeamPairUpdateManyMutationInput, MarketingChannelOfficeTeamPairUncheckedUpdateManyWithoutMarketingChannelInput>
  }

  export type MarketingChannelOfficeTeamPairScalarWhereInput = {
    AND?: MarketingChannelOfficeTeamPairScalarWhereInput | MarketingChannelOfficeTeamPairScalarWhereInput[]
    OR?: MarketingChannelOfficeTeamPairScalarWhereInput[]
    NOT?: MarketingChannelOfficeTeamPairScalarWhereInput | MarketingChannelOfficeTeamPairScalarWhereInput[]
    id?: IntFilter<"MarketingChannelOfficeTeamPair"> | number
    marketingChannelCode?: StringFilter<"MarketingChannelOfficeTeamPair"> | string
    marketingOfficeId?: StringFilter<"MarketingChannelOfficeTeamPair"> | string
    marketingTeamCode?: StringFilter<"MarketingChannelOfficeTeamPair"> | string
  }

  export type BusinessUnitMarketingPairUpsertWithWhereUniqueWithoutMarketingChannelInput = {
    where: BusinessUnitMarketingPairWhereUniqueInput
    update: XOR<BusinessUnitMarketingPairUpdateWithoutMarketingChannelInput, BusinessUnitMarketingPairUncheckedUpdateWithoutMarketingChannelInput>
    create: XOR<BusinessUnitMarketingPairCreateWithoutMarketingChannelInput, BusinessUnitMarketingPairUncheckedCreateWithoutMarketingChannelInput>
  }

  export type BusinessUnitMarketingPairUpdateWithWhereUniqueWithoutMarketingChannelInput = {
    where: BusinessUnitMarketingPairWhereUniqueInput
    data: XOR<BusinessUnitMarketingPairUpdateWithoutMarketingChannelInput, BusinessUnitMarketingPairUncheckedUpdateWithoutMarketingChannelInput>
  }

  export type BusinessUnitMarketingPairUpdateManyWithWhereWithoutMarketingChannelInput = {
    where: BusinessUnitMarketingPairScalarWhereInput
    data: XOR<BusinessUnitMarketingPairUpdateManyMutationInput, BusinessUnitMarketingPairUncheckedUpdateManyWithoutMarketingChannelInput>
  }

  export type MarketingChannelOfficeTeamPairCreateWithoutMarketingOfficeInput = {
    marketingChannel: MarketingChannelCreateNestedOneWithoutChannelOfficePairsInput
    marketingTeam: MarketingTeamCreateNestedOneWithoutOfficeTeamPairsInput
  }

  export type MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingOfficeInput = {
    id?: number
    marketingChannelCode: string
    marketingTeamCode: string
  }

  export type MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingOfficeInput = {
    where: MarketingChannelOfficeTeamPairWhereUniqueInput
    create: XOR<MarketingChannelOfficeTeamPairCreateWithoutMarketingOfficeInput, MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingOfficeInput>
  }

  export type MarketingChannelOfficeTeamPairCreateManyMarketingOfficeInputEnvelope = {
    data: MarketingChannelOfficeTeamPairCreateManyMarketingOfficeInput | MarketingChannelOfficeTeamPairCreateManyMarketingOfficeInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUnitMarketingPairCreateWithoutMarketingOfficeInput = {
    id?: string
    businessUnit: BusinessUnitCreateNestedOneWithoutBusinessUnitMarketingPairsInput
    marketingChannel: MarketingChannelCreateNestedOneWithoutBusinessUnitMarketingPairsInput
    marketingTeam: MarketingTeamCreateNestedOneWithoutBusinessUnitMarketingPairsInput
  }

  export type BusinessUnitMarketingPairUncheckedCreateWithoutMarketingOfficeInput = {
    id?: string
    businessUnitCode: string
    marketingChannelCode: string
    marketingTeamCode: string
  }

  export type BusinessUnitMarketingPairCreateOrConnectWithoutMarketingOfficeInput = {
    where: BusinessUnitMarketingPairWhereUniqueInput
    create: XOR<BusinessUnitMarketingPairCreateWithoutMarketingOfficeInput, BusinessUnitMarketingPairUncheckedCreateWithoutMarketingOfficeInput>
  }

  export type BusinessUnitMarketingPairCreateManyMarketingOfficeInputEnvelope = {
    data: BusinessUnitMarketingPairCreateManyMarketingOfficeInput | BusinessUnitMarketingPairCreateManyMarketingOfficeInput[]
    skipDuplicates?: boolean
  }

  export type MarketingChannelOfficeTeamPairUpsertWithWhereUniqueWithoutMarketingOfficeInput = {
    where: MarketingChannelOfficeTeamPairWhereUniqueInput
    update: XOR<MarketingChannelOfficeTeamPairUpdateWithoutMarketingOfficeInput, MarketingChannelOfficeTeamPairUncheckedUpdateWithoutMarketingOfficeInput>
    create: XOR<MarketingChannelOfficeTeamPairCreateWithoutMarketingOfficeInput, MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingOfficeInput>
  }

  export type MarketingChannelOfficeTeamPairUpdateWithWhereUniqueWithoutMarketingOfficeInput = {
    where: MarketingChannelOfficeTeamPairWhereUniqueInput
    data: XOR<MarketingChannelOfficeTeamPairUpdateWithoutMarketingOfficeInput, MarketingChannelOfficeTeamPairUncheckedUpdateWithoutMarketingOfficeInput>
  }

  export type MarketingChannelOfficeTeamPairUpdateManyWithWhereWithoutMarketingOfficeInput = {
    where: MarketingChannelOfficeTeamPairScalarWhereInput
    data: XOR<MarketingChannelOfficeTeamPairUpdateManyMutationInput, MarketingChannelOfficeTeamPairUncheckedUpdateManyWithoutMarketingOfficeInput>
  }

  export type BusinessUnitMarketingPairUpsertWithWhereUniqueWithoutMarketingOfficeInput = {
    where: BusinessUnitMarketingPairWhereUniqueInput
    update: XOR<BusinessUnitMarketingPairUpdateWithoutMarketingOfficeInput, BusinessUnitMarketingPairUncheckedUpdateWithoutMarketingOfficeInput>
    create: XOR<BusinessUnitMarketingPairCreateWithoutMarketingOfficeInput, BusinessUnitMarketingPairUncheckedCreateWithoutMarketingOfficeInput>
  }

  export type BusinessUnitMarketingPairUpdateWithWhereUniqueWithoutMarketingOfficeInput = {
    where: BusinessUnitMarketingPairWhereUniqueInput
    data: XOR<BusinessUnitMarketingPairUpdateWithoutMarketingOfficeInput, BusinessUnitMarketingPairUncheckedUpdateWithoutMarketingOfficeInput>
  }

  export type BusinessUnitMarketingPairUpdateManyWithWhereWithoutMarketingOfficeInput = {
    where: BusinessUnitMarketingPairScalarWhereInput
    data: XOR<BusinessUnitMarketingPairUpdateManyMutationInput, BusinessUnitMarketingPairUncheckedUpdateManyWithoutMarketingOfficeInput>
  }

  export type MarketingChannelOfficeTeamPairCreateWithoutMarketingTeamInput = {
    marketingChannel: MarketingChannelCreateNestedOneWithoutChannelOfficePairsInput
    marketingOffice: MarketingOfficeCreateNestedOneWithoutOfficeTeamPairsInput
  }

  export type MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingTeamInput = {
    id?: number
    marketingChannelCode: string
    marketingOfficeId: string
  }

  export type MarketingChannelOfficeTeamPairCreateOrConnectWithoutMarketingTeamInput = {
    where: MarketingChannelOfficeTeamPairWhereUniqueInput
    create: XOR<MarketingChannelOfficeTeamPairCreateWithoutMarketingTeamInput, MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingTeamInput>
  }

  export type MarketingChannelOfficeTeamPairCreateManyMarketingTeamInputEnvelope = {
    data: MarketingChannelOfficeTeamPairCreateManyMarketingTeamInput | MarketingChannelOfficeTeamPairCreateManyMarketingTeamInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUnitMarketingPairCreateWithoutMarketingTeamInput = {
    id?: string
    businessUnit: BusinessUnitCreateNestedOneWithoutBusinessUnitMarketingPairsInput
    marketingChannel: MarketingChannelCreateNestedOneWithoutBusinessUnitMarketingPairsInput
    marketingOffice: MarketingOfficeCreateNestedOneWithoutBusinessUnitMarketingPairsInput
  }

  export type BusinessUnitMarketingPairUncheckedCreateWithoutMarketingTeamInput = {
    id?: string
    businessUnitCode: string
    marketingChannelCode: string
    marketingOfficeId: string
  }

  export type BusinessUnitMarketingPairCreateOrConnectWithoutMarketingTeamInput = {
    where: BusinessUnitMarketingPairWhereUniqueInput
    create: XOR<BusinessUnitMarketingPairCreateWithoutMarketingTeamInput, BusinessUnitMarketingPairUncheckedCreateWithoutMarketingTeamInput>
  }

  export type BusinessUnitMarketingPairCreateManyMarketingTeamInputEnvelope = {
    data: BusinessUnitMarketingPairCreateManyMarketingTeamInput | BusinessUnitMarketingPairCreateManyMarketingTeamInput[]
    skipDuplicates?: boolean
  }

  export type MarketingChannelOfficeTeamPairUpsertWithWhereUniqueWithoutMarketingTeamInput = {
    where: MarketingChannelOfficeTeamPairWhereUniqueInput
    update: XOR<MarketingChannelOfficeTeamPairUpdateWithoutMarketingTeamInput, MarketingChannelOfficeTeamPairUncheckedUpdateWithoutMarketingTeamInput>
    create: XOR<MarketingChannelOfficeTeamPairCreateWithoutMarketingTeamInput, MarketingChannelOfficeTeamPairUncheckedCreateWithoutMarketingTeamInput>
  }

  export type MarketingChannelOfficeTeamPairUpdateWithWhereUniqueWithoutMarketingTeamInput = {
    where: MarketingChannelOfficeTeamPairWhereUniqueInput
    data: XOR<MarketingChannelOfficeTeamPairUpdateWithoutMarketingTeamInput, MarketingChannelOfficeTeamPairUncheckedUpdateWithoutMarketingTeamInput>
  }

  export type MarketingChannelOfficeTeamPairUpdateManyWithWhereWithoutMarketingTeamInput = {
    where: MarketingChannelOfficeTeamPairScalarWhereInput
    data: XOR<MarketingChannelOfficeTeamPairUpdateManyMutationInput, MarketingChannelOfficeTeamPairUncheckedUpdateManyWithoutMarketingTeamInput>
  }

  export type BusinessUnitMarketingPairUpsertWithWhereUniqueWithoutMarketingTeamInput = {
    where: BusinessUnitMarketingPairWhereUniqueInput
    update: XOR<BusinessUnitMarketingPairUpdateWithoutMarketingTeamInput, BusinessUnitMarketingPairUncheckedUpdateWithoutMarketingTeamInput>
    create: XOR<BusinessUnitMarketingPairCreateWithoutMarketingTeamInput, BusinessUnitMarketingPairUncheckedCreateWithoutMarketingTeamInput>
  }

  export type BusinessUnitMarketingPairUpdateWithWhereUniqueWithoutMarketingTeamInput = {
    where: BusinessUnitMarketingPairWhereUniqueInput
    data: XOR<BusinessUnitMarketingPairUpdateWithoutMarketingTeamInput, BusinessUnitMarketingPairUncheckedUpdateWithoutMarketingTeamInput>
  }

  export type BusinessUnitMarketingPairUpdateManyWithWhereWithoutMarketingTeamInput = {
    where: BusinessUnitMarketingPairScalarWhereInput
    data: XOR<BusinessUnitMarketingPairUpdateManyMutationInput, BusinessUnitMarketingPairUncheckedUpdateManyWithoutMarketingTeamInput>
  }

  export type MarketingChannelCreateWithoutChannelOfficePairsInput = {
    marketingChannelCode: string
    marketingChannelName: string
    marketingChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitMarketingPairs?: BusinessUnitMarketingPairCreateNestedManyWithoutMarketingChannelInput
  }

  export type MarketingChannelUncheckedCreateWithoutChannelOfficePairsInput = {
    id?: number
    marketingChannelCode: string
    marketingChannelName: string
    marketingChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUncheckedCreateNestedManyWithoutMarketingChannelInput
  }

  export type MarketingChannelCreateOrConnectWithoutChannelOfficePairsInput = {
    where: MarketingChannelWhereUniqueInput
    create: XOR<MarketingChannelCreateWithoutChannelOfficePairsInput, MarketingChannelUncheckedCreateWithoutChannelOfficePairsInput>
  }

  export type MarketingOfficeCreateWithoutOfficeTeamPairsInput = {
    marketingOfficeId: string
    organizationName: string
    marketingOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitMarketingPairs?: BusinessUnitMarketingPairCreateNestedManyWithoutMarketingOfficeInput
  }

  export type MarketingOfficeUncheckedCreateWithoutOfficeTeamPairsInput = {
    id?: number
    marketingOfficeId: string
    organizationName: string
    marketingOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUncheckedCreateNestedManyWithoutMarketingOfficeInput
  }

  export type MarketingOfficeCreateOrConnectWithoutOfficeTeamPairsInput = {
    where: MarketingOfficeWhereUniqueInput
    create: XOR<MarketingOfficeCreateWithoutOfficeTeamPairsInput, MarketingOfficeUncheckedCreateWithoutOfficeTeamPairsInput>
  }

  export type MarketingTeamCreateWithoutOfficeTeamPairsInput = {
    marketingTeamCode: string
    marketingTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitMarketingPairs?: BusinessUnitMarketingPairCreateNestedManyWithoutMarketingTeamInput
  }

  export type MarketingTeamUncheckedCreateWithoutOfficeTeamPairsInput = {
    id?: number
    marketingTeamCode: string
    marketingTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUncheckedCreateNestedManyWithoutMarketingTeamInput
  }

  export type MarketingTeamCreateOrConnectWithoutOfficeTeamPairsInput = {
    where: MarketingTeamWhereUniqueInput
    create: XOR<MarketingTeamCreateWithoutOfficeTeamPairsInput, MarketingTeamUncheckedCreateWithoutOfficeTeamPairsInput>
  }

  export type MarketingChannelUpsertWithoutChannelOfficePairsInput = {
    update: XOR<MarketingChannelUpdateWithoutChannelOfficePairsInput, MarketingChannelUncheckedUpdateWithoutChannelOfficePairsInput>
    create: XOR<MarketingChannelCreateWithoutChannelOfficePairsInput, MarketingChannelUncheckedCreateWithoutChannelOfficePairsInput>
    where?: MarketingChannelWhereInput
  }

  export type MarketingChannelUpdateToOneWithWhereWithoutChannelOfficePairsInput = {
    where?: MarketingChannelWhereInput
    data: XOR<MarketingChannelUpdateWithoutChannelOfficePairsInput, MarketingChannelUncheckedUpdateWithoutChannelOfficePairsInput>
  }

  export type MarketingChannelUpdateWithoutChannelOfficePairsInput = {
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingChannelName?: StringFieldUpdateOperationsInput | string
    marketingChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUpdateManyWithoutMarketingChannelNestedInput
  }

  export type MarketingChannelUncheckedUpdateWithoutChannelOfficePairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingChannelName?: StringFieldUpdateOperationsInput | string
    marketingChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUncheckedUpdateManyWithoutMarketingChannelNestedInput
  }

  export type MarketingOfficeUpsertWithoutOfficeTeamPairsInput = {
    update: XOR<MarketingOfficeUpdateWithoutOfficeTeamPairsInput, MarketingOfficeUncheckedUpdateWithoutOfficeTeamPairsInput>
    create: XOR<MarketingOfficeCreateWithoutOfficeTeamPairsInput, MarketingOfficeUncheckedCreateWithoutOfficeTeamPairsInput>
    where?: MarketingOfficeWhereInput
  }

  export type MarketingOfficeUpdateToOneWithWhereWithoutOfficeTeamPairsInput = {
    where?: MarketingOfficeWhereInput
    data: XOR<MarketingOfficeUpdateWithoutOfficeTeamPairsInput, MarketingOfficeUncheckedUpdateWithoutOfficeTeamPairsInput>
  }

  export type MarketingOfficeUpdateWithoutOfficeTeamPairsInput = {
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    marketingOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUpdateManyWithoutMarketingOfficeNestedInput
  }

  export type MarketingOfficeUncheckedUpdateWithoutOfficeTeamPairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    marketingOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUncheckedUpdateManyWithoutMarketingOfficeNestedInput
  }

  export type MarketingTeamUpsertWithoutOfficeTeamPairsInput = {
    update: XOR<MarketingTeamUpdateWithoutOfficeTeamPairsInput, MarketingTeamUncheckedUpdateWithoutOfficeTeamPairsInput>
    create: XOR<MarketingTeamCreateWithoutOfficeTeamPairsInput, MarketingTeamUncheckedCreateWithoutOfficeTeamPairsInput>
    where?: MarketingTeamWhereInput
  }

  export type MarketingTeamUpdateToOneWithWhereWithoutOfficeTeamPairsInput = {
    where?: MarketingTeamWhereInput
    data: XOR<MarketingTeamUpdateWithoutOfficeTeamPairsInput, MarketingTeamUncheckedUpdateWithoutOfficeTeamPairsInput>
  }

  export type MarketingTeamUpdateWithoutOfficeTeamPairsInput = {
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
    marketingTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUpdateManyWithoutMarketingTeamNestedInput
  }

  export type MarketingTeamUncheckedUpdateWithoutOfficeTeamPairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
    marketingTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUncheckedUpdateManyWithoutMarketingTeamNestedInput
  }

  export type ServiceChannelOfficeTeamPairCreateWithoutServiceChannelInput = {
    serviceOffice: ServiceOfficeCreateNestedOneWithoutOfficeTeamPairsInput
    serviceTeam: ServiceTeamCreateNestedOneWithoutOfficeTeamPairsInput
  }

  export type ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceChannelInput = {
    id?: number
    serviceOfficeId: string
    serviceTeamCode: string
  }

  export type ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceChannelInput = {
    where: ServiceChannelOfficeTeamPairWhereUniqueInput
    create: XOR<ServiceChannelOfficeTeamPairCreateWithoutServiceChannelInput, ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceChannelInput>
  }

  export type ServiceChannelOfficeTeamPairCreateManyServiceChannelInputEnvelope = {
    data: ServiceChannelOfficeTeamPairCreateManyServiceChannelInput | ServiceChannelOfficeTeamPairCreateManyServiceChannelInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUnitServicePairCreateWithoutServiceChannelInput = {
    id?: string
    businessUnit: BusinessUnitCreateNestedOneWithoutBusinessUnitServicePairsInput
    serviceOffice: ServiceOfficeCreateNestedOneWithoutBusinessUnitServicePairsInput
    serviceTeam: ServiceTeamCreateNestedOneWithoutBusinessUnitServicePairsInput
  }

  export type BusinessUnitServicePairUncheckedCreateWithoutServiceChannelInput = {
    id?: string
    businessUnitCode: string
    serviceOfficeId: string
    serviceTeamCode: string
  }

  export type BusinessUnitServicePairCreateOrConnectWithoutServiceChannelInput = {
    where: BusinessUnitServicePairWhereUniqueInput
    create: XOR<BusinessUnitServicePairCreateWithoutServiceChannelInput, BusinessUnitServicePairUncheckedCreateWithoutServiceChannelInput>
  }

  export type BusinessUnitServicePairCreateManyServiceChannelInputEnvelope = {
    data: BusinessUnitServicePairCreateManyServiceChannelInput | BusinessUnitServicePairCreateManyServiceChannelInput[]
    skipDuplicates?: boolean
  }

  export type ServiceChannelOfficeTeamPairUpsertWithWhereUniqueWithoutServiceChannelInput = {
    where: ServiceChannelOfficeTeamPairWhereUniqueInput
    update: XOR<ServiceChannelOfficeTeamPairUpdateWithoutServiceChannelInput, ServiceChannelOfficeTeamPairUncheckedUpdateWithoutServiceChannelInput>
    create: XOR<ServiceChannelOfficeTeamPairCreateWithoutServiceChannelInput, ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceChannelInput>
  }

  export type ServiceChannelOfficeTeamPairUpdateWithWhereUniqueWithoutServiceChannelInput = {
    where: ServiceChannelOfficeTeamPairWhereUniqueInput
    data: XOR<ServiceChannelOfficeTeamPairUpdateWithoutServiceChannelInput, ServiceChannelOfficeTeamPairUncheckedUpdateWithoutServiceChannelInput>
  }

  export type ServiceChannelOfficeTeamPairUpdateManyWithWhereWithoutServiceChannelInput = {
    where: ServiceChannelOfficeTeamPairScalarWhereInput
    data: XOR<ServiceChannelOfficeTeamPairUpdateManyMutationInput, ServiceChannelOfficeTeamPairUncheckedUpdateManyWithoutServiceChannelInput>
  }

  export type ServiceChannelOfficeTeamPairScalarWhereInput = {
    AND?: ServiceChannelOfficeTeamPairScalarWhereInput | ServiceChannelOfficeTeamPairScalarWhereInput[]
    OR?: ServiceChannelOfficeTeamPairScalarWhereInput[]
    NOT?: ServiceChannelOfficeTeamPairScalarWhereInput | ServiceChannelOfficeTeamPairScalarWhereInput[]
    id?: IntFilter<"ServiceChannelOfficeTeamPair"> | number
    serviceChannelCode?: StringFilter<"ServiceChannelOfficeTeamPair"> | string
    serviceOfficeId?: StringFilter<"ServiceChannelOfficeTeamPair"> | string
    serviceTeamCode?: StringFilter<"ServiceChannelOfficeTeamPair"> | string
  }

  export type BusinessUnitServicePairUpsertWithWhereUniqueWithoutServiceChannelInput = {
    where: BusinessUnitServicePairWhereUniqueInput
    update: XOR<BusinessUnitServicePairUpdateWithoutServiceChannelInput, BusinessUnitServicePairUncheckedUpdateWithoutServiceChannelInput>
    create: XOR<BusinessUnitServicePairCreateWithoutServiceChannelInput, BusinessUnitServicePairUncheckedCreateWithoutServiceChannelInput>
  }

  export type BusinessUnitServicePairUpdateWithWhereUniqueWithoutServiceChannelInput = {
    where: BusinessUnitServicePairWhereUniqueInput
    data: XOR<BusinessUnitServicePairUpdateWithoutServiceChannelInput, BusinessUnitServicePairUncheckedUpdateWithoutServiceChannelInput>
  }

  export type BusinessUnitServicePairUpdateManyWithWhereWithoutServiceChannelInput = {
    where: BusinessUnitServicePairScalarWhereInput
    data: XOR<BusinessUnitServicePairUpdateManyMutationInput, BusinessUnitServicePairUncheckedUpdateManyWithoutServiceChannelInput>
  }

  export type ServiceChannelOfficeTeamPairCreateWithoutServiceOfficeInput = {
    serviceChannel: ServiceChannelCreateNestedOneWithoutChannelOfficePairsInput
    serviceTeam: ServiceTeamCreateNestedOneWithoutOfficeTeamPairsInput
  }

  export type ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceOfficeInput = {
    id?: number
    serviceChannelCode: string
    serviceTeamCode: string
  }

  export type ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceOfficeInput = {
    where: ServiceChannelOfficeTeamPairWhereUniqueInput
    create: XOR<ServiceChannelOfficeTeamPairCreateWithoutServiceOfficeInput, ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceOfficeInput>
  }

  export type ServiceChannelOfficeTeamPairCreateManyServiceOfficeInputEnvelope = {
    data: ServiceChannelOfficeTeamPairCreateManyServiceOfficeInput | ServiceChannelOfficeTeamPairCreateManyServiceOfficeInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUnitServicePairCreateWithoutServiceOfficeInput = {
    id?: string
    businessUnit: BusinessUnitCreateNestedOneWithoutBusinessUnitServicePairsInput
    serviceChannel: ServiceChannelCreateNestedOneWithoutBusinessUnitServicePairsInput
    serviceTeam: ServiceTeamCreateNestedOneWithoutBusinessUnitServicePairsInput
  }

  export type BusinessUnitServicePairUncheckedCreateWithoutServiceOfficeInput = {
    id?: string
    businessUnitCode: string
    serviceChannelCode: string
    serviceTeamCode: string
  }

  export type BusinessUnitServicePairCreateOrConnectWithoutServiceOfficeInput = {
    where: BusinessUnitServicePairWhereUniqueInput
    create: XOR<BusinessUnitServicePairCreateWithoutServiceOfficeInput, BusinessUnitServicePairUncheckedCreateWithoutServiceOfficeInput>
  }

  export type BusinessUnitServicePairCreateManyServiceOfficeInputEnvelope = {
    data: BusinessUnitServicePairCreateManyServiceOfficeInput | BusinessUnitServicePairCreateManyServiceOfficeInput[]
    skipDuplicates?: boolean
  }

  export type ServiceChannelOfficeTeamPairUpsertWithWhereUniqueWithoutServiceOfficeInput = {
    where: ServiceChannelOfficeTeamPairWhereUniqueInput
    update: XOR<ServiceChannelOfficeTeamPairUpdateWithoutServiceOfficeInput, ServiceChannelOfficeTeamPairUncheckedUpdateWithoutServiceOfficeInput>
    create: XOR<ServiceChannelOfficeTeamPairCreateWithoutServiceOfficeInput, ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceOfficeInput>
  }

  export type ServiceChannelOfficeTeamPairUpdateWithWhereUniqueWithoutServiceOfficeInput = {
    where: ServiceChannelOfficeTeamPairWhereUniqueInput
    data: XOR<ServiceChannelOfficeTeamPairUpdateWithoutServiceOfficeInput, ServiceChannelOfficeTeamPairUncheckedUpdateWithoutServiceOfficeInput>
  }

  export type ServiceChannelOfficeTeamPairUpdateManyWithWhereWithoutServiceOfficeInput = {
    where: ServiceChannelOfficeTeamPairScalarWhereInput
    data: XOR<ServiceChannelOfficeTeamPairUpdateManyMutationInput, ServiceChannelOfficeTeamPairUncheckedUpdateManyWithoutServiceOfficeInput>
  }

  export type BusinessUnitServicePairUpsertWithWhereUniqueWithoutServiceOfficeInput = {
    where: BusinessUnitServicePairWhereUniqueInput
    update: XOR<BusinessUnitServicePairUpdateWithoutServiceOfficeInput, BusinessUnitServicePairUncheckedUpdateWithoutServiceOfficeInput>
    create: XOR<BusinessUnitServicePairCreateWithoutServiceOfficeInput, BusinessUnitServicePairUncheckedCreateWithoutServiceOfficeInput>
  }

  export type BusinessUnitServicePairUpdateWithWhereUniqueWithoutServiceOfficeInput = {
    where: BusinessUnitServicePairWhereUniqueInput
    data: XOR<BusinessUnitServicePairUpdateWithoutServiceOfficeInput, BusinessUnitServicePairUncheckedUpdateWithoutServiceOfficeInput>
  }

  export type BusinessUnitServicePairUpdateManyWithWhereWithoutServiceOfficeInput = {
    where: BusinessUnitServicePairScalarWhereInput
    data: XOR<BusinessUnitServicePairUpdateManyMutationInput, BusinessUnitServicePairUncheckedUpdateManyWithoutServiceOfficeInput>
  }

  export type ServiceChannelOfficeTeamPairCreateWithoutServiceTeamInput = {
    serviceChannel: ServiceChannelCreateNestedOneWithoutChannelOfficePairsInput
    serviceOffice: ServiceOfficeCreateNestedOneWithoutOfficeTeamPairsInput
  }

  export type ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceTeamInput = {
    id?: number
    serviceChannelCode: string
    serviceOfficeId: string
  }

  export type ServiceChannelOfficeTeamPairCreateOrConnectWithoutServiceTeamInput = {
    where: ServiceChannelOfficeTeamPairWhereUniqueInput
    create: XOR<ServiceChannelOfficeTeamPairCreateWithoutServiceTeamInput, ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceTeamInput>
  }

  export type ServiceChannelOfficeTeamPairCreateManyServiceTeamInputEnvelope = {
    data: ServiceChannelOfficeTeamPairCreateManyServiceTeamInput | ServiceChannelOfficeTeamPairCreateManyServiceTeamInput[]
    skipDuplicates?: boolean
  }

  export type BusinessUnitServicePairCreateWithoutServiceTeamInput = {
    id?: string
    businessUnit: BusinessUnitCreateNestedOneWithoutBusinessUnitServicePairsInput
    serviceChannel: ServiceChannelCreateNestedOneWithoutBusinessUnitServicePairsInput
    serviceOffice: ServiceOfficeCreateNestedOneWithoutBusinessUnitServicePairsInput
  }

  export type BusinessUnitServicePairUncheckedCreateWithoutServiceTeamInput = {
    id?: string
    businessUnitCode: string
    serviceChannelCode: string
    serviceOfficeId: string
  }

  export type BusinessUnitServicePairCreateOrConnectWithoutServiceTeamInput = {
    where: BusinessUnitServicePairWhereUniqueInput
    create: XOR<BusinessUnitServicePairCreateWithoutServiceTeamInput, BusinessUnitServicePairUncheckedCreateWithoutServiceTeamInput>
  }

  export type BusinessUnitServicePairCreateManyServiceTeamInputEnvelope = {
    data: BusinessUnitServicePairCreateManyServiceTeamInput | BusinessUnitServicePairCreateManyServiceTeamInput[]
    skipDuplicates?: boolean
  }

  export type ServiceChannelOfficeTeamPairUpsertWithWhereUniqueWithoutServiceTeamInput = {
    where: ServiceChannelOfficeTeamPairWhereUniqueInput
    update: XOR<ServiceChannelOfficeTeamPairUpdateWithoutServiceTeamInput, ServiceChannelOfficeTeamPairUncheckedUpdateWithoutServiceTeamInput>
    create: XOR<ServiceChannelOfficeTeamPairCreateWithoutServiceTeamInput, ServiceChannelOfficeTeamPairUncheckedCreateWithoutServiceTeamInput>
  }

  export type ServiceChannelOfficeTeamPairUpdateWithWhereUniqueWithoutServiceTeamInput = {
    where: ServiceChannelOfficeTeamPairWhereUniqueInput
    data: XOR<ServiceChannelOfficeTeamPairUpdateWithoutServiceTeamInput, ServiceChannelOfficeTeamPairUncheckedUpdateWithoutServiceTeamInput>
  }

  export type ServiceChannelOfficeTeamPairUpdateManyWithWhereWithoutServiceTeamInput = {
    where: ServiceChannelOfficeTeamPairScalarWhereInput
    data: XOR<ServiceChannelOfficeTeamPairUpdateManyMutationInput, ServiceChannelOfficeTeamPairUncheckedUpdateManyWithoutServiceTeamInput>
  }

  export type BusinessUnitServicePairUpsertWithWhereUniqueWithoutServiceTeamInput = {
    where: BusinessUnitServicePairWhereUniqueInput
    update: XOR<BusinessUnitServicePairUpdateWithoutServiceTeamInput, BusinessUnitServicePairUncheckedUpdateWithoutServiceTeamInput>
    create: XOR<BusinessUnitServicePairCreateWithoutServiceTeamInput, BusinessUnitServicePairUncheckedCreateWithoutServiceTeamInput>
  }

  export type BusinessUnitServicePairUpdateWithWhereUniqueWithoutServiceTeamInput = {
    where: BusinessUnitServicePairWhereUniqueInput
    data: XOR<BusinessUnitServicePairUpdateWithoutServiceTeamInput, BusinessUnitServicePairUncheckedUpdateWithoutServiceTeamInput>
  }

  export type BusinessUnitServicePairUpdateManyWithWhereWithoutServiceTeamInput = {
    where: BusinessUnitServicePairScalarWhereInput
    data: XOR<BusinessUnitServicePairUpdateManyMutationInput, BusinessUnitServicePairUncheckedUpdateManyWithoutServiceTeamInput>
  }

  export type ServiceChannelCreateWithoutChannelOfficePairsInput = {
    serviceChannelCode: string
    serviceChannelName: string
    serviceChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitServicePairs?: BusinessUnitServicePairCreateNestedManyWithoutServiceChannelInput
  }

  export type ServiceChannelUncheckedCreateWithoutChannelOfficePairsInput = {
    id?: number
    serviceChannelCode: string
    serviceChannelName: string
    serviceChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitServicePairs?: BusinessUnitServicePairUncheckedCreateNestedManyWithoutServiceChannelInput
  }

  export type ServiceChannelCreateOrConnectWithoutChannelOfficePairsInput = {
    where: ServiceChannelWhereUniqueInput
    create: XOR<ServiceChannelCreateWithoutChannelOfficePairsInput, ServiceChannelUncheckedCreateWithoutChannelOfficePairsInput>
  }

  export type ServiceOfficeCreateWithoutOfficeTeamPairsInput = {
    serviceOfficeId: string
    organizationName: string
    serviceOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitServicePairs?: BusinessUnitServicePairCreateNestedManyWithoutServiceOfficeInput
  }

  export type ServiceOfficeUncheckedCreateWithoutOfficeTeamPairsInput = {
    id?: number
    serviceOfficeId: string
    organizationName: string
    serviceOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitServicePairs?: BusinessUnitServicePairUncheckedCreateNestedManyWithoutServiceOfficeInput
  }

  export type ServiceOfficeCreateOrConnectWithoutOfficeTeamPairsInput = {
    where: ServiceOfficeWhereUniqueInput
    create: XOR<ServiceOfficeCreateWithoutOfficeTeamPairsInput, ServiceOfficeUncheckedCreateWithoutOfficeTeamPairsInput>
  }

  export type ServiceTeamCreateWithoutOfficeTeamPairsInput = {
    serviceTeamCode: string
    serviceTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitServicePairs?: BusinessUnitServicePairCreateNestedManyWithoutServiceTeamInput
  }

  export type ServiceTeamUncheckedCreateWithoutOfficeTeamPairsInput = {
    id?: number
    serviceTeamCode: string
    serviceTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    businessUnitServicePairs?: BusinessUnitServicePairUncheckedCreateNestedManyWithoutServiceTeamInput
  }

  export type ServiceTeamCreateOrConnectWithoutOfficeTeamPairsInput = {
    where: ServiceTeamWhereUniqueInput
    create: XOR<ServiceTeamCreateWithoutOfficeTeamPairsInput, ServiceTeamUncheckedCreateWithoutOfficeTeamPairsInput>
  }

  export type ServiceChannelUpsertWithoutChannelOfficePairsInput = {
    update: XOR<ServiceChannelUpdateWithoutChannelOfficePairsInput, ServiceChannelUncheckedUpdateWithoutChannelOfficePairsInput>
    create: XOR<ServiceChannelCreateWithoutChannelOfficePairsInput, ServiceChannelUncheckedCreateWithoutChannelOfficePairsInput>
    where?: ServiceChannelWhereInput
  }

  export type ServiceChannelUpdateToOneWithWhereWithoutChannelOfficePairsInput = {
    where?: ServiceChannelWhereInput
    data: XOR<ServiceChannelUpdateWithoutChannelOfficePairsInput, ServiceChannelUncheckedUpdateWithoutChannelOfficePairsInput>
  }

  export type ServiceChannelUpdateWithoutChannelOfficePairsInput = {
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceChannelName?: StringFieldUpdateOperationsInput | string
    serviceChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitServicePairs?: BusinessUnitServicePairUpdateManyWithoutServiceChannelNestedInput
  }

  export type ServiceChannelUncheckedUpdateWithoutChannelOfficePairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceChannelName?: StringFieldUpdateOperationsInput | string
    serviceChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitServicePairs?: BusinessUnitServicePairUncheckedUpdateManyWithoutServiceChannelNestedInput
  }

  export type ServiceOfficeUpsertWithoutOfficeTeamPairsInput = {
    update: XOR<ServiceOfficeUpdateWithoutOfficeTeamPairsInput, ServiceOfficeUncheckedUpdateWithoutOfficeTeamPairsInput>
    create: XOR<ServiceOfficeCreateWithoutOfficeTeamPairsInput, ServiceOfficeUncheckedCreateWithoutOfficeTeamPairsInput>
    where?: ServiceOfficeWhereInput
  }

  export type ServiceOfficeUpdateToOneWithWhereWithoutOfficeTeamPairsInput = {
    where?: ServiceOfficeWhereInput
    data: XOR<ServiceOfficeUpdateWithoutOfficeTeamPairsInput, ServiceOfficeUncheckedUpdateWithoutOfficeTeamPairsInput>
  }

  export type ServiceOfficeUpdateWithoutOfficeTeamPairsInput = {
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    serviceOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitServicePairs?: BusinessUnitServicePairUpdateManyWithoutServiceOfficeNestedInput
  }

  export type ServiceOfficeUncheckedUpdateWithoutOfficeTeamPairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    serviceOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitServicePairs?: BusinessUnitServicePairUncheckedUpdateManyWithoutServiceOfficeNestedInput
  }

  export type ServiceTeamUpsertWithoutOfficeTeamPairsInput = {
    update: XOR<ServiceTeamUpdateWithoutOfficeTeamPairsInput, ServiceTeamUncheckedUpdateWithoutOfficeTeamPairsInput>
    create: XOR<ServiceTeamCreateWithoutOfficeTeamPairsInput, ServiceTeamUncheckedCreateWithoutOfficeTeamPairsInput>
    where?: ServiceTeamWhereInput
  }

  export type ServiceTeamUpdateToOneWithWhereWithoutOfficeTeamPairsInput = {
    where?: ServiceTeamWhereInput
    data: XOR<ServiceTeamUpdateWithoutOfficeTeamPairsInput, ServiceTeamUncheckedUpdateWithoutOfficeTeamPairsInput>
  }

  export type ServiceTeamUpdateWithoutOfficeTeamPairsInput = {
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
    serviceTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitServicePairs?: BusinessUnitServicePairUpdateManyWithoutServiceTeamNestedInput
  }

  export type ServiceTeamUncheckedUpdateWithoutOfficeTeamPairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
    serviceTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnitServicePairs?: BusinessUnitServicePairUncheckedUpdateManyWithoutServiceTeamNestedInput
  }

  export type BusinessUnitCreateWithoutBusinessUnitSalesPairsInput = {
    businessUnitCode: string
    businessUnitDesc: string
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    entityUnitPairs?: BusinessEntityUnitPairCreateNestedManyWithoutBusinessUnitInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairCreateNestedManyWithoutBusinessUnitInput
    businessUnitServicePairs?: BusinessUnitServicePairCreateNestedManyWithoutBusinessUnitInput
  }

  export type BusinessUnitUncheckedCreateWithoutBusinessUnitSalesPairsInput = {
    id?: number
    businessUnitCode: string
    businessUnitDesc: string
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    entityUnitPairs?: BusinessEntityUnitPairUncheckedCreateNestedManyWithoutBusinessUnitInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUncheckedCreateNestedManyWithoutBusinessUnitInput
    businessUnitServicePairs?: BusinessUnitServicePairUncheckedCreateNestedManyWithoutBusinessUnitInput
  }

  export type BusinessUnitCreateOrConnectWithoutBusinessUnitSalesPairsInput = {
    where: BusinessUnitWhereUniqueInput
    create: XOR<BusinessUnitCreateWithoutBusinessUnitSalesPairsInput, BusinessUnitUncheckedCreateWithoutBusinessUnitSalesPairsInput>
  }

  export type SalesChannelCreateWithoutBusinessUnitSalesPairsInput = {
    salesChannelCode: string
    salesChannelName: string
    salesChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    channelOfficePairs?: SalesChannelOfficeTeamPairCreateNestedManyWithoutSalesChannelInput
  }

  export type SalesChannelUncheckedCreateWithoutBusinessUnitSalesPairsInput = {
    id?: number
    salesChannelCode: string
    salesChannelName: string
    salesChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    channelOfficePairs?: SalesChannelOfficeTeamPairUncheckedCreateNestedManyWithoutSalesChannelInput
  }

  export type SalesChannelCreateOrConnectWithoutBusinessUnitSalesPairsInput = {
    where: SalesChannelWhereUniqueInput
    create: XOR<SalesChannelCreateWithoutBusinessUnitSalesPairsInput, SalesChannelUncheckedCreateWithoutBusinessUnitSalesPairsInput>
  }

  export type SalesOfficeCreateWithoutBusinessUnitSalesPairsInput = {
    salesOfficeId: string
    organizationName: string
    salesOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: SalesChannelOfficeTeamPairCreateNestedManyWithoutSalesOfficeInput
  }

  export type SalesOfficeUncheckedCreateWithoutBusinessUnitSalesPairsInput = {
    id?: number
    salesOfficeId: string
    organizationName: string
    salesOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: SalesChannelOfficeTeamPairUncheckedCreateNestedManyWithoutSalesOfficeInput
  }

  export type SalesOfficeCreateOrConnectWithoutBusinessUnitSalesPairsInput = {
    where: SalesOfficeWhereUniqueInput
    create: XOR<SalesOfficeCreateWithoutBusinessUnitSalesPairsInput, SalesOfficeUncheckedCreateWithoutBusinessUnitSalesPairsInput>
  }

  export type SalesTeamCreateWithoutBusinessUnitSalesPairsInput = {
    salesTeamCode: string
    salesTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: SalesChannelOfficeTeamPairCreateNestedManyWithoutSalesTeamInput
  }

  export type SalesTeamUncheckedCreateWithoutBusinessUnitSalesPairsInput = {
    id?: number
    salesTeamCode: string
    salesTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: SalesChannelOfficeTeamPairUncheckedCreateNestedManyWithoutSalesTeamInput
  }

  export type SalesTeamCreateOrConnectWithoutBusinessUnitSalesPairsInput = {
    where: SalesTeamWhereUniqueInput
    create: XOR<SalesTeamCreateWithoutBusinessUnitSalesPairsInput, SalesTeamUncheckedCreateWithoutBusinessUnitSalesPairsInput>
  }

  export type BusinessUnitUpsertWithoutBusinessUnitSalesPairsInput = {
    update: XOR<BusinessUnitUpdateWithoutBusinessUnitSalesPairsInput, BusinessUnitUncheckedUpdateWithoutBusinessUnitSalesPairsInput>
    create: XOR<BusinessUnitCreateWithoutBusinessUnitSalesPairsInput, BusinessUnitUncheckedCreateWithoutBusinessUnitSalesPairsInput>
    where?: BusinessUnitWhereInput
  }

  export type BusinessUnitUpdateToOneWithWhereWithoutBusinessUnitSalesPairsInput = {
    where?: BusinessUnitWhereInput
    data: XOR<BusinessUnitUpdateWithoutBusinessUnitSalesPairsInput, BusinessUnitUncheckedUpdateWithoutBusinessUnitSalesPairsInput>
  }

  export type BusinessUnitUpdateWithoutBusinessUnitSalesPairsInput = {
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    businessUnitDesc?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityUnitPairs?: BusinessEntityUnitPairUpdateManyWithoutBusinessUnitNestedInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUpdateManyWithoutBusinessUnitNestedInput
    businessUnitServicePairs?: BusinessUnitServicePairUpdateManyWithoutBusinessUnitNestedInput
  }

  export type BusinessUnitUncheckedUpdateWithoutBusinessUnitSalesPairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    businessUnitDesc?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityUnitPairs?: BusinessEntityUnitPairUncheckedUpdateManyWithoutBusinessUnitNestedInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUncheckedUpdateManyWithoutBusinessUnitNestedInput
    businessUnitServicePairs?: BusinessUnitServicePairUncheckedUpdateManyWithoutBusinessUnitNestedInput
  }

  export type SalesChannelUpsertWithoutBusinessUnitSalesPairsInput = {
    update: XOR<SalesChannelUpdateWithoutBusinessUnitSalesPairsInput, SalesChannelUncheckedUpdateWithoutBusinessUnitSalesPairsInput>
    create: XOR<SalesChannelCreateWithoutBusinessUnitSalesPairsInput, SalesChannelUncheckedCreateWithoutBusinessUnitSalesPairsInput>
    where?: SalesChannelWhereInput
  }

  export type SalesChannelUpdateToOneWithWhereWithoutBusinessUnitSalesPairsInput = {
    where?: SalesChannelWhereInput
    data: XOR<SalesChannelUpdateWithoutBusinessUnitSalesPairsInput, SalesChannelUncheckedUpdateWithoutBusinessUnitSalesPairsInput>
  }

  export type SalesChannelUpdateWithoutBusinessUnitSalesPairsInput = {
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesChannelName?: StringFieldUpdateOperationsInput | string
    salesChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channelOfficePairs?: SalesChannelOfficeTeamPairUpdateManyWithoutSalesChannelNestedInput
  }

  export type SalesChannelUncheckedUpdateWithoutBusinessUnitSalesPairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesChannelName?: StringFieldUpdateOperationsInput | string
    salesChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channelOfficePairs?: SalesChannelOfficeTeamPairUncheckedUpdateManyWithoutSalesChannelNestedInput
  }

  export type SalesOfficeUpsertWithoutBusinessUnitSalesPairsInput = {
    update: XOR<SalesOfficeUpdateWithoutBusinessUnitSalesPairsInput, SalesOfficeUncheckedUpdateWithoutBusinessUnitSalesPairsInput>
    create: XOR<SalesOfficeCreateWithoutBusinessUnitSalesPairsInput, SalesOfficeUncheckedCreateWithoutBusinessUnitSalesPairsInput>
    where?: SalesOfficeWhereInput
  }

  export type SalesOfficeUpdateToOneWithWhereWithoutBusinessUnitSalesPairsInput = {
    where?: SalesOfficeWhereInput
    data: XOR<SalesOfficeUpdateWithoutBusinessUnitSalesPairsInput, SalesOfficeUncheckedUpdateWithoutBusinessUnitSalesPairsInput>
  }

  export type SalesOfficeUpdateWithoutBusinessUnitSalesPairsInput = {
    salesOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    salesOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: SalesChannelOfficeTeamPairUpdateManyWithoutSalesOfficeNestedInput
  }

  export type SalesOfficeUncheckedUpdateWithoutBusinessUnitSalesPairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    salesOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: SalesChannelOfficeTeamPairUncheckedUpdateManyWithoutSalesOfficeNestedInput
  }

  export type SalesTeamUpsertWithoutBusinessUnitSalesPairsInput = {
    update: XOR<SalesTeamUpdateWithoutBusinessUnitSalesPairsInput, SalesTeamUncheckedUpdateWithoutBusinessUnitSalesPairsInput>
    create: XOR<SalesTeamCreateWithoutBusinessUnitSalesPairsInput, SalesTeamUncheckedCreateWithoutBusinessUnitSalesPairsInput>
    where?: SalesTeamWhereInput
  }

  export type SalesTeamUpdateToOneWithWhereWithoutBusinessUnitSalesPairsInput = {
    where?: SalesTeamWhereInput
    data: XOR<SalesTeamUpdateWithoutBusinessUnitSalesPairsInput, SalesTeamUncheckedUpdateWithoutBusinessUnitSalesPairsInput>
  }

  export type SalesTeamUpdateWithoutBusinessUnitSalesPairsInput = {
    salesTeamCode?: StringFieldUpdateOperationsInput | string
    salesTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: SalesChannelOfficeTeamPairUpdateManyWithoutSalesTeamNestedInput
  }

  export type SalesTeamUncheckedUpdateWithoutBusinessUnitSalesPairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesTeamCode?: StringFieldUpdateOperationsInput | string
    salesTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: SalesChannelOfficeTeamPairUncheckedUpdateManyWithoutSalesTeamNestedInput
  }

  export type BusinessUnitCreateWithoutBusinessUnitMarketingPairsInput = {
    businessUnitCode: string
    businessUnitDesc: string
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    entityUnitPairs?: BusinessEntityUnitPairCreateNestedManyWithoutBusinessUnitInput
    businessUnitSalesPairs?: BusinessUnitSalesPairCreateNestedManyWithoutBusinessUnitInput
    businessUnitServicePairs?: BusinessUnitServicePairCreateNestedManyWithoutBusinessUnitInput
  }

  export type BusinessUnitUncheckedCreateWithoutBusinessUnitMarketingPairsInput = {
    id?: number
    businessUnitCode: string
    businessUnitDesc: string
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    entityUnitPairs?: BusinessEntityUnitPairUncheckedCreateNestedManyWithoutBusinessUnitInput
    businessUnitSalesPairs?: BusinessUnitSalesPairUncheckedCreateNestedManyWithoutBusinessUnitInput
    businessUnitServicePairs?: BusinessUnitServicePairUncheckedCreateNestedManyWithoutBusinessUnitInput
  }

  export type BusinessUnitCreateOrConnectWithoutBusinessUnitMarketingPairsInput = {
    where: BusinessUnitWhereUniqueInput
    create: XOR<BusinessUnitCreateWithoutBusinessUnitMarketingPairsInput, BusinessUnitUncheckedCreateWithoutBusinessUnitMarketingPairsInput>
  }

  export type MarketingChannelCreateWithoutBusinessUnitMarketingPairsInput = {
    marketingChannelCode: string
    marketingChannelName: string
    marketingChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    channelOfficePairs?: MarketingChannelOfficeTeamPairCreateNestedManyWithoutMarketingChannelInput
  }

  export type MarketingChannelUncheckedCreateWithoutBusinessUnitMarketingPairsInput = {
    id?: number
    marketingChannelCode: string
    marketingChannelName: string
    marketingChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    channelOfficePairs?: MarketingChannelOfficeTeamPairUncheckedCreateNestedManyWithoutMarketingChannelInput
  }

  export type MarketingChannelCreateOrConnectWithoutBusinessUnitMarketingPairsInput = {
    where: MarketingChannelWhereUniqueInput
    create: XOR<MarketingChannelCreateWithoutBusinessUnitMarketingPairsInput, MarketingChannelUncheckedCreateWithoutBusinessUnitMarketingPairsInput>
  }

  export type MarketingOfficeCreateWithoutBusinessUnitMarketingPairsInput = {
    marketingOfficeId: string
    organizationName: string
    marketingOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: MarketingChannelOfficeTeamPairCreateNestedManyWithoutMarketingOfficeInput
  }

  export type MarketingOfficeUncheckedCreateWithoutBusinessUnitMarketingPairsInput = {
    id?: number
    marketingOfficeId: string
    organizationName: string
    marketingOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: MarketingChannelOfficeTeamPairUncheckedCreateNestedManyWithoutMarketingOfficeInput
  }

  export type MarketingOfficeCreateOrConnectWithoutBusinessUnitMarketingPairsInput = {
    where: MarketingOfficeWhereUniqueInput
    create: XOR<MarketingOfficeCreateWithoutBusinessUnitMarketingPairsInput, MarketingOfficeUncheckedCreateWithoutBusinessUnitMarketingPairsInput>
  }

  export type MarketingTeamCreateWithoutBusinessUnitMarketingPairsInput = {
    marketingTeamCode: string
    marketingTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: MarketingChannelOfficeTeamPairCreateNestedManyWithoutMarketingTeamInput
  }

  export type MarketingTeamUncheckedCreateWithoutBusinessUnitMarketingPairsInput = {
    id?: number
    marketingTeamCode: string
    marketingTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: MarketingChannelOfficeTeamPairUncheckedCreateNestedManyWithoutMarketingTeamInput
  }

  export type MarketingTeamCreateOrConnectWithoutBusinessUnitMarketingPairsInput = {
    where: MarketingTeamWhereUniqueInput
    create: XOR<MarketingTeamCreateWithoutBusinessUnitMarketingPairsInput, MarketingTeamUncheckedCreateWithoutBusinessUnitMarketingPairsInput>
  }

  export type BusinessUnitUpsertWithoutBusinessUnitMarketingPairsInput = {
    update: XOR<BusinessUnitUpdateWithoutBusinessUnitMarketingPairsInput, BusinessUnitUncheckedUpdateWithoutBusinessUnitMarketingPairsInput>
    create: XOR<BusinessUnitCreateWithoutBusinessUnitMarketingPairsInput, BusinessUnitUncheckedCreateWithoutBusinessUnitMarketingPairsInput>
    where?: BusinessUnitWhereInput
  }

  export type BusinessUnitUpdateToOneWithWhereWithoutBusinessUnitMarketingPairsInput = {
    where?: BusinessUnitWhereInput
    data: XOR<BusinessUnitUpdateWithoutBusinessUnitMarketingPairsInput, BusinessUnitUncheckedUpdateWithoutBusinessUnitMarketingPairsInput>
  }

  export type BusinessUnitUpdateWithoutBusinessUnitMarketingPairsInput = {
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    businessUnitDesc?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityUnitPairs?: BusinessEntityUnitPairUpdateManyWithoutBusinessUnitNestedInput
    businessUnitSalesPairs?: BusinessUnitSalesPairUpdateManyWithoutBusinessUnitNestedInput
    businessUnitServicePairs?: BusinessUnitServicePairUpdateManyWithoutBusinessUnitNestedInput
  }

  export type BusinessUnitUncheckedUpdateWithoutBusinessUnitMarketingPairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    businessUnitDesc?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityUnitPairs?: BusinessEntityUnitPairUncheckedUpdateManyWithoutBusinessUnitNestedInput
    businessUnitSalesPairs?: BusinessUnitSalesPairUncheckedUpdateManyWithoutBusinessUnitNestedInput
    businessUnitServicePairs?: BusinessUnitServicePairUncheckedUpdateManyWithoutBusinessUnitNestedInput
  }

  export type MarketingChannelUpsertWithoutBusinessUnitMarketingPairsInput = {
    update: XOR<MarketingChannelUpdateWithoutBusinessUnitMarketingPairsInput, MarketingChannelUncheckedUpdateWithoutBusinessUnitMarketingPairsInput>
    create: XOR<MarketingChannelCreateWithoutBusinessUnitMarketingPairsInput, MarketingChannelUncheckedCreateWithoutBusinessUnitMarketingPairsInput>
    where?: MarketingChannelWhereInput
  }

  export type MarketingChannelUpdateToOneWithWhereWithoutBusinessUnitMarketingPairsInput = {
    where?: MarketingChannelWhereInput
    data: XOR<MarketingChannelUpdateWithoutBusinessUnitMarketingPairsInput, MarketingChannelUncheckedUpdateWithoutBusinessUnitMarketingPairsInput>
  }

  export type MarketingChannelUpdateWithoutBusinessUnitMarketingPairsInput = {
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingChannelName?: StringFieldUpdateOperationsInput | string
    marketingChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channelOfficePairs?: MarketingChannelOfficeTeamPairUpdateManyWithoutMarketingChannelNestedInput
  }

  export type MarketingChannelUncheckedUpdateWithoutBusinessUnitMarketingPairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingChannelName?: StringFieldUpdateOperationsInput | string
    marketingChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channelOfficePairs?: MarketingChannelOfficeTeamPairUncheckedUpdateManyWithoutMarketingChannelNestedInput
  }

  export type MarketingOfficeUpsertWithoutBusinessUnitMarketingPairsInput = {
    update: XOR<MarketingOfficeUpdateWithoutBusinessUnitMarketingPairsInput, MarketingOfficeUncheckedUpdateWithoutBusinessUnitMarketingPairsInput>
    create: XOR<MarketingOfficeCreateWithoutBusinessUnitMarketingPairsInput, MarketingOfficeUncheckedCreateWithoutBusinessUnitMarketingPairsInput>
    where?: MarketingOfficeWhereInput
  }

  export type MarketingOfficeUpdateToOneWithWhereWithoutBusinessUnitMarketingPairsInput = {
    where?: MarketingOfficeWhereInput
    data: XOR<MarketingOfficeUpdateWithoutBusinessUnitMarketingPairsInput, MarketingOfficeUncheckedUpdateWithoutBusinessUnitMarketingPairsInput>
  }

  export type MarketingOfficeUpdateWithoutBusinessUnitMarketingPairsInput = {
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    marketingOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: MarketingChannelOfficeTeamPairUpdateManyWithoutMarketingOfficeNestedInput
  }

  export type MarketingOfficeUncheckedUpdateWithoutBusinessUnitMarketingPairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    marketingOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: MarketingChannelOfficeTeamPairUncheckedUpdateManyWithoutMarketingOfficeNestedInput
  }

  export type MarketingTeamUpsertWithoutBusinessUnitMarketingPairsInput = {
    update: XOR<MarketingTeamUpdateWithoutBusinessUnitMarketingPairsInput, MarketingTeamUncheckedUpdateWithoutBusinessUnitMarketingPairsInput>
    create: XOR<MarketingTeamCreateWithoutBusinessUnitMarketingPairsInput, MarketingTeamUncheckedCreateWithoutBusinessUnitMarketingPairsInput>
    where?: MarketingTeamWhereInput
  }

  export type MarketingTeamUpdateToOneWithWhereWithoutBusinessUnitMarketingPairsInput = {
    where?: MarketingTeamWhereInput
    data: XOR<MarketingTeamUpdateWithoutBusinessUnitMarketingPairsInput, MarketingTeamUncheckedUpdateWithoutBusinessUnitMarketingPairsInput>
  }

  export type MarketingTeamUpdateWithoutBusinessUnitMarketingPairsInput = {
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
    marketingTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: MarketingChannelOfficeTeamPairUpdateManyWithoutMarketingTeamNestedInput
  }

  export type MarketingTeamUncheckedUpdateWithoutBusinessUnitMarketingPairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
    marketingTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: MarketingChannelOfficeTeamPairUncheckedUpdateManyWithoutMarketingTeamNestedInput
  }

  export type BusinessUnitCreateWithoutBusinessUnitServicePairsInput = {
    businessUnitCode: string
    businessUnitDesc: string
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    entityUnitPairs?: BusinessEntityUnitPairCreateNestedManyWithoutBusinessUnitInput
    businessUnitSalesPairs?: BusinessUnitSalesPairCreateNestedManyWithoutBusinessUnitInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairCreateNestedManyWithoutBusinessUnitInput
  }

  export type BusinessUnitUncheckedCreateWithoutBusinessUnitServicePairsInput = {
    id?: number
    businessUnitCode: string
    businessUnitDesc: string
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    entityUnitPairs?: BusinessEntityUnitPairUncheckedCreateNestedManyWithoutBusinessUnitInput
    businessUnitSalesPairs?: BusinessUnitSalesPairUncheckedCreateNestedManyWithoutBusinessUnitInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUncheckedCreateNestedManyWithoutBusinessUnitInput
  }

  export type BusinessUnitCreateOrConnectWithoutBusinessUnitServicePairsInput = {
    where: BusinessUnitWhereUniqueInput
    create: XOR<BusinessUnitCreateWithoutBusinessUnitServicePairsInput, BusinessUnitUncheckedCreateWithoutBusinessUnitServicePairsInput>
  }

  export type ServiceChannelCreateWithoutBusinessUnitServicePairsInput = {
    serviceChannelCode: string
    serviceChannelName: string
    serviceChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    channelOfficePairs?: ServiceChannelOfficeTeamPairCreateNestedManyWithoutServiceChannelInput
  }

  export type ServiceChannelUncheckedCreateWithoutBusinessUnitServicePairsInput = {
    id?: number
    serviceChannelCode: string
    serviceChannelName: string
    serviceChannelDesc?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    channelOfficePairs?: ServiceChannelOfficeTeamPairUncheckedCreateNestedManyWithoutServiceChannelInput
  }

  export type ServiceChannelCreateOrConnectWithoutBusinessUnitServicePairsInput = {
    where: ServiceChannelWhereUniqueInput
    create: XOR<ServiceChannelCreateWithoutBusinessUnitServicePairsInput, ServiceChannelUncheckedCreateWithoutBusinessUnitServicePairsInput>
  }

  export type ServiceOfficeCreateWithoutBusinessUnitServicePairsInput = {
    serviceOfficeId: string
    organizationName: string
    serviceOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: ServiceChannelOfficeTeamPairCreateNestedManyWithoutServiceOfficeInput
  }

  export type ServiceOfficeUncheckedCreateWithoutBusinessUnitServicePairsInput = {
    id?: number
    serviceOfficeId: string
    organizationName: string
    serviceOfficeDesc?: string | null
    street1: string
    street2?: string | null
    city: string
    state: string
    region?: string | null
    country: string
    pinCode: string
    validFrom: Date | string
    validTo: Date | string
    company: string
    parentUnit?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: ServiceChannelOfficeTeamPairUncheckedCreateNestedManyWithoutServiceOfficeInput
  }

  export type ServiceOfficeCreateOrConnectWithoutBusinessUnitServicePairsInput = {
    where: ServiceOfficeWhereUniqueInput
    create: XOR<ServiceOfficeCreateWithoutBusinessUnitServicePairsInput, ServiceOfficeUncheckedCreateWithoutBusinessUnitServicePairsInput>
  }

  export type ServiceTeamCreateWithoutBusinessUnitServicePairsInput = {
    serviceTeamCode: string
    serviceTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: ServiceChannelOfficeTeamPairCreateNestedManyWithoutServiceTeamInput
  }

  export type ServiceTeamUncheckedCreateWithoutBusinessUnitServicePairsInput = {
    id?: number
    serviceTeamCode: string
    serviceTeamName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    officeTeamPairs?: ServiceChannelOfficeTeamPairUncheckedCreateNestedManyWithoutServiceTeamInput
  }

  export type ServiceTeamCreateOrConnectWithoutBusinessUnitServicePairsInput = {
    where: ServiceTeamWhereUniqueInput
    create: XOR<ServiceTeamCreateWithoutBusinessUnitServicePairsInput, ServiceTeamUncheckedCreateWithoutBusinessUnitServicePairsInput>
  }

  export type BusinessUnitUpsertWithoutBusinessUnitServicePairsInput = {
    update: XOR<BusinessUnitUpdateWithoutBusinessUnitServicePairsInput, BusinessUnitUncheckedUpdateWithoutBusinessUnitServicePairsInput>
    create: XOR<BusinessUnitCreateWithoutBusinessUnitServicePairsInput, BusinessUnitUncheckedCreateWithoutBusinessUnitServicePairsInput>
    where?: BusinessUnitWhereInput
  }

  export type BusinessUnitUpdateToOneWithWhereWithoutBusinessUnitServicePairsInput = {
    where?: BusinessUnitWhereInput
    data: XOR<BusinessUnitUpdateWithoutBusinessUnitServicePairsInput, BusinessUnitUncheckedUpdateWithoutBusinessUnitServicePairsInput>
  }

  export type BusinessUnitUpdateWithoutBusinessUnitServicePairsInput = {
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    businessUnitDesc?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityUnitPairs?: BusinessEntityUnitPairUpdateManyWithoutBusinessUnitNestedInput
    businessUnitSalesPairs?: BusinessUnitSalesPairUpdateManyWithoutBusinessUnitNestedInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUpdateManyWithoutBusinessUnitNestedInput
  }

  export type BusinessUnitUncheckedUpdateWithoutBusinessUnitServicePairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    businessUnitDesc?: StringFieldUpdateOperationsInput | string
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityUnitPairs?: BusinessEntityUnitPairUncheckedUpdateManyWithoutBusinessUnitNestedInput
    businessUnitSalesPairs?: BusinessUnitSalesPairUncheckedUpdateManyWithoutBusinessUnitNestedInput
    businessUnitMarketingPairs?: BusinessUnitMarketingPairUncheckedUpdateManyWithoutBusinessUnitNestedInput
  }

  export type ServiceChannelUpsertWithoutBusinessUnitServicePairsInput = {
    update: XOR<ServiceChannelUpdateWithoutBusinessUnitServicePairsInput, ServiceChannelUncheckedUpdateWithoutBusinessUnitServicePairsInput>
    create: XOR<ServiceChannelCreateWithoutBusinessUnitServicePairsInput, ServiceChannelUncheckedCreateWithoutBusinessUnitServicePairsInput>
    where?: ServiceChannelWhereInput
  }

  export type ServiceChannelUpdateToOneWithWhereWithoutBusinessUnitServicePairsInput = {
    where?: ServiceChannelWhereInput
    data: XOR<ServiceChannelUpdateWithoutBusinessUnitServicePairsInput, ServiceChannelUncheckedUpdateWithoutBusinessUnitServicePairsInput>
  }

  export type ServiceChannelUpdateWithoutBusinessUnitServicePairsInput = {
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceChannelName?: StringFieldUpdateOperationsInput | string
    serviceChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channelOfficePairs?: ServiceChannelOfficeTeamPairUpdateManyWithoutServiceChannelNestedInput
  }

  export type ServiceChannelUncheckedUpdateWithoutBusinessUnitServicePairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceChannelName?: StringFieldUpdateOperationsInput | string
    serviceChannelDesc?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    channelOfficePairs?: ServiceChannelOfficeTeamPairUncheckedUpdateManyWithoutServiceChannelNestedInput
  }

  export type ServiceOfficeUpsertWithoutBusinessUnitServicePairsInput = {
    update: XOR<ServiceOfficeUpdateWithoutBusinessUnitServicePairsInput, ServiceOfficeUncheckedUpdateWithoutBusinessUnitServicePairsInput>
    create: XOR<ServiceOfficeCreateWithoutBusinessUnitServicePairsInput, ServiceOfficeUncheckedCreateWithoutBusinessUnitServicePairsInput>
    where?: ServiceOfficeWhereInput
  }

  export type ServiceOfficeUpdateToOneWithWhereWithoutBusinessUnitServicePairsInput = {
    where?: ServiceOfficeWhereInput
    data: XOR<ServiceOfficeUpdateWithoutBusinessUnitServicePairsInput, ServiceOfficeUncheckedUpdateWithoutBusinessUnitServicePairsInput>
  }

  export type ServiceOfficeUpdateWithoutBusinessUnitServicePairsInput = {
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    serviceOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: ServiceChannelOfficeTeamPairUpdateManyWithoutServiceOfficeNestedInput
  }

  export type ServiceOfficeUncheckedUpdateWithoutBusinessUnitServicePairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
    organizationName?: StringFieldUpdateOperationsInput | string
    serviceOfficeDesc?: NullableStringFieldUpdateOperationsInput | string | null
    street1?: StringFieldUpdateOperationsInput | string
    street2?: NullableStringFieldUpdateOperationsInput | string | null
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    region?: NullableStringFieldUpdateOperationsInput | string | null
    country?: StringFieldUpdateOperationsInput | string
    pinCode?: StringFieldUpdateOperationsInput | string
    validFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    validTo?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: StringFieldUpdateOperationsInput | string
    parentUnit?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: ServiceChannelOfficeTeamPairUncheckedUpdateManyWithoutServiceOfficeNestedInput
  }

  export type ServiceTeamUpsertWithoutBusinessUnitServicePairsInput = {
    update: XOR<ServiceTeamUpdateWithoutBusinessUnitServicePairsInput, ServiceTeamUncheckedUpdateWithoutBusinessUnitServicePairsInput>
    create: XOR<ServiceTeamCreateWithoutBusinessUnitServicePairsInput, ServiceTeamUncheckedCreateWithoutBusinessUnitServicePairsInput>
    where?: ServiceTeamWhereInput
  }

  export type ServiceTeamUpdateToOneWithWhereWithoutBusinessUnitServicePairsInput = {
    where?: ServiceTeamWhereInput
    data: XOR<ServiceTeamUpdateWithoutBusinessUnitServicePairsInput, ServiceTeamUncheckedUpdateWithoutBusinessUnitServicePairsInput>
  }

  export type ServiceTeamUpdateWithoutBusinessUnitServicePairsInput = {
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
    serviceTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: ServiceChannelOfficeTeamPairUpdateManyWithoutServiceTeamNestedInput
  }

  export type ServiceTeamUncheckedUpdateWithoutBusinessUnitServicePairsInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
    serviceTeamName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    officeTeamPairs?: ServiceChannelOfficeTeamPairUncheckedUpdateManyWithoutServiceTeamNestedInput
  }

  export type BusinessEntityUnitPairCreateManyBusinessEntityInput = {
    id?: number
    businessUnitCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessEntityUnitPairUpdateWithoutBusinessEntityInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessUnit?: BusinessUnitUpdateOneRequiredWithoutEntityUnitPairsNestedInput
  }

  export type BusinessEntityUnitPairUncheckedUpdateWithoutBusinessEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessEntityUnitPairUncheckedUpdateManyWithoutBusinessEntityInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessEntityUnitPairCreateManyBusinessUnitInput = {
    id?: number
    businessEntityCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessUnitSalesPairCreateManyBusinessUnitInput = {
    id?: string
    salesChannelCode: string
    salesOfficeId: string
    salesTeamCode: string
  }

  export type BusinessUnitMarketingPairCreateManyBusinessUnitInput = {
    id?: string
    marketingChannelCode: string
    marketingOfficeId: string
    marketingTeamCode: string
  }

  export type BusinessUnitServicePairCreateManyBusinessUnitInput = {
    id?: string
    serviceChannelCode: string
    serviceOfficeId: string
    serviceTeamCode: string
  }

  export type BusinessEntityUnitPairUpdateWithoutBusinessUnitInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    businessEntity?: BusinessEntityUpdateOneRequiredWithoutEntityUnitPairsNestedInput
  }

  export type BusinessEntityUnitPairUncheckedUpdateWithoutBusinessUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessEntityCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessEntityUnitPairUncheckedUpdateManyWithoutBusinessUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    businessEntityCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessUnitSalesPairUpdateWithoutBusinessUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    salesChannel?: SalesChannelUpdateOneRequiredWithoutBusinessUnitSalesPairsNestedInput
    salesOffice?: SalesOfficeUpdateOneRequiredWithoutBusinessUnitSalesPairsNestedInput
    salesTeam?: SalesTeamUpdateOneRequiredWithoutBusinessUnitSalesPairsNestedInput
  }

  export type BusinessUnitSalesPairUncheckedUpdateWithoutBusinessUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesOfficeId?: StringFieldUpdateOperationsInput | string
    salesTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitSalesPairUncheckedUpdateManyWithoutBusinessUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesOfficeId?: StringFieldUpdateOperationsInput | string
    salesTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitMarketingPairUpdateWithoutBusinessUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketingChannel?: MarketingChannelUpdateOneRequiredWithoutBusinessUnitMarketingPairsNestedInput
    marketingOffice?: MarketingOfficeUpdateOneRequiredWithoutBusinessUnitMarketingPairsNestedInput
    marketingTeam?: MarketingTeamUpdateOneRequiredWithoutBusinessUnitMarketingPairsNestedInput
  }

  export type BusinessUnitMarketingPairUncheckedUpdateWithoutBusinessUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitMarketingPairUncheckedUpdateManyWithoutBusinessUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitServicePairUpdateWithoutBusinessUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceChannel?: ServiceChannelUpdateOneRequiredWithoutBusinessUnitServicePairsNestedInput
    serviceOffice?: ServiceOfficeUpdateOneRequiredWithoutBusinessUnitServicePairsNestedInput
    serviceTeam?: ServiceTeamUpdateOneRequiredWithoutBusinessUnitServicePairsNestedInput
  }

  export type BusinessUnitServicePairUncheckedUpdateWithoutBusinessUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitServicePairUncheckedUpdateManyWithoutBusinessUnitInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type SalesChannelOfficeTeamPairCreateManySalesChannelInput = {
    id?: number
    salesOfficeId: string
    salesTeamCode: string
  }

  export type BusinessUnitSalesPairCreateManySalesChannelInput = {
    id?: string
    businessUnitCode: string
    salesOfficeId: string
    salesTeamCode: string
  }

  export type SalesChannelOfficeTeamPairUpdateWithoutSalesChannelInput = {
    salesOffice?: SalesOfficeUpdateOneRequiredWithoutOfficeTeamPairsNestedInput
    salesTeam?: SalesTeamUpdateOneRequiredWithoutOfficeTeamPairsNestedInput
  }

  export type SalesChannelOfficeTeamPairUncheckedUpdateWithoutSalesChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOfficeId?: StringFieldUpdateOperationsInput | string
    salesTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type SalesChannelOfficeTeamPairUncheckedUpdateManyWithoutSalesChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesOfficeId?: StringFieldUpdateOperationsInput | string
    salesTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitSalesPairUpdateWithoutSalesChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnit?: BusinessUnitUpdateOneRequiredWithoutBusinessUnitSalesPairsNestedInput
    salesOffice?: SalesOfficeUpdateOneRequiredWithoutBusinessUnitSalesPairsNestedInput
    salesTeam?: SalesTeamUpdateOneRequiredWithoutBusinessUnitSalesPairsNestedInput
  }

  export type BusinessUnitSalesPairUncheckedUpdateWithoutSalesChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    salesOfficeId?: StringFieldUpdateOperationsInput | string
    salesTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitSalesPairUncheckedUpdateManyWithoutSalesChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    salesOfficeId?: StringFieldUpdateOperationsInput | string
    salesTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type SalesChannelOfficeTeamPairCreateManySalesOfficeInput = {
    id?: number
    salesChannelCode: string
    salesTeamCode: string
  }

  export type BusinessUnitSalesPairCreateManySalesOfficeInput = {
    id?: string
    businessUnitCode: string
    salesChannelCode: string
    salesTeamCode: string
  }

  export type SalesChannelOfficeTeamPairUpdateWithoutSalesOfficeInput = {
    salesChannel?: SalesChannelUpdateOneRequiredWithoutChannelOfficePairsNestedInput
    salesTeam?: SalesTeamUpdateOneRequiredWithoutOfficeTeamPairsNestedInput
  }

  export type SalesChannelOfficeTeamPairUncheckedUpdateWithoutSalesOfficeInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type SalesChannelOfficeTeamPairUncheckedUpdateManyWithoutSalesOfficeInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitSalesPairUpdateWithoutSalesOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnit?: BusinessUnitUpdateOneRequiredWithoutBusinessUnitSalesPairsNestedInput
    salesChannel?: SalesChannelUpdateOneRequiredWithoutBusinessUnitSalesPairsNestedInput
    salesTeam?: SalesTeamUpdateOneRequiredWithoutBusinessUnitSalesPairsNestedInput
  }

  export type BusinessUnitSalesPairUncheckedUpdateWithoutSalesOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitSalesPairUncheckedUpdateManyWithoutSalesOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type SalesChannelOfficeTeamPairCreateManySalesTeamInput = {
    id?: number
    salesChannelCode: string
    salesOfficeId: string
  }

  export type BusinessUnitSalesPairCreateManySalesTeamInput = {
    id?: string
    businessUnitCode: string
    salesChannelCode: string
    salesOfficeId: string
  }

  export type SalesChannelOfficeTeamPairUpdateWithoutSalesTeamInput = {
    salesChannel?: SalesChannelUpdateOneRequiredWithoutChannelOfficePairsNestedInput
    salesOffice?: SalesOfficeUpdateOneRequiredWithoutOfficeTeamPairsNestedInput
  }

  export type SalesChannelOfficeTeamPairUncheckedUpdateWithoutSalesTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesOfficeId?: StringFieldUpdateOperationsInput | string
  }

  export type SalesChannelOfficeTeamPairUncheckedUpdateManyWithoutSalesTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesOfficeId?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitSalesPairUpdateWithoutSalesTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnit?: BusinessUnitUpdateOneRequiredWithoutBusinessUnitSalesPairsNestedInput
    salesChannel?: SalesChannelUpdateOneRequiredWithoutBusinessUnitSalesPairsNestedInput
    salesOffice?: SalesOfficeUpdateOneRequiredWithoutBusinessUnitSalesPairsNestedInput
  }

  export type BusinessUnitSalesPairUncheckedUpdateWithoutSalesTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesOfficeId?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitSalesPairUncheckedUpdateManyWithoutSalesTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    salesChannelCode?: StringFieldUpdateOperationsInput | string
    salesOfficeId?: StringFieldUpdateOperationsInput | string
  }

  export type MarketingChannelOfficeTeamPairCreateManyMarketingChannelInput = {
    id?: number
    marketingOfficeId: string
    marketingTeamCode: string
  }

  export type BusinessUnitMarketingPairCreateManyMarketingChannelInput = {
    id?: string
    businessUnitCode: string
    marketingOfficeId: string
    marketingTeamCode: string
  }

  export type MarketingChannelOfficeTeamPairUpdateWithoutMarketingChannelInput = {
    marketingOffice?: MarketingOfficeUpdateOneRequiredWithoutOfficeTeamPairsNestedInput
    marketingTeam?: MarketingTeamUpdateOneRequiredWithoutOfficeTeamPairsNestedInput
  }

  export type MarketingChannelOfficeTeamPairUncheckedUpdateWithoutMarketingChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type MarketingChannelOfficeTeamPairUncheckedUpdateManyWithoutMarketingChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitMarketingPairUpdateWithoutMarketingChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnit?: BusinessUnitUpdateOneRequiredWithoutBusinessUnitMarketingPairsNestedInput
    marketingOffice?: MarketingOfficeUpdateOneRequiredWithoutBusinessUnitMarketingPairsNestedInput
    marketingTeam?: MarketingTeamUpdateOneRequiredWithoutBusinessUnitMarketingPairsNestedInput
  }

  export type BusinessUnitMarketingPairUncheckedUpdateWithoutMarketingChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitMarketingPairUncheckedUpdateManyWithoutMarketingChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type MarketingChannelOfficeTeamPairCreateManyMarketingOfficeInput = {
    id?: number
    marketingChannelCode: string
    marketingTeamCode: string
  }

  export type BusinessUnitMarketingPairCreateManyMarketingOfficeInput = {
    id?: string
    businessUnitCode: string
    marketingChannelCode: string
    marketingTeamCode: string
  }

  export type MarketingChannelOfficeTeamPairUpdateWithoutMarketingOfficeInput = {
    marketingChannel?: MarketingChannelUpdateOneRequiredWithoutChannelOfficePairsNestedInput
    marketingTeam?: MarketingTeamUpdateOneRequiredWithoutOfficeTeamPairsNestedInput
  }

  export type MarketingChannelOfficeTeamPairUncheckedUpdateWithoutMarketingOfficeInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type MarketingChannelOfficeTeamPairUncheckedUpdateManyWithoutMarketingOfficeInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitMarketingPairUpdateWithoutMarketingOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnit?: BusinessUnitUpdateOneRequiredWithoutBusinessUnitMarketingPairsNestedInput
    marketingChannel?: MarketingChannelUpdateOneRequiredWithoutBusinessUnitMarketingPairsNestedInput
    marketingTeam?: MarketingTeamUpdateOneRequiredWithoutBusinessUnitMarketingPairsNestedInput
  }

  export type BusinessUnitMarketingPairUncheckedUpdateWithoutMarketingOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitMarketingPairUncheckedUpdateManyWithoutMarketingOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type MarketingChannelOfficeTeamPairCreateManyMarketingTeamInput = {
    id?: number
    marketingChannelCode: string
    marketingOfficeId: string
  }

  export type BusinessUnitMarketingPairCreateManyMarketingTeamInput = {
    id?: string
    businessUnitCode: string
    marketingChannelCode: string
    marketingOfficeId: string
  }

  export type MarketingChannelOfficeTeamPairUpdateWithoutMarketingTeamInput = {
    marketingChannel?: MarketingChannelUpdateOneRequiredWithoutChannelOfficePairsNestedInput
    marketingOffice?: MarketingOfficeUpdateOneRequiredWithoutOfficeTeamPairsNestedInput
  }

  export type MarketingChannelOfficeTeamPairUncheckedUpdateWithoutMarketingTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
  }

  export type MarketingChannelOfficeTeamPairUncheckedUpdateManyWithoutMarketingTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitMarketingPairUpdateWithoutMarketingTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnit?: BusinessUnitUpdateOneRequiredWithoutBusinessUnitMarketingPairsNestedInput
    marketingChannel?: MarketingChannelUpdateOneRequiredWithoutBusinessUnitMarketingPairsNestedInput
    marketingOffice?: MarketingOfficeUpdateOneRequiredWithoutBusinessUnitMarketingPairsNestedInput
  }

  export type BusinessUnitMarketingPairUncheckedUpdateWithoutMarketingTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitMarketingPairUncheckedUpdateManyWithoutMarketingTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    marketingChannelCode?: StringFieldUpdateOperationsInput | string
    marketingOfficeId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceChannelOfficeTeamPairCreateManyServiceChannelInput = {
    id?: number
    serviceOfficeId: string
    serviceTeamCode: string
  }

  export type BusinessUnitServicePairCreateManyServiceChannelInput = {
    id?: string
    businessUnitCode: string
    serviceOfficeId: string
    serviceTeamCode: string
  }

  export type ServiceChannelOfficeTeamPairUpdateWithoutServiceChannelInput = {
    serviceOffice?: ServiceOfficeUpdateOneRequiredWithoutOfficeTeamPairsNestedInput
    serviceTeam?: ServiceTeamUpdateOneRequiredWithoutOfficeTeamPairsNestedInput
  }

  export type ServiceChannelOfficeTeamPairUncheckedUpdateWithoutServiceChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceChannelOfficeTeamPairUncheckedUpdateManyWithoutServiceChannelInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitServicePairUpdateWithoutServiceChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnit?: BusinessUnitUpdateOneRequiredWithoutBusinessUnitServicePairsNestedInput
    serviceOffice?: ServiceOfficeUpdateOneRequiredWithoutBusinessUnitServicePairsNestedInput
    serviceTeam?: ServiceTeamUpdateOneRequiredWithoutBusinessUnitServicePairsNestedInput
  }

  export type BusinessUnitServicePairUncheckedUpdateWithoutServiceChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitServicePairUncheckedUpdateManyWithoutServiceChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceChannelOfficeTeamPairCreateManyServiceOfficeInput = {
    id?: number
    serviceChannelCode: string
    serviceTeamCode: string
  }

  export type BusinessUnitServicePairCreateManyServiceOfficeInput = {
    id?: string
    businessUnitCode: string
    serviceChannelCode: string
    serviceTeamCode: string
  }

  export type ServiceChannelOfficeTeamPairUpdateWithoutServiceOfficeInput = {
    serviceChannel?: ServiceChannelUpdateOneRequiredWithoutChannelOfficePairsNestedInput
    serviceTeam?: ServiceTeamUpdateOneRequiredWithoutOfficeTeamPairsNestedInput
  }

  export type ServiceChannelOfficeTeamPairUncheckedUpdateWithoutServiceOfficeInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceChannelOfficeTeamPairUncheckedUpdateManyWithoutServiceOfficeInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitServicePairUpdateWithoutServiceOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnit?: BusinessUnitUpdateOneRequiredWithoutBusinessUnitServicePairsNestedInput
    serviceChannel?: ServiceChannelUpdateOneRequiredWithoutBusinessUnitServicePairsNestedInput
    serviceTeam?: ServiceTeamUpdateOneRequiredWithoutBusinessUnitServicePairsNestedInput
  }

  export type BusinessUnitServicePairUncheckedUpdateWithoutServiceOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitServicePairUncheckedUpdateManyWithoutServiceOfficeInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceTeamCode?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceChannelOfficeTeamPairCreateManyServiceTeamInput = {
    id?: number
    serviceChannelCode: string
    serviceOfficeId: string
  }

  export type BusinessUnitServicePairCreateManyServiceTeamInput = {
    id?: string
    businessUnitCode: string
    serviceChannelCode: string
    serviceOfficeId: string
  }

  export type ServiceChannelOfficeTeamPairUpdateWithoutServiceTeamInput = {
    serviceChannel?: ServiceChannelUpdateOneRequiredWithoutChannelOfficePairsNestedInput
    serviceOffice?: ServiceOfficeUpdateOneRequiredWithoutOfficeTeamPairsNestedInput
  }

  export type ServiceChannelOfficeTeamPairUncheckedUpdateWithoutServiceTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceChannelOfficeTeamPairUncheckedUpdateManyWithoutServiceTeamInput = {
    id?: IntFieldUpdateOperationsInput | number
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitServicePairUpdateWithoutServiceTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnit?: BusinessUnitUpdateOneRequiredWithoutBusinessUnitServicePairsNestedInput
    serviceChannel?: ServiceChannelUpdateOneRequiredWithoutBusinessUnitServicePairsNestedInput
    serviceOffice?: ServiceOfficeUpdateOneRequiredWithoutBusinessUnitServicePairsNestedInput
  }

  export type BusinessUnitServicePairUncheckedUpdateWithoutServiceTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
  }

  export type BusinessUnitServicePairUncheckedUpdateManyWithoutServiceTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    businessUnitCode?: StringFieldUpdateOperationsInput | string
    serviceChannelCode?: StringFieldUpdateOperationsInput | string
    serviceOfficeId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}